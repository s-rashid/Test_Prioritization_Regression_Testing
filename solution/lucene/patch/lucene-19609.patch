diff --git a/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ContentSource.java b/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ContentSource.java
index 4af7dde..cfe377c 100644
--- a/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ContentSource.java
+++ b/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ContentSource.java
@@ -17,19 +17,11 @@ package org.apache.lucene.benchmark.byTask.feeds;
  * limitations under the License.
  */
 
-import java.io.BufferedInputStream;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Locale;
-import java.util.Map;
 
-import org.apache.commons.compress.compressors.CompressorException;
-import org.apache.commons.compress.compressors.CompressorStreamFactory;
 import org.apache.lucene.benchmark.byTask.utils.Config;
 
 /**
@@ -56,17 +48,6 @@ import org.apache.lucene.benchmark.byTask.utils.Config;
  */
 public abstract class ContentSource {
   
-  private static final Map<String,String> extensionToType = new HashMap<String,String>();
-  static {
-  	// these in are lower case, we will lower case at the test as well
-    extensionToType.put(".bz2", CompressorStreamFactory.BZIP2);
-    extensionToType.put(".bzip", CompressorStreamFactory.BZIP2);
-    extensionToType.put(".gz", CompressorStreamFactory.GZIP);
-    extensionToType.put(".gzip", CompressorStreamFactory.GZIP);
-  }
-  
-  protected static final int BUFFER_SIZE = 1 << 16; // 64K
-
   private long bytesCount;
   private long totalBytesCount;
   private int docsCount;
@@ -78,8 +59,6 @@ public abstract class ContentSource {
   protected boolean verbose;
   protected String encoding;
   
-  private CompressorStreamFactory csFactory = new CompressorStreamFactory();
-
   /** update count of bytes generated by this source */  
   protected final synchronized void addBytes(long numBytes) {
     bytesCount += numBytes;
@@ -114,63 +93,6 @@ public abstract class ContentSource {
     }
   }
 
-  /**
-   * Returns an {@link InputStream} over the requested file. This method
-   * attempts to identify the appropriate {@link InputStream} instance to return
-   * based on the file name (e.g., if it ends with .bz2 or .bzip, return a
-   * 'bzip' {@link InputStream}).
-   */
-  protected InputStream getInputStream(File file) throws IOException {
-    // First, create a FileInputStream, as this will be required by all types.
-    // Wrap with BufferedInputStream for better performance
-    InputStream is = new BufferedInputStream(new FileInputStream(file), BUFFER_SIZE);
-    
-    String fileName = file.getName();
-    int idx = fileName.lastIndexOf('.');
-    String type = null;
-    if (idx != -1) {
-      type = extensionToType.get(fileName.substring(idx).toLowerCase(Locale.ENGLISH));
-    }
-    
-    if (type!=null) { // bzip or gzip
-    	try {
-    		return closableCompressorInputStream(type,is);
-    	} catch (CompressorException e) {
-    		IOException ioe = new IOException(e.getMessage());
-    		ioe.initCause(e);
-    		throw ioe;
-    	}
-    } 
-    
-    return is;
-  }
-  
-  /**
-   * Wrap the compressor input stream so that calling close will also close
-   * the underlying stream - workaround for CommonsCompress bug (COMPRESS-127). 
-   */
-  private InputStream closableCompressorInputStream(String type, final InputStream is) throws CompressorException {
-    final InputStream delegee = csFactory.createCompressorInputStream(type, is);
-    if (!type.equals(CompressorStreamFactory.GZIP)) {
-    	return delegee; //compressor bug affects only gzip
-    }
-    return new InputStream() {
-			@Override	public int read() throws IOException { return delegee.read();	}
-			@Override	public int read(byte[] b) throws IOException { return delegee.read(b);	}
-			@Override	public int available() throws IOException {	return delegee.available();	}
-			@Override	public synchronized void mark(int readlimit) { delegee.mark(readlimit);	}
-			@Override	public boolean markSupported() { return delegee.markSupported(); }
-			@Override	public int read(byte[] b, int off, int len) throws IOException { return delegee.read(b, off, len); }
-			@Override	public synchronized void reset() throws IOException {	delegee.reset(); }
-			@Override	public long skip(long n) throws IOException {	return delegee.skip(n);	}
-			@Override	
-			public void close() throws IOException { 
-				delegee.close();
-				is.close();
-			}
-    };
-	}
-
 	/**
    * Returns true whether it's time to log a message (depending on verbose and
    * the number of documents generated).
