diff --git a/lucene/src/java/org/apache/lucene/util/AttributeImpl.java b/lucene/src/java/org/apache/lucene/util/AttributeImpl.java
index c8bf649..d22491b 100644
--- a/lucene/src/java/org/apache/lucene/util/AttributeImpl.java
+++ b/lucene/src/java/org/apache/lucene/util/AttributeImpl.java
@@ -20,6 +20,8 @@ package org.apache.lucene.util;
 import java.io.Serializable;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
+import java.lang.ref.WeakReference;
+import java.util.LinkedList;
 
 /**
  * Base class for Attributes that can be added to a 
@@ -37,72 +39,80 @@ public abstract class AttributeImpl implements Cloneable, Serializable, Attribut
   public abstract void clear();
   
   /**
-   * The default implementation of this method accesses all declared
-   * fields of this object and prints the values in the following syntax:
+   * This method returns the current attribute values as a string in the following format
+   * by calling the {@link #reflectWith(AttributeReflector)} method:
    * 
+   * <ul>
+   * <li><em>iff {@code prependAttClass=true}:</em> {@code "AttributeClass#key=value,AttributeClass#key=value"}
+   * <li><em>iff {@code prependAttClass=false}:</em> {@code "key=value,key=value"}
+   * </ul>
+   *
+   * @see #reflectWith(AttributeReflector)
+   */
+  public final String reflectAsString(final boolean prependAttClass) {
+    final StringBuilder buffer = new StringBuilder();
+    reflectWith(new AttributeReflector() {
+      public void reflect(Class<? extends Attribute> attClass, String key, Object value) {
+        if (buffer.length() > 0) {
+          buffer.append(',');
+        }
+        if (prependAttClass) {
+          buffer.append(attClass.getName()).append('#');
+        }
+        buffer.append(key).append('=').append((value == null) ? "null" : value);
+      }
+    });
+    return buffer.toString();
+  }
+  
+  /**
+   * This method is for introspection of attributes, it should simply
+   * add the key/values this attribute holds to the given {@link AttributeReflector}.
+   *
+   * <p>The default implementation calls {@link AttributeReflector#reflect} for all
+   * non-static fields from the implementing class, using the field name as key
+   * and the field value as value. The Attribute class is also determined by reflection.
+   * Please note that the default implementation can only handle single-Attribute
+   * implementations.
+   *
+   * <p>Custom implementations look like this (e.g. for a combined attribute implementation):
    * <pre>
-   *   public String toString() {
-   *     return "start=" + startOffset + ",end=" + endOffset;
+   *   public void reflectWith(AttributeReflector reflector) {
+   *     reflector.reflect(CharTermAttribute.class, "term", term());
+   *     reflector.reflect(PositionIncrementAttribute.class, "positionIncrement", getPositionIncrement());
    *   }
    * </pre>
-   * 
-   * This method may be overridden by subclasses.
+   *
+   * <p>If you implement this method, make sure that for each invocation, the same set of {@link Attribute}
+   * interfaces and keys are passed to {@link AttributeReflector#reflect} in the same order, but possibly
+   * different values. So don't automatically exclude e.g. {@code null} properties!
+   *
+   * @see #reflectAsString(boolean)
    */
-  @Override
-  public String toString() {
-    StringBuilder buffer = new StringBuilder();
-    Class<?> clazz = this.getClass();
-    Field[] fields = clazz.getDeclaredFields();
+  public void reflectWith(AttributeReflector reflector) {
+    final Class<? extends AttributeImpl> clazz = this.getClass();
+    final LinkedList<WeakReference<Class<? extends Attribute>>> interfaces = AttributeSource.getAttributeInterfaces(clazz);
+    if (interfaces.size() != 1) {
+      throw new UnsupportedOperationException(clazz.getName() +
+        " implements more than one Attribute interface, the default reflectWith() implementation cannot handle this.");
+    }
+    final Class<? extends Attribute> interf = interfaces.getFirst().get();
+    final Field[] fields = clazz.getDeclaredFields();
     try {
       for (int i = 0; i < fields.length; i++) {
-        Field f = fields[i];
+        final Field f = fields[i];
         if (Modifier.isStatic(f.getModifiers())) continue;
         f.setAccessible(true);
-        Object value = f.get(this);
-        if (buffer.length()>0) {
-          buffer.append(',');
-        }
-        if (value == null) {
-          buffer.append(f.getName() + "=null");
-        } else {
-          buffer.append(f.getName() + "=" + value);
-        }
+        reflector.reflect(interf, f.getName(), f.get(this));
       }
     } catch (IllegalAccessException e) {
       // this should never happen, because we're just accessing fields
       // from 'this'
       throw new RuntimeException(e);
     }
-    
-    return buffer.toString();
   }
   
   /**
-   * Subclasses must implement this method and should compute
-   * a hashCode similar to this:
-   * <pre>
-   *   public int hashCode() {
-   *     int code = startOffset;
-   *     code = code * 31 + endOffset;
-   *     return code;
-   *   }
-   * </pre> 
-   * 
-   * see also {@link #equals(Object)}
-   */
-  @Override
-  public abstract int hashCode();
-  
-  /**
-   * All values used for computation of {@link #hashCode()} 
-   * should be checked here for equality.
-   * 
-   * see also {@link Object#equals(Object)}
-   */
-  @Override
-  public abstract boolean equals(Object other);
-  
-  /**
    * Copies the values from this Attribute into the passed-in
    * target attribute. The target implementation must support all the
    * Attributes this implementation supports.
