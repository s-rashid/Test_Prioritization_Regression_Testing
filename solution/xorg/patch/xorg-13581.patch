diff --git a/hw/xgl/xglglx.c b/hw/xgl/xglglx.c
index 22e8cc0..09900e7 100644
--- a/hw/xgl/xglglx.c
+++ b/hw/xgl/xglglx.c
@@ -32,8 +32,19 @@
 #include "glxserver.h"
 #include "glxdrawable.h"
 #include "glxscreens.h"
+#include "glxutil.h"
+#include "unpack.h"
+#include "g_disptab.h"
 #include "micmap.h"
 
+#define XGL_MAX_TEXTURE_UNITS 8
+
+#define XGL_TEXTURE_1D_BIT	  (1 << 0)
+#define XGL_TEXTURE_2D_BIT	  (1 << 1)
+#define XGL_TEXTURE_3D_BIT	  (1 << 2)
+#define XGL_TEXTURE_RECTANGLE_BIT (1 << 3)
+#define XGL_TEXTURE_CUBE_MAP_BIT  (1 << 4)
+	
 extern void
 GlxSetVisualConfigs (int	       nconfigs,
 		     __GLXvisualConfig *configs,
@@ -91,31 +102,56 @@ typedef struct _xglGLBuffer {
     GLFreeBuffersProc   freeBuffers;
     ScreenPtr		pScreen;
     DrawablePtr		pDrawable;
+    glitz_surface_t	*backSurface;
     PixmapPtr		pPixmap;
-    GCPtr		pGC, swapGC;
+    GCPtr		pGC;
     RegionRec		damage;
     void	        *private;
+    int			xOff, yOff;
+    int			yFlip;
 } xglGLBufferRec, *xglGLBufferPtr;
 
 typedef int xglGLXVisualConfigRec, *xglGLXVisualConfigPtr;
-
 typedef struct _xglDisplayList *xglDisplayListPtr;
 
 #define XGL_LIST_OP_CALLS 0
 #define XGL_LIST_OP_DRAW  1
-#define XGL_LIST_OP_COPY  2
+#define XGL_LIST_OP_GL    2
 #define XGL_LIST_OP_LIST  3
 
-typedef struct _xglCopyOp {
-    void (*copyProc) (struct _xglCopyOp *pOp);
+typedef struct _xglGLOp {
+    void (*glProc) (struct _xglGLOp *pOp);
     union {
+	GLenum     enumeration;
+	GLbitfield bitfield;
+	GLsizei    size;
+	struct {
+	    GLint   x;
+	    GLint   y;
+	    GLsizei width;
+	    GLsizei height;
+	} rect;
+	struct {
+	    GLenum target;
+	    GLuint texture;
+	} bind_texture;
+	struct {
+	    GLenum target;
+	    GLenum pname;
+	    GLint  params[4];
+	} tex_parameter_iv;
+	struct {
+	    GLenum  target;
+	    GLenum  pname;
+	    GLfloat params[4];
+	} tex_parameter_fv;
 	struct {
 	    GLint   x;
 	    GLint   y;
 	    GLsizei width;
 	    GLsizei height;
 	    GLenum  type; 
-	} pixels;
+	} copy_pixels;
 	struct {
 	    GLenum  target;
 	    GLint   level;
@@ -124,7 +160,7 @@ typedef struct _xglCopyOp {
 	    GLint   y;
 	    GLsizei width;
 	    GLint   border; 
-	} tex_image_1d;
+	} copy_tex_image_1d;
 	struct {
 	    GLenum  target;
 	    GLint   level;
@@ -134,7 +170,7 @@ typedef struct _xglCopyOp {
 	    GLsizei width;
 	    GLsizei height;
 	    GLint   border; 
-	} tex_image_2d;
+	} copy_tex_image_2d;
 	struct {
 	    GLenum  target;
 	    GLint   level;
@@ -142,7 +178,7 @@ typedef struct _xglCopyOp {
 	    GLint   x;
 	    GLint   y;
 	    GLsizei width; 
-	} tex_sub_image_1d;
+	} copy_tex_sub_image_1d;
 	struct {
 	    GLenum  target;
 	    GLint   level;
@@ -152,28 +188,28 @@ typedef struct _xglCopyOp {
 	    GLint   y;
 	    GLsizei width;
 	    GLsizei height; 
-	} tex_sub_image_2d;
+	} copy_tex_sub_image_2d;
 	struct {
 	    GLenum  target;
 	    GLenum  internalformat;
 	    GLint   x;
 	    GLint   y;
 	    GLsizei width;
-	} color_table;
+	} copy_color_table;
 	struct {
 	    GLenum  target;
 	    GLsizei start;
 	    GLint   x;
 	    GLint   y;
 	    GLsizei width;
-	} color_sub_table;
+	} copy_color_sub_table;
 	struct {
 	    GLenum  target;
 	    GLenum  internalformat;
 	    GLint   x;
 	    GLint   y;
 	    GLsizei width;
-	} convolution_filter_1d;
+	} copy_convolution_filter_1d;
 	struct {
 	    GLenum  target;
 	    GLenum  internalformat;
@@ -181,7 +217,7 @@ typedef struct _xglCopyOp {
 	    GLint   y;
 	    GLsizei width;
 	    GLsizei height;
-	} convolution_filter_2d;
+	} copy_convolution_filter_2d;
 	struct {
 	    GLenum  target;
 	    GLint   level;
@@ -192,16 +228,20 @@ typedef struct _xglCopyOp {
 	    GLint   y;
 	    GLsizei width;
 	    GLsizei height; 
-	} tex_sub_image_3d;
+	} copy_tex_sub_image_3d;
+	struct {
+	    GLfloat x;
+	    GLfloat y;
+	    GLfloat z;
+	} window_pos_3f;
     } u;
-} xglCopyOpRec, *xglCopyOpPtr;
+} xglGLOpRec, *xglGLOpPtr;
 
 typedef struct _xglListOp {
     int type;
     union {
-	GLuint		  name;
-	xglCopyOpPtr	  copy;
-	xglDisplayListPtr list;
+	GLuint	   list;
+	xglGLOpPtr gl;
     } u;
 } xglListOpRec, *xglListOpPtr;
 
@@ -209,13 +249,24 @@ typedef struct _xglDisplayList {
     xglListOpPtr pOp;
     int		 nOp;
     int		 size;
-    int		 refcnt;
 } xglDisplayListRec;
 
 typedef struct _xglTexObj {
+    GLuint    key;
     GLuint name;
+    PixmapPtr pPixmap;
+    int	      refcnt;
 } xglTexObjRec, *xglTexObjPtr;
 
+typedef struct _xglTexUnit {
+    GLbitfield   enabled;
+    xglTexObjPtr p1D;
+    xglTexObjPtr p2D;
+    xglTexObjPtr p3D;
+    xglTexObjPtr pRect;
+    xglTexObjPtr pCubeMap;
+} xglTexUnitRec, *xglTexUnitPtr;
+
 typedef struct _xglGLAttributes {
     GLbitfield mask;
     GLenum     drawBuffer;
@@ -223,6 +274,7 @@ typedef struct _xglGLAttributes {
     xRectangle viewport;
     xRectangle scissor;
     GLboolean  scissorTest;
+    xglTexUnitRec texUnits[XGL_MAX_TEXTURE_UNITS];
 } xglGLAttributesRec, *xglGLAttributesPtr;
 
 typedef struct _xglGLContext {
@@ -232,14 +284,17 @@ typedef struct _xglGLContext {
     struct _xglGLContext     *shared;
     glitz_context_t	     *context;
     __glProcTableEXT	     glRenderTableEXT;
+    PFNGLACTIVETEXTUREARBPROC ActiveTextureARB;
     PFNGLWINDOWPOS3FMESAPROC WindowPos3fMESA;
     Bool		     needInit;
-    Bool		     target;
-    glitz_surface_t	     *draw;
-    int			     tx, ty;
     xglGLBufferPtr	     pDrawBuffer;
+    xglGLBufferPtr	      pReadBuffer;
+    int			      drawXoff, drawYoff;
     char		     *versionString;
-    GLenum		     error;
+    GLenum		      errorValue;
+    GLboolean		      doubleBuffer;
+    GLint		      depthBits;
+    GLint		      stencilBits;
     xglHashTablePtr	     texObjects;
     xglHashTablePtr	     displayLists;
     GLuint		     list;
@@ -249,9 +304,200 @@ typedef struct _xglGLContext {
     xglGLAttributesRec	     attrib;
     xglGLAttributesPtr	     pAttribStack;
     int			     nAttribStack;
+    int			      activeTexUnit;
+    GLint		      maxTexUnits;
+    GLint		      maxListNesting;
 } xglGLContextRec, *xglGLContextPtr;
 
-xglGLContextPtr cctx = NULL;
+static xglGLContextPtr cctx = NULL;
+
+static void
+xglSetCurrentContext (xglGLContextPtr pContext);
+
+#define XGL_GLX_INTERSECT_BOX(pBox1, pBox2) \
+    {					    \
+	if ((pBox1)->x1 < (pBox2)->x1)      \
+	    (pBox1)->x1 = (pBox2)->x1;      \
+	if ((pBox1)->y1 < (pBox2)->y1)      \
+	    (pBox1)->y1 = (pBox2)->y1;      \
+	if ((pBox1)->x2 > (pBox2)->x2)      \
+	    (pBox1)->x2 = (pBox2)->x2;      \
+	if ((pBox1)->y2 > (pBox2)->y2)      \
+	    (pBox1)->y2 = (pBox2)->y2;      \
+    }
+
+#define XGL_GLX_SET_SCISSOR_BOX(pBox)		      \
+    glScissor ((pBox)->x1,			      \
+	       cctx->pDrawBuffer->yFlip - (pBox)->y2, \
+	       (pBox)->x2 - (pBox)->x1,		      \
+	       (pBox)->y2 - (pBox)->y1)
+
+#define XGL_GLX_DRAW_PROLOGUE(pBox, nBox, pScissorBox)			  \
+    (pBox) = REGION_RECTS (cctx->pDrawBuffer->pGC->pCompositeClip);	  \
+    (nBox) = REGION_NUM_RECTS (cctx->pDrawBuffer->pGC->pCompositeClip);   \
+    (pScissorBox)->x1 = cctx->attrib.scissor.x + cctx->pDrawBuffer->xOff; \
+    (pScissorBox)->x2 = (pScissorBox)->x1 + cctx->attrib.scissor.width;	  \
+    (pScissorBox)->y2 = cctx->attrib.scissor.y + cctx->pDrawBuffer->yOff; \
+    (pScissorBox)->y2 = cctx->pDrawBuffer->yFlip - (pScissorBox)->y2;     \
+    (pScissorBox)->y1 = (pScissorBox)->y2 - cctx->attrib.scissor.height;  \
+    xglSetupTextures ()
+
+#define XGL_GLX_DRAW_DAMAGE(pBox, pRegion)				 \
+    if (cctx->attrib.drawBuffer != GL_BACK &&				 \
+	cctx->pDrawBuffer->pDrawable &&					 \
+	cctx->pDrawBuffer->pDrawable->type != DRAWABLE_PIXMAP)		 \
+    {									 \
+	REGION_INIT (cctx->pDrawBuffer->pGC->pScreen, pRegion, pBox, 1); \
+	REGION_UNION (cctx->pDrawBuffer->pGC->pScreen,			 \
+		      &cctx->pDrawBuffer->damage,			 \
+		      &cctx->pDrawBuffer->damage,			 \
+		      pRegion);						 \
+	REGION_UNINIT (cctx->pDrawBuffer->pGC->pScreen, pRegion);	 \
+    }
+
+static void
+xglRecordError (GLenum error)
+{
+    if (cctx->errorValue == GL_NO_ERROR)
+	cctx->errorValue = error;
+}
+
+static xglDisplayListPtr
+xglCreateList (void)
+{
+    xglDisplayListPtr pDisplayList;
+    
+    pDisplayList = xalloc (sizeof (xglDisplayListRec));
+    if (!pDisplayList)
+	return NULL;
+    
+    pDisplayList->pOp    = NULL;
+    pDisplayList->nOp    = 0;
+    pDisplayList->size   = 0;
+
+    return pDisplayList;
+}
+
+static void
+xglDestroyList (xglDisplayListPtr pDisplayList)
+{
+    xglListOpPtr pOp = pDisplayList->pOp;
+    int		 nOp = pDisplayList->nOp;
+
+    while (nOp--)
+    {
+	switch (pOp->type) {
+	case XGL_LIST_OP_CALLS:
+	case XGL_LIST_OP_DRAW:
+	    glDeleteLists (pOp->u.list, 1);
+	    break;    
+	case XGL_LIST_OP_GL:
+	    xfree (pOp->u.gl);
+	    break;
+	case XGL_LIST_OP_LIST:
+	    break;
+	}
+	
+	pOp++;
+    }
+    
+    if (pDisplayList->pOp)
+	xfree (pDisplayList->pOp);
+
+    xfree (pDisplayList);
+}
+
+static Bool
+xglResizeList (xglDisplayListPtr pDisplayList,
+	       int		 nOp)
+{
+    if (pDisplayList->size < nOp)
+    {
+	int size = pDisplayList->nOp ? pDisplayList->nOp : 4;
+
+	while (size < nOp)
+	    size <<= 1;
+	
+	pDisplayList->pOp = xrealloc (pDisplayList->pOp,
+				      sizeof (xglListOpRec) * size);
+	if (!pDisplayList->pOp)
+	    return FALSE;
+	
+	pDisplayList->size = size;
+    }
+
+    return TRUE;
+}
+
+static void
+xglStartList (int    type,
+	      GLenum mode)
+{
+    if (!xglResizeList (cctx->pList, cctx->pList->nOp + 1))
+    {
+	xglRecordError (GL_OUT_OF_MEMORY);
+	return;
+    }
+    
+    cctx->pList->pOp[cctx->pList->nOp].type   = type;
+    cctx->pList->pOp[cctx->pList->nOp].u.list = glGenLists (1);
+
+    glNewList (cctx->pList->pOp[cctx->pList->nOp].u.list, mode);
+
+    cctx->pList->nOp++;
+}
+
+static void
+xglGLOp (xglGLOpPtr pOp)
+{
+    if (cctx->list)
+    {
+	xglGLOpPtr pGLOp;
+
+	pGLOp = xalloc (sizeof (xglGLOpRec));
+	if (!pGLOp)
+	{
+	    xglRecordError (GL_OUT_OF_MEMORY);
+	    return;
+	}
+	
+	if (!xglResizeList (cctx->pList, cctx->pList->nOp + 1))
+	{
+	    xfree (pGLOp);
+	    xglRecordError (GL_OUT_OF_MEMORY);
+	    return;
+	}
+
+	glEndList ();
+
+	*pGLOp = *pOp;
+	
+	cctx->pList->pOp[cctx->pList->nOp].type = XGL_LIST_OP_GL;
+	cctx->pList->pOp[cctx->pList->nOp].u.gl = pGLOp;
+	cctx->pList->nOp++;
+
+	if (cctx->listMode == GL_COMPILE_AND_EXECUTE)
+	    (*pOp->glProc) (pOp);
+
+	xglStartList (XGL_LIST_OP_CALLS, cctx->listMode);
+    }
+    else
+	(*pOp->glProc) (pOp);   
+}
+
+static void
+xglViewportProc (xglGLOpPtr pOp)
+{
+    cctx->attrib.viewport.x	 = pOp->u.rect.x;
+    cctx->attrib.viewport.y	 = pOp->u.rect.y;
+    cctx->attrib.viewport.width  = pOp->u.rect.width;
+    cctx->attrib.viewport.height = pOp->u.rect.height;
+
+    glViewport (pOp->u.rect.x + cctx->pDrawBuffer->xOff,
+		pOp->u.rect.y + cctx->pDrawBuffer->yOff,
+		pOp->u.rect.width,
+		pOp->u.rect.height);
+}
 
 static void
 xglViewport (GLint   x,
@@ -259,12 +505,25 @@ xglViewport (GLint   x,
 	     GLsizei width,
 	     GLsizei height)
 {
-    cctx->attrib.viewport.x	 = x;
-    cctx->attrib.viewport.y	 = y;
-    cctx->attrib.viewport.width  = width;
-    cctx->attrib.viewport.height = height;
+    xglGLOpRec gl;
+    
+    gl.glProc = xglViewportProc;
 
-    glitz_context_set_viewport (cctx->context, x, y, width, height);
+    gl.u.rect.x	     = x;
+    gl.u.rect.y	     = y;
+    gl.u.rect.width  = width;
+    gl.u.rect.height = height;
+
+    xglGLOp (&gl);
+}
+
+static void
+xglScissorProc (xglGLOpPtr pOp)
+{
+    cctx->attrib.scissor.x	= pOp->u.rect.x;
+    cctx->attrib.scissor.y	= pOp->u.rect.y;
+    cctx->attrib.scissor.width  = pOp->u.rect.width;
+    cctx->attrib.scissor.height = pOp->u.rect.height;
 }
 
 static void
@@ -273,67 +532,227 @@ xglScissor (GLint   x,
 	    GLsizei width,
 	    GLsizei height)
 {
-    cctx->attrib.scissor.x	= x;
-    cctx->attrib.scissor.y	= y;
-    cctx->attrib.scissor.width  = width;
-    cctx->attrib.scissor.height = height;
+    xglGLOpRec gl;
 
-    if (cctx->attrib.scissorTest)
-	glitz_context_set_scissor (cctx->context, x, y, width, height);
+    gl.glProc = xglScissorProc;
+
+    gl.u.rect.x	     = x;
+    gl.u.rect.y	     = y;
+    gl.u.rect.width  = width;
+    gl.u.rect.height = height;
+
+    xglGLOp (&gl);
+}
+
+static void
+xglDrawBufferProc (xglGLOpPtr pOp)
+{
+    switch (pOp->u.enumeration) {
+    case GL_FRONT:
+    case GL_FRONT_AND_BACK:
+	break;
+    case GL_BACK:
+	if (!cctx->doubleBuffer)
+	{
+	    xglRecordError (GL_INVALID_OPERATION);
+	    return;
+	}
+	break;
+    default:
+	xglRecordError (GL_INVALID_ENUM);
+	return;
+    }
+    
+    cctx->attrib.drawBuffer = pOp->u.enumeration;
+    
+    glDrawBuffer (pOp->u.enumeration);
 }
 
 static void
 xglDrawBuffer (GLenum mode)
 {
-    if (mode != cctx->attrib.drawBuffer)
-	ErrorF ("NYI xglDrawBuffer: 0x%x\n", mode);
+    xglGLOpRec gl;
+    
+    gl.glProc = xglDrawBufferProc;
+
+    gl.u.enumeration = mode;
+
+    xglGLOp (&gl);
 }
 
 static void
-xglDisable (GLenum cap)
+xglReadBufferProc (xglGLOpPtr pOp)
 {
-    switch (cap) {
-    case GL_SCISSOR_TEST:
-	if (cctx->attrib.scissorTest)
+    switch (pOp->u.enumeration) {
+    case GL_FRONT:
+	break;
+    case GL_BACK:
+	if (!cctx->doubleBuffer)
 	{
-	    cctx->attrib.scissorTest = GL_FALSE;
-	    glitz_context_set_scissor (cctx->context,
-				       0, 0,
-				       cctx->pDrawBuffer->pDrawable->width,
-				       cctx->pDrawBuffer->pDrawable->height);
+	    xglRecordError (GL_INVALID_OPERATION);
+	    return;
 	}
 	break;
     default:
-	glDisable (cap);
+	xglRecordError (GL_INVALID_ENUM);
+	return;
     }
+    
+    cctx->attrib.readBuffer = pOp->u.enumeration;
+	
+    glReadBuffer (pOp->u.enumeration);
 }
 
 static void
-xglEnable (GLenum cap)
+xglReadBuffer (GLenum mode)
 {
-    switch (cap) {
+    xglGLOpRec gl;
+    
+    gl.glProc = xglReadBufferProc;
+
+    gl.u.enumeration = mode;
+
+    xglGLOp (&gl);
+}
+
+static void
+xglDisableProc (xglGLOpPtr pOp)
+{
+    xglTexUnitPtr pTexUnit = &cctx->attrib.texUnits[cctx->activeTexUnit];
+    
+    switch (pOp->u.enumeration) {
+    case GL_SCISSOR_TEST:
+	cctx->attrib.scissorTest = GL_FALSE;
+	return;
+    case GL_TEXTURE_1D:
+	pTexUnit->enabled &= ~XGL_TEXTURE_1D_BIT;
+	break;
+    case GL_TEXTURE_2D:
+	pTexUnit->enabled &= ~XGL_TEXTURE_2D_BIT;
+	break;
+    case GL_TEXTURE_3D:
+	pTexUnit->enabled &= ~XGL_TEXTURE_3D_BIT;
+	break;
+    case GL_TEXTURE_RECTANGLE_NV:
+	pTexUnit->enabled &= ~XGL_TEXTURE_RECTANGLE_BIT;
+	break;
+    case GL_TEXTURE_CUBE_MAP_ARB:
+	pTexUnit->enabled &= ~XGL_TEXTURE_CUBE_MAP_BIT;
+	break;
+    default:
+	break;
+    }
+
+    glDisable (pOp->u.enumeration);
+}
+
+static void
+xglDisable (GLenum cap)
+{
+    xglGLOpRec gl;
+    
+    gl.glProc = xglDisableProc;
+
+    gl.u.enumeration = cap;
+
+    xglGLOp (&gl);
+}
+
+static void
+xglEnableProc (xglGLOpPtr pOp)
+{
+    xglTexUnitPtr pTexUnit = &cctx->attrib.texUnits[cctx->activeTexUnit];
+    
+    switch (pOp->u.enumeration) {
     case GL_SCISSOR_TEST:
 	cctx->attrib.scissorTest = GL_TRUE;
-	glitz_context_set_scissor (cctx->context,
-				   cctx->attrib.scissor.x,
-				   cctx->attrib.scissor.y,
-				   cctx->attrib.scissor.width,
-				   cctx->attrib.scissor.height);
+	return;
+    case GL_DEPTH_TEST:
+	if (!cctx->depthBits)
+	    return;
+    case GL_STENCIL_TEST:
+	if (!cctx->stencilBits)
+	    return;
+    case GL_TEXTURE_1D:
+	pTexUnit->enabled |= XGL_TEXTURE_1D_BIT;
+	break;
+    case GL_TEXTURE_2D:
+	pTexUnit->enabled |= XGL_TEXTURE_2D_BIT;
+	break;
+    case GL_TEXTURE_3D:
+	pTexUnit->enabled |= XGL_TEXTURE_3D_BIT;
+	break;
+    case GL_TEXTURE_RECTANGLE_NV:
+	pTexUnit->enabled |= XGL_TEXTURE_RECTANGLE_BIT;
+	break;
+    case GL_TEXTURE_CUBE_MAP_ARB:
+	pTexUnit->enabled |= XGL_TEXTURE_CUBE_MAP_BIT;
 	break;
     default:
-	glEnable (cap);
+	break;
     }
+
+    glEnable (pOp->u.enumeration);
 }
 
 static void
-xglReadBuffer (GLenum mode)
+xglEnable (GLenum cap)
 {
-    if (mode != cctx->attrib.readBuffer)
-	ErrorF ("NYI xglReadBuffer: 0x%x\n", mode);
+    xglGLOpRec gl;
+    
+    gl.glProc = xglEnableProc;
+
+    gl.u.enumeration = cap;
+
+    xglGLOp (&gl);
 }
 
 static void
-xglPushAttrib (GLbitfield mask)
+xglDeleteTexObj (xglTexObjPtr pTexObj)
+{
+    if (pTexObj->pPixmap)
+    {
+	ScreenPtr pScreen = pTexObj->pPixmap->drawable.pScreen;
+	
+	(*pScreen->DestroyPixmap) (pTexObj->pPixmap);
+    }
+
+    if (pTexObj->name)
+    {
+	glDeleteTextures (1, &pTexObj->name);
+    }
+
+    pTexObj->key     = 0;
+    pTexObj->name    = 0;
+    pTexObj->pPixmap = NULL;
+}
+
+static void
+xglRefTexObj (xglTexObjPtr pTexObj)
+{
+    if (!pTexObj)
+	return;
+    
+    pTexObj->refcnt++;
+}
+
+static void
+xglUnrefTexObj (xglTexObjPtr pTexObj)
+{
+    if (!pTexObj)
+	return;
+    
+    pTexObj->refcnt--;
+    if (pTexObj->refcnt)
+	return;
+
+    xglDeleteTexObj (pTexObj);
+
+    xfree (pTexObj);
+}
+
+static void
+xglPushAttribProc (xglGLOpPtr pOp)
 {
     xglGLAttributesPtr pAttrib;
     GLint	       depth;
@@ -342,7 +761,7 @@ xglPushAttrib (GLbitfield mask)
     
     if (cctx->nAttribStack == depth)
     {
-	cctx->error = GL_STACK_OVERFLOW;
+	xglRecordError (GL_STACK_OVERFLOW);
 	return;
     }
     
@@ -352,44 +771,55 @@ xglPushAttrib (GLbitfield mask)
     
     if (!cctx->pAttribStack)
     {
-	cctx->error = GL_OUT_OF_MEMORY;
+	xglRecordError (GL_OUT_OF_MEMORY);
 	return;
     }
 
     pAttrib = &cctx->pAttribStack[cctx->nAttribStack];
-    pAttrib->mask = mask;
+    pAttrib->mask = pOp->u.bitfield;
 
-    if (mask & GL_COLOR_BUFFER_BIT)
-	pAttrib->drawBuffer = cctx->attrib.drawBuffer;
+    *pAttrib = cctx->attrib;
 
-    if (mask & GL_PIXEL_MODE_BIT)
-	pAttrib->readBuffer = cctx->attrib.readBuffer;
+    if (pOp->u.bitfield & GL_TEXTURE_BIT)
+    {
+	int i;
  
-    if (mask & GL_SCISSOR_BIT)
+	for (i = 0; i < cctx->maxTexUnits; i++)
     {
-	pAttrib->scissorTest = cctx->attrib.scissorTest;
-	pAttrib->scissor = cctx->attrib.scissor;
+	    xglRefTexObj (pAttrib->texUnits[i].p1D);
+	    xglRefTexObj (pAttrib->texUnits[i].p2D);
+	    xglRefTexObj (pAttrib->texUnits[i].p3D);
+	    xglRefTexObj (pAttrib->texUnits[i].pRect);
+	    xglRefTexObj (pAttrib->texUnits[i].pCubeMap);
+	}
     }
-    else if (mask & GL_ENABLE_BIT)
-	pAttrib->scissorTest = cctx->attrib.scissorTest;
-
-    if (mask & GL_VIEWPORT_BIT)
-	pAttrib->viewport = cctx->attrib.viewport;
 
     cctx->nAttribStack++;
     
-    glPushAttrib (mask);
+    glPushAttrib (pOp->u.bitfield);
 }
 
 static void
-xglPopAttrib (void)
+xglPushAttrib (GLbitfield mask)
+{
+    xglGLOpRec gl;
+    
+    gl.glProc = xglPushAttribProc;
+
+    gl.u.bitfield = mask;
+
+    xglGLOp (&gl);
+}
+
+static void
+xglPopAttribProc (xglGLOpPtr pOp)
 {
     xglGLAttributesPtr pAttrib;
     GLbitfield	       mask;
     
     if (!cctx->nAttribStack)
     {
-	cctx->error = GL_STACK_UNDERFLOW;
+	xglRecordError (GL_STACK_UNDERFLOW);
 	return;
     }
 
@@ -430,6 +860,29 @@ xglPopAttrib (void)
 		     pAttrib->viewport.width,
 		     pAttrib->viewport.height);
 
+    if (mask & GL_TEXTURE_BIT)
+    {
+	int i;
+	
+	for (i = 0; i < cctx->maxTexUnits; i++)
+	{
+	    xglUnrefTexObj (cctx->attrib.texUnits[i].p1D);
+	    xglUnrefTexObj (cctx->attrib.texUnits[i].p2D);
+	    xglUnrefTexObj (cctx->attrib.texUnits[i].p3D);
+	    xglUnrefTexObj (cctx->attrib.texUnits[i].pRect);
+	    xglUnrefTexObj (cctx->attrib.texUnits[i].pCubeMap);
+
+	    cctx->attrib.texUnits[i] = pAttrib->texUnits[i];
+	}
+    }
+    else if (mask & GL_ENABLE_BIT)
+    {
+	int i;
+	
+	for (i = 0; i < cctx->maxTexUnits; i++)
+	   cctx->attrib.texUnits[i].enabled = pAttrib->texUnits[i].enabled;
+    }
+    
     cctx->pAttribStack =
 	realloc (cctx->pAttribStack,
 		 sizeof (xglGLAttributesRec) * cctx->nAttribStack);
@@ -437,28 +890,48 @@ xglPopAttrib (void)
     glPopAttrib ();
 }
 
-static GLint
-xglGetTextureBinding (GLenum pname)
+static void
+xglPopAttrib (void)
 {
-    xglTexObjPtr pTexObj;
-    GLuint	 key;
-    GLint	 texture;
+    xglGLOpRec gl;
     
-    glGetIntegerv (pname, &texture);
+    gl.glProc = xglPopAttribProc;
+
+    xglGLOp (&gl);
+}
     
-    key = xglHashFirstEntry (cctx->shared->texObjects);
-    while (key)
+static GLuint
+xglActiveTextureBinding (GLenum target)
     {
-	pTexObj = (xglTexObjPtr) xglHashLookup (cctx->shared->texObjects, key);
-	if (pTexObj && pTexObj->name == texture)
-	    return key;
+    xglTexObjPtr pTexObj;
 	
-	key = xglHashNextEntry (cctx->shared->texObjects, key);
+    switch (target) {
+    case GL_TEXTURE_BINDING_1D:
+	pTexObj = cctx->attrib.texUnits[cctx->activeTexUnit].p1D;
+	break;
+    case GL_TEXTURE_BINDING_2D:
+	pTexObj = cctx->attrib.texUnits[cctx->activeTexUnit].p2D;
+	break;
+    case GL_TEXTURE_BINDING_3D:
+	pTexObj = cctx->attrib.texUnits[cctx->activeTexUnit].p3D;
+	break;
+    case GL_TEXTURE_BINDING_RECTANGLE_NV:
+	pTexObj = cctx->attrib.texUnits[cctx->activeTexUnit].pRect;
+	break;
+    case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
+	pTexObj = cctx->attrib.texUnits[cctx->activeTexUnit].pCubeMap;
+	break;
+    default:
+	return 0;
     }
     
+    if (pTexObj)
+	return pTexObj->key;
+    
     return 0;
 }
 
+#define DOUBLE_TO_BOOLEAN(X) ((X) ? GL_TRUE : GL_FALSE)
 #define INT_TO_BOOLEAN(I)  ((I) ? GL_TRUE : GL_FALSE)
 #define ENUM_TO_BOOLEAN(E) ((E) ? GL_TRUE : GL_FALSE)
 
@@ -467,8 +940,25 @@ xglGetBooleanv (GLenum	  pname,
 		GLboolean *params)
 {
     switch (pname) {
+    case GL_CURRENT_RASTER_POSITION:
+    {
+	GLdouble v[4];
+	
+	glGetDoublev (GL_CURRENT_RASTER_POSITION, v);
+
+	params[0] = DOUBLE_TO_BOOLEAN (v[0] - (GLdouble) cctx->drawXoff);
+	params[1] = DOUBLE_TO_BOOLEAN (v[1] - (GLdouble) cctx->drawYoff);
+	params[2] = DOUBLE_TO_BOOLEAN (v[2]);
+	params[3] = DOUBLE_TO_BOOLEAN (v[3]);
+    } break;
     case GL_DOUBLEBUFFER:
-	params[0] = GL_TRUE;
+	params[0] = cctx->doubleBuffer;
+	break;
+    case GL_DEPTH_BITS:
+	params[0] = INT_TO_BOOLEAN (cctx->depthBits);
+	break;
+    case GL_STENCIL_BITS:
+	params[0] = INT_TO_BOOLEAN (cctx->stencilBits);
 	break;
     case GL_DRAW_BUFFER:
 	params[0] = ENUM_TO_BOOLEAN (cctx->attrib.drawBuffer);
@@ -494,12 +984,14 @@ xglGetBooleanv (GLenum	  pname,
     case GL_TEXTURE_BINDING_1D:
     case GL_TEXTURE_BINDING_2D:
     case GL_TEXTURE_BINDING_3D:
+    case GL_TEXTURE_RECTANGLE_NV:
 	/* should be safe to fall-through here */
     default:
 	glGetBooleanv (pname, params);
     }
 }
 
+#define INT_TO_DOUBLE(I)     ((GLdouble) (I))
 #define ENUM_TO_DOUBLE(E)    ((GLdouble) (E))
 #define BOOLEAN_TO_DOUBLE(B) ((B) ? 1.0F : 0.0F)
 
@@ -508,8 +1000,20 @@ xglGetDoublev (GLenum	pname,
 	       GLdouble *params)
 {
     switch (pname) {
+    case GL_CURRENT_RASTER_POSITION:
+	glGetDoublev (GL_CURRENT_RASTER_POSITION, params);
+
+	params[0] -= (GLdouble) cctx->drawXoff;
+	params[1] -= (GLdouble) cctx->drawYoff;
+	break;
     case GL_DOUBLEBUFFER:
-	params[0] = BOOLEAN_TO_DOUBLE (GL_TRUE);
+	params[0] = BOOLEAN_TO_DOUBLE (cctx->doubleBuffer);
+	break;
+    case GL_DEPTH_BITS:
+	params[0] = INT_TO_DOUBLE (cctx->depthBits);
+	break;
+    case GL_STENCIL_BITS:
+	params[0] = INT_TO_DOUBLE (cctx->stencilBits);
 	break;
     case GL_DRAW_BUFFER:
 	params[0] = ENUM_TO_DOUBLE (cctx->attrib.drawBuffer);
@@ -535,13 +1039,18 @@ xglGetDoublev (GLenum	pname,
     case GL_TEXTURE_BINDING_1D:
     case GL_TEXTURE_BINDING_2D:
     case GL_TEXTURE_BINDING_3D:
-	params[0] = xglGetTextureBinding (pname);
+    case GL_TEXTURE_RECTANGLE_NV:
+	params[0] = xglActiveTextureBinding (pname);
+	break;
+    case GL_MAX_TEXTURE_UNITS_ARB:
+	params[0] = cctx->maxTexUnits;
 	break;
     default:
 	glGetDoublev (pname, params);
     }
 }
 
+#define INT_TO_FLOAT(I)     ((GLfloat) (I))
 #define ENUM_TO_FLOAT(E)    ((GLfloat) (E))
 #define BOOLEAN_TO_FLOAT(B) ((B) ? 1.0F : 0.0F)
 
@@ -550,8 +1059,20 @@ xglGetFloatv (GLenum  pname,
 	      GLfloat *params)
 {
     switch (pname) {
+    case GL_CURRENT_RASTER_POSITION:
+	glGetFloatv (GL_CURRENT_RASTER_POSITION, params);
+
+	params[0] -= (GLfloat) cctx->drawXoff;
+	params[1] -= (GLfloat) cctx->drawYoff;
+	break;
     case GL_DOUBLEBUFFER:
-	params[0] = BOOLEAN_TO_FLOAT (GL_TRUE);
+	params[0] = BOOLEAN_TO_FLOAT (cctx->doubleBuffer);
+	break;
+    case GL_DEPTH_BITS:
+	params[0] = INT_TO_FLOAT (cctx->depthBits);
+	break;
+    case GL_STENCIL_BITS:
+	params[0] = INT_TO_FLOAT (cctx->stencilBits);
 	break;
     case GL_DRAW_BUFFER:
 	params[0] = ENUM_TO_FLOAT (cctx->attrib.drawBuffer);
@@ -577,7 +1098,11 @@ xglGetFloatv (GLenum  pname,
     case GL_TEXTURE_BINDING_1D:
     case GL_TEXTURE_BINDING_2D:
     case GL_TEXTURE_BINDING_3D:
-	params[0] = xglGetTextureBinding (pname);
+    case GL_TEXTURE_RECTANGLE_NV:
+	params[0] = xglActiveTextureBinding (pname);
+	break;
+    case GL_MAX_TEXTURE_UNITS_ARB:
+	params[0] = cctx->maxTexUnits;
 	break;
     default:
 	glGetFloatv (pname, params);
@@ -592,8 +1117,20 @@ xglGetIntegerv (GLenum pname,
 		GLint  *params)
 {
     switch (pname) {
+    case GL_CURRENT_RASTER_POSITION:
+	glGetIntegerv (GL_CURRENT_RASTER_POSITION, params);
+	
+	params[0] -= (GLint) cctx->drawXoff;
+	params[1] -= (GLint) cctx->drawYoff;
+	break;
     case GL_DOUBLEBUFFER:
-	params[0] = BOOLEAN_TO_INT (GL_TRUE);
+	params[0] = BOOLEAN_TO_INT (cctx->doubleBuffer);
+	break;
+    case GL_DEPTH_BITS:
+	params[0] = cctx->depthBits;
+	break;
+    case GL_STENCIL_BITS:
+	params[0] = cctx->stencilBits;
 	break;
     case GL_DRAW_BUFFER:
 	params[0] = ENUM_TO_INT (cctx->attrib.drawBuffer);
@@ -619,7 +1156,11 @@ xglGetIntegerv (GLenum pname,
     case GL_TEXTURE_BINDING_1D:
     case GL_TEXTURE_BINDING_2D:
     case GL_TEXTURE_BINDING_3D:
-	params[0] = xglGetTextureBinding (pname);
+    case GL_TEXTURE_RECTANGLE_NV:
+	params[0] = xglActiveTextureBinding (pname);
+	break;
+    case GL_MAX_TEXTURE_UNITS_ARB:
+	params[0] = cctx->maxTexUnits;
 	break;
     default:
 	glGetIntegerv (pname, params);
@@ -640,8 +1181,13 @@ xglIsEnabled (GLenum cap)
 static GLenum
 xglGetError (void)
 {
-    if (cctx->error != GL_NO_ERROR)
-	return cctx->error;
+    GLenum error = cctx->errorValue;
+	
+    if (error != GL_NO_ERROR)
+    {
+	cctx->errorValue = GL_NO_ERROR;
+	return error;
+    }
 
     return glGetError ();
 }
@@ -683,13 +1229,16 @@ xglGenTextures (GLsizei n,
 	pTexObj = xalloc (sizeof (xglTexObjRec));
 	if (pTexObj)
 	{
+	    pTexObj->key     = name;
 	    pTexObj->name = *textures;
+	    pTexObj->pPixmap = NULL;
+	    pTexObj->refcnt  = 1;
+
 	    xglHashInsert (cctx->shared->texObjects, name, pTexObj);
 	}
 	else
 	{
-	    glDeleteTextures (1, textures);
-	    cctx->error = GL_OUT_OF_MEMORY;
+	    xglRecordError (GL_OUT_OF_MEMORY);
 	}
 	
 	*textures++ = name++;
@@ -697,32 +1246,140 @@ xglGenTextures (GLsizei n,
 }
 
 static void
-xglBindTexture (GLenum target,
-		GLuint texture)
+xglBindTextureProc (xglGLOpPtr pOp)
 {
-    if (texture)
+    xglTexObjPtr *ppTexObj;
+    
+    switch (pOp->u.bind_texture.target) {
+    case GL_TEXTURE_1D:
+	ppTexObj = &cctx->attrib.texUnits[cctx->activeTexUnit].p1D;
+	break;
+    case GL_TEXTURE_2D:
+	ppTexObj = &cctx->attrib.texUnits[cctx->activeTexUnit].p2D;
+	break;
+    case GL_TEXTURE_3D:
+	ppTexObj = &cctx->attrib.texUnits[cctx->activeTexUnit].p3D;
+	break;
+    case GL_TEXTURE_RECTANGLE_NV:
+	ppTexObj = &cctx->attrib.texUnits[cctx->activeTexUnit].pRect;
+	break;
+    case GL_TEXTURE_CUBE_MAP_ARB:
+	ppTexObj = &cctx->attrib.texUnits[cctx->activeTexUnit].pCubeMap;
+	break;
+    default:
+	xglRecordError (GL_INVALID_ENUM);
+	return;
+    }
+    
+    if (pOp->u.bind_texture.texture)
     {
 	xglTexObjPtr pTexObj;
 	
 	pTexObj = (xglTexObjPtr) xglHashLookup (cctx->shared->texObjects,
-						texture);
+						pOp->u.bind_texture.texture);
 	if (!pTexObj)
 	{
 	    pTexObj = xalloc (sizeof (xglTexObjRec));
 	    if (!pTexObj)
 	    {
-		cctx->error = GL_OUT_OF_MEMORY;
+		xglRecordError (GL_OUT_OF_MEMORY);
 		return;
 	    }
 
+	    pTexObj->key     = pOp->u.bind_texture.texture;
+	    pTexObj->pPixmap = NULL;
+	    pTexObj->refcnt  = 1;
+
 	    glGenTextures (1, &pTexObj->name);
-	    xglHashInsert (cctx->shared->texObjects, texture, pTexObj);
+	    
+	    xglHashInsert (cctx->shared->texObjects,
+			   pOp->u.bind_texture.texture,
+			   pTexObj);
 	}
 	
-	glBindTexture (target, pTexObj->name);
+	xglRefTexObj (pTexObj);
+	xglUnrefTexObj (*ppTexObj);
+	*ppTexObj = pTexObj;
+
+	glBindTexture (pOp->u.bind_texture.target, pTexObj->name);
+    }
+    else
+    {
+	xglUnrefTexObj (*ppTexObj);
+	*ppTexObj = NULL;
+	
+	glBindTexture (pOp->u.bind_texture.target, 0);
+    }
+}
+
+static void
+xglBindTexture (GLenum target,
+		GLuint texture)
+{
+    xglGLOpRec gl;
+    
+    gl.glProc = xglBindTextureProc;
+
+    gl.u.bind_texture.target  = target;
+    gl.u.bind_texture.texture = texture;
+    
+    xglGLOp (&gl);
+}
+
+static void
+xglSetupTextures (void)
+{
+    xglGLContextPtr pContext = cctx;
+    xglTexUnitPtr   pTexUnit;
+    xglTexObjPtr    pTexObj[XGL_MAX_TEXTURE_UNITS];
+    int		    i, activeTexUnit;
+    
+    for (i = 0; i < pContext->maxTexUnits; i++)
+    {
+	pTexObj[i] = NULL;
+
+	pTexUnit = &pContext->attrib.texUnits[i];
+	if (pTexUnit->enabled)
+	{
+	    if (pTexUnit->enabled & XGL_TEXTURE_RECTANGLE_BIT)
+		pTexObj[i] = pTexUnit->pRect;
+	    else if (pTexUnit->enabled & XGL_TEXTURE_2D_BIT)
+		pTexObj[i] = pTexUnit->p2D;
+	    
+	    if (pTexObj[i] && pTexObj[i]->pPixmap)
+	    {
+		if (!xglSyncSurface (&pTexObj[i]->pPixmap->drawable))
+		    pTexObj[i] = NULL;
     }
     else
-	glBindTexture (target, 0);
+		pTexObj[i] = NULL;
+	}
+    }
+
+    if (pContext != cctx)
+    {
+	XGL_SCREEN_PRIV (pContext->pDrawBuffer->pGC->pScreen);
+	
+	glitz_drawable_finish (pScreenPriv->drawable);
+	
+	xglSetCurrentContext (pContext);
+    }
+    
+    activeTexUnit = cctx->activeTexUnit;
+    for (i = 0; i < pContext->maxTexUnits; i++)
+    {
+	if (pTexObj[i])
+	{
+	    XGL_PIXMAP_PRIV (pTexObj[i]->pPixmap);
+
+	    activeTexUnit = GL_TEXTURE0_ARB + i;
+	    cctx->ActiveTextureARB (activeTexUnit);
+	    glitz_context_bind_texture (cctx->context, pPixmapPriv->surface);
+	}
+    }
+
+    if (cctx->activeTexUnit != activeTexUnit) 
+	cctx->ActiveTextureARB (cctx->activeTexUnit);  
 }
  
 static GLboolean
@@ -735,7 +1392,7 @@ xglAreTexturesResident (GLsizei	     n,
     
     if (n < 0)
     {
-	cctx->error = GL_INVALID_VALUE;
+	xglRecordError (GL_INVALID_VALUE);
 	return GL_FALSE;
     }
     
@@ -749,7 +1406,7 @@ xglAreTexturesResident (GLsizei	     n,
 	
 	if (textures[i] == 0)
 	{
-	    cctx->error = GL_INVALID_VALUE;
+	    xglRecordError (GL_INVALID_VALUE);
 	    return GL_FALSE;
 	}
 
@@ -757,11 +1414,12 @@ xglAreTexturesResident (GLsizei	     n,
 						textures[i]);
 	if (!pTexObj)
 	{
-	    cctx->error = GL_INVALID_VALUE;
+	    xglRecordError (GL_INVALID_VALUE);
 	    return GL_FALSE;
 	}
 	
-	if (glAreTexturesResident (1, &pTexObj->name, &resident))
+	if (pTexObj->name == 0 ||
+	    glAreTexturesResident (1, &pTexObj->name, &resident))
 	{
 	    if (!allResident)
 		residences[i] = GL_TRUE;
@@ -794,9 +1452,9 @@ xglDeleteTextures (GLsizei	n,
 						*textures);
 	if (pTexObj)
 	{
-	    glDeleteTextures (1, &pTexObj->name);
+	    xglDeleteTexObj (pTexObj);
+	    xglUnrefTexObj (pTexObj);
 	    xglHashRemove (cctx->shared->texObjects, *textures);
-	    xfree (pTexObj);
 	}
 	textures++;
     }
@@ -812,7 +1470,7 @@ xglIsTexture (GLuint texture)
     
     pTexObj = (xglTexObjPtr) xglHashLookup (cctx->shared->texObjects, texture);
     if (pTexObj)
-	return glIsTexture (pTexObj->name);
+	return GL_TRUE;
 
     return GL_FALSE;
 }
@@ -827,7 +1485,7 @@ xglPrioritizeTextures (GLsizei	      n,
     
     if (n < 0)
     {
-	cctx->error = GL_INVALID_VALUE;
+	xglRecordError (GL_INVALID_VALUE);
 	return;
     }
     
@@ -841,100 +1499,219 @@ xglPrioritizeTextures (GLsizei	      n,
 	
 	pTexObj = (xglTexObjPtr) xglHashLookup (cctx->shared->texObjects,
 						textures[i]);
-	if (pTexObj)
+	if (pTexObj && pTexObj->name)
 	    glPrioritizeTextures (1, &pTexObj->name, &priorities[i]);
     }
 }
 
-static xglDisplayListPtr
-xglCreateList (void)
+static void
+xglTexParameterfvProc (xglGLOpPtr pOp)
 {
-    xglDisplayListPtr pDisplayList;
+    xglTexObjPtr pTexObj;
     
-    pDisplayList = xalloc (sizeof (xglDisplayListRec));
-    if (!pDisplayList)
-	return NULL;
+    glTexParameterfv (pOp->u.tex_parameter_fv.target,
+		      pOp->u.tex_parameter_fv.pname,
+		      pOp->u.tex_parameter_fv.params);
     
-    pDisplayList->pOp    = NULL;
-    pDisplayList->nOp    = 0;
-    pDisplayList->size   = 0;
-    pDisplayList->refcnt = 1;
+    switch (pOp->u.tex_parameter_fv.target) {
+    case GL_TEXTURE_2D:
+	pTexObj = cctx->attrib.texUnits[cctx->activeTexUnit].p2D;
+	break;
+    case GL_TEXTURE_RECTANGLE_NV:
+	pTexObj = cctx->attrib.texUnits[cctx->activeTexUnit].pRect;
+	break;
+    default:
+	pTexObj = NULL;
+	break;
+    }
 
-    return pDisplayList;
+    if (pTexObj && pTexObj->pPixmap)
+    {
+	XGL_PIXMAP_PRIV (pTexObj->pPixmap);
+
+	/* texture parameters should eventually go into a
+	   glitz_texture_object_t */
+	glitz_context_bind_texture (cctx->context, pPixmapPriv->surface);
+
+	glTexParameterfv (pOp->u.tex_parameter_fv.target,
+			  pOp->u.tex_parameter_fv.pname,
+			  pOp->u.tex_parameter_fv.params);
+	
+	glBindTexture (pOp->u.tex_parameter_fv.target, pTexObj->name);
+    }
 }
 
 static void
-xglDestroyList (xglDisplayListPtr pDisplayList)
+xglTexParameterfv (GLenum	 target,
+		   GLenum	 pname,
+		   const GLfloat *params)
 {
-    xglListOpPtr pOp = pDisplayList->pOp;
-    int		 nOp = pDisplayList->nOp;
+    xglGLOpRec gl;
 
-    pDisplayList->refcnt--;
-    if (pDisplayList->refcnt)
-	return;
+    gl.glProc = xglTexParameterfvProc;
 
-    while (nOp--)
+    gl.u.tex_parameter_fv.target = target;
+    gl.u.tex_parameter_fv.pname  = pname;
+
+    switch (pname) {
+    case GL_TEXTURE_BORDER_COLOR:
+	gl.u.tex_parameter_fv.params[3] = params[3];
+	gl.u.tex_parameter_fv.params[2] = params[2];
+	gl.u.tex_parameter_fv.params[1] = params[1];
+	/* fall-through */
+    default:
+	gl.u.tex_parameter_fv.params[0] = params[0];
+	break;
+    }
+    
+    xglGLOp (&gl);
+}
+
+static void
+xglTexParameterivProc (xglGLOpPtr pOp)
     {
-	switch (pOp->type) {
-	case XGL_LIST_OP_CALLS:
-	case XGL_LIST_OP_DRAW:
-	    glDeleteLists (pOp->u.name, 1);
+    xglTexObjPtr pTexObj;
+
+    glTexParameteriv (pOp->u.tex_parameter_iv.target,
+		      pOp->u.tex_parameter_iv.pname,
+		      pOp->u.tex_parameter_iv.params);
+
+    switch (pOp->u.tex_parameter_iv.target) {
+    case GL_TEXTURE_2D:
+	pTexObj = cctx->attrib.texUnits[cctx->activeTexUnit].p2D;
 	    break;    
-	case XGL_LIST_OP_COPY:
-	    xfree (pOp->u.copy);
+    case GL_TEXTURE_RECTANGLE_NV:
+	pTexObj = cctx->attrib.texUnits[cctx->activeTexUnit].pRect;
 	    break;
-	case XGL_LIST_OP_LIST:
-	    xglDestroyList (pOp->u.list);
+    default:
+	pTexObj = NULL;
 	    break;
 	}
 	
-	pOp++;
-    }
+    if (pTexObj && pTexObj->pPixmap)
+    {
+	XGL_PIXMAP_PRIV (pTexObj->pPixmap);
     
-    if (pDisplayList->pOp)
-	xfree (pDisplayList->pOp);
+	/* texture parameters should eventually go into a
+	   glitz_texture_object_t */
+	glitz_context_bind_texture (cctx->context, pPixmapPriv->surface);
 
-    xfree (pDisplayList);
+	glTexParameteriv (pOp->u.tex_parameter_iv.target,
+			  pOp->u.tex_parameter_iv.pname,
+			  pOp->u.tex_parameter_iv.params);
+	
+	glBindTexture (pOp->u.tex_parameter_iv.target, pTexObj->name);
+    }
 }
 
-static Bool
-xglResizeList (xglDisplayListPtr pDisplayList,
-	       int		 nOp)
-{
-    if (pDisplayList->size < nOp)
+static void
+xglTexParameteriv (GLenum      target,
+		   GLenum      pname,
+		   const GLint *params)
     {
-	int size = pDisplayList->nOp ? pDisplayList->nOp : 4;
+    xglGLOpRec gl;
 
-	while (size < nOp)
-	    size <<= 1;
+    gl.glProc = xglTexParameterivProc;
 	
-	pDisplayList->pOp = xrealloc (pDisplayList->pOp,
-				      sizeof (xglListOpRec) * size);
-	if (!pDisplayList->pOp)
-	    return FALSE;
+    gl.u.tex_parameter_iv.target = target;
+    gl.u.tex_parameter_iv.pname  = pname;
 	
-	pDisplayList->size = size;
+    switch (pname) {
+    case GL_TEXTURE_BORDER_COLOR:
+	gl.u.tex_parameter_iv.params[3] = params[3];
+	gl.u.tex_parameter_iv.params[2] = params[2];
+	gl.u.tex_parameter_iv.params[1] = params[1];
+	/* fall-through */
+    default:
+	gl.u.tex_parameter_iv.params[0] = params[0];
+	break;
     }
 
-    return TRUE;
+    xglGLOp (&gl);
 }
 
 static void
-xglStartList (int    type,
-	      GLenum mode)
+xglTexParameterf (GLenum  target,
+		  GLenum  pname,
+		  GLfloat param)
 {
-    if (!xglResizeList (cctx->pList, cctx->pList->nOp + 1))
+    xglTexParameterfv (target, pname, (const GLfloat *) &param);
+}
+
+static void
+xglTexParameteri (GLenum target,
+		  GLenum pname,
+		  GLint  param)
     {
-	cctx->error = GL_OUT_OF_MEMORY;
-	return;
+    xglTexParameteriv (target, pname, (const GLint *) &param);
     }
     
-    cctx->pList->pOp[cctx->pList->nOp].type   = type;
-    cctx->pList->pOp[cctx->pList->nOp].u.name = glGenLists (1);
+static void
+xglGetTexLevelParameterfv (GLenum  target,
+			   GLint   level,
+			   GLenum  pname,
+			   GLfloat *params)
+{
+    xglTexObjPtr pTexObj;
+
+    switch (target) {
+    case GL_TEXTURE_2D:
+	pTexObj = cctx->attrib.texUnits[cctx->activeTexUnit].p2D;
+	break;
+    case GL_TEXTURE_RECTANGLE_NV:
+	pTexObj = cctx->attrib.texUnits[cctx->activeTexUnit].pRect;
+	break;
+    default:
+	pTexObj = NULL;
+	break;
+    }
+
+    if (pTexObj && pTexObj->pPixmap)
+    {
+	XGL_PIXMAP_PRIV (pTexObj->pPixmap);
 
-    glNewList (cctx->pList->pOp[cctx->pList->nOp].u.name, mode);
+	glitz_context_bind_texture (cctx->context, pPixmapPriv->surface);
 
-    cctx->pList->nOp++;
+	glGetTexLevelParameterfv (target, level, pname, params);
+	
+	glBindTexture (target, pTexObj->name);
+    }
+    else
+	glGetTexLevelParameterfv (target, level, pname, params);
+}
+
+static void
+xglGetTexLevelParameteriv (GLenum target,
+			   GLint  level,
+			   GLenum pname,
+			   GLint  *params)
+{
+    xglTexObjPtr pTexObj;
+
+    switch (target) {
+    case GL_TEXTURE_2D:
+	pTexObj = cctx->attrib.texUnits[cctx->activeTexUnit].p2D;
+	break;
+    case GL_TEXTURE_RECTANGLE_NV:
+	pTexObj = cctx->attrib.texUnits[cctx->activeTexUnit].pRect;
+	break;
+    default:
+	pTexObj = NULL;
+	break;
+    }
+
+    if (pTexObj && pTexObj->pPixmap)
+    {
+	XGL_PIXMAP_PRIV (pTexObj->pPixmap);
+
+	glitz_context_bind_texture (cctx->context, pPixmapPriv->surface);
+
+	glGetTexLevelParameteriv (target, level, pname, params);
+	
+	glBindTexture (target, pTexObj->name);
+    }
+    else
+	glGetTexLevelParameteriv (target, level, pname, params);
 }
 
 static GLuint
@@ -955,7 +1732,7 @@ xglGenLists (GLsizei range)
 	}
 	else
 	{
-	    cctx->error = GL_OUT_OF_MEMORY;
+	    xglRecordError (GL_OUT_OF_MEMORY);
 	}
     }
 
@@ -968,20 +1745,20 @@ xglNewList (GLuint list,
 {
     if (!list)
     {
-	cctx->error = GL_INVALID_VALUE;
+	xglRecordError (GL_INVALID_VALUE);
 	return;
     }
 
     if (cctx->list)
     {
-	cctx->error = GL_INVALID_OPERATION;
+	xglRecordError (GL_INVALID_OPERATION);
 	return;
     }
 
     cctx->pList = xglCreateList ();
     if (!cctx->pList)
     {
-	cctx->error = GL_OUT_OF_MEMORY;
+	xglRecordError (GL_OUT_OF_MEMORY);
 	return;
     }
 
@@ -998,7 +1775,7 @@ xglEndList (void)
 
     if (!cctx->list)
     {
-	cctx->error = GL_INVALID_OPERATION;
+	xglRecordError (GL_INVALID_OPERATION);
 	return;
     }
 
@@ -1017,62 +1794,26 @@ xglEndList (void)
     cctx->list = 0;
 }
 
-#define XGL_GLX_DRAW_DECLARATIONS(pBox, nBox)				   \
-    GCPtr	   pGC = cctx->pDrawBuffer->pGC;			   \
-    BoxPtr	   (pBox) = REGION_RECTS (pGC->pCompositeClip);		   \
-    int		   (nBox) = REGION_NUM_RECTS (pGC->pCompositeClip);	   \
-    DrawablePtr	   pDrawable = cctx->pDrawBuffer->pDrawable;		   \
-    int		   scissorX1 = cctx->attrib.scissor.x;			   \
-    int		   scissorX2 = scissorX1 + cctx->attrib.scissor.width;	   \
-    int		   scissorY2 = pDrawable->height - cctx->attrib.scissor.y; \
-    int		   scissorY1 = scissorY2 - cctx->attrib.scissor.height
-
-#define XGL_GLX_DRAW_SCISSOR_CLIP(box) \
-    if ((box)->x1 < scissorX1)	       \
-	(box)->x1 = scissorX1;	       \
-    if ((box)->y1 < scissorY1)	       \
-	(box)->y1 = scissorY1;	       \
-    if ((box)->x2 > scissorX2)	       \
-	(box)->x2 = scissorX2;	       \
-    if ((box)->y2 > scissorY2)	       \
-	(box)->y2 = scissorY2
-
-#define XGL_GLX_DRAW_DAMAGE(pBox, pRegion)	      \
-    if (cctx->attrib.drawBuffer == GL_FRONT)	      \
-    {						      \
-	REGION_INIT (pGC->pScreen, pRegion, pBox, 1); \
-	REGION_UNION (pGC->pScreen,		      \
-		      &cctx->pDrawBuffer->damage,     \
-		      &cctx->pDrawBuffer->damage,     \
-		      pRegion);			      \
-	REGION_UNINIT (pGC->pScreen, pRegion);	      \
-    } 
-
-#define XGL_GLX_DRAW_SET_SCISSOR_BOX(box)		      \
-    glitz_context_set_scissor (cctx->context,		      \
-			       (box)->x1,		      \
-			       pDrawable->height - (box)->y2, \
-			       (box)->x2 - (box)->x1,	      \
-			       (box)->y2 - (box)->y1)
-		    
-		    
 static void
 xglDrawList (GLuint list)
 {
     RegionRec region;
-    BoxRec    box;
+    BoxRec    scissor, box;
+    BoxPtr    pBox;
+    int	      nBox;
 	
-    XGL_GLX_DRAW_DECLARATIONS (pBox, nBox);
+    XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
 
     while (nBox--)
     {
 	box = *pBox++;
 	
-	XGL_GLX_DRAW_SCISSOR_CLIP (&box);
+	if (cctx->attrib.scissorTest)
+	    XGL_GLX_INTERSECT_BOX (&box, &scissor);
 	
 	if (box.x1 < box.x2 && box.y1 < box.y2)
 	{
-	    XGL_GLX_DRAW_SET_SCISSOR_BOX (&box);
+	    XGL_GLX_SET_SCISSOR_BOX (&box);
 
 	    glCallList (list);
 
@@ -1082,24 +1823,38 @@ xglDrawList (GLuint list)
 }
 
 static void
-xglCallDisplayList (xglDisplayListPtr pDisplayList)
+xglCallDisplayList (GLuint list,
+		    int	   nesting)
+{
+    if (nesting > cctx->maxListNesting)
+	return;
+
+    if (!list)
 {
+	xglRecordError (GL_INVALID_VALUE);
+	return;
+    }
+    
     if (cctx->list)
     {
 	if (!xglResizeList (cctx->pList, cctx->pList->nOp + 1))
 	{
-	    cctx->error = GL_OUT_OF_MEMORY;
+	    xglRecordError (GL_OUT_OF_MEMORY);
 	    return;
 	}
 
-	pDisplayList->refcnt++;
-
 	cctx->pList->pOp[cctx->pList->nOp].type   = XGL_LIST_OP_LIST;
-	cctx->pList->pOp[cctx->pList->nOp].u.list = pDisplayList;
+	cctx->pList->pOp[cctx->pList->nOp].u.list = list;
 	cctx->pList->nOp++;
     }
     else
     {
+	xglDisplayListPtr pDisplayList;
+
+	pDisplayList = (xglDisplayListPtr)
+	    xglHashLookup (cctx->shared->displayLists, list);
+	if (pDisplayList)
+	{
 	xglListOpPtr pOp = pDisplayList->pOp;
 	int	     nOp = pDisplayList->nOp;
 
@@ -1107,16 +1862,16 @@ xglCallDisplayList (xglDisplayListPtr pDisplayList)
 	{
 	    switch (pOp->type) {
 	    case XGL_LIST_OP_CALLS:
-		glCallList (pOp->u.name);
+		    glCallList (pOp->u.list);
 		break;
 	    case XGL_LIST_OP_DRAW:
-		xglDrawList (pOp->u.name);
+		    xglDrawList (pOp->u.list);
 		break;
-	    case XGL_LIST_OP_COPY:
-		(*pOp->u.copy->copyProc) (pOp->u.copy);
+		case XGL_LIST_OP_GL:
+		    (*pOp->u.gl->glProc) (pOp->u.gl);
 		break;
 	    case XGL_LIST_OP_LIST:
-		xglCallDisplayList (pOp->u.list);
+		    xglCallDisplayList (pOp->u.list, nesting + 1);
 		break;
 	    }
 
@@ -1124,22 +1879,12 @@ xglCallDisplayList (xglDisplayListPtr pDisplayList)
 	}
     }
 }
+}
 
 static void
 xglCallList (GLuint list)
 {
-    xglDisplayListPtr pDisplayList;
-    
-    if (!list)
-    {
-	cctx->error = GL_INVALID_VALUE;
-	return;
-    }
-       
-    pDisplayList = (xglDisplayListPtr)
-	xglHashLookup (cctx->shared->displayLists, list);
-    if (pDisplayList)
-	xglCallDisplayList (pDisplayList);
+    xglCallDisplayList (list, 1);
 }
 
 static void
@@ -1147,7 +1892,6 @@ xglCallLists (GLsizei	   n,
 	      GLenum	   type,
 	      const GLvoid *lists)
 {
-    xglDisplayListPtr pDisplayList;
     GLuint	      list;
     GLint	      base, i;
 
@@ -1198,14 +1942,11 @@ xglCallLists (GLsizei	   n,
 		+ (GLuint) * (ubptr + 3);
 	} break;
 	default:
-	    cctx->error = GL_INVALID_ENUM;
+	    xglRecordError (GL_INVALID_ENUM);
 	    return;
 	}
 	
-	pDisplayList = (xglDisplayListPtr)
-	    xglHashLookup (cctx->shared->displayLists, base + list);
-	if (pDisplayList)
-	    xglCallDisplayList (pDisplayList);
+	xglCallDisplayList (base + list, 1);
     }
 }
 
@@ -1218,7 +1959,7 @@ xglDeleteLists (GLuint  list,
     
     if (range < 0)
     {
-	cctx->error = GL_INVALID_VALUE;
+	xglRecordError (GL_INVALID_VALUE);
 	return;
     }
     
@@ -1253,30 +1994,36 @@ xglIsList (GLuint list)
 static void
 xglFlush (void)
 {
-    xglGLBufferPtr pBuffer = cctx->pDrawBuffer;
-    
     glFlush ();
 
+    if (cctx->pDrawBuffer->pDrawable)
+    {
+	xglGLBufferPtr pBuffer = cctx->pDrawBuffer;
+    
     if (REGION_NOTEMPTY (pBuffer->pDrawable->pScreen, &pBuffer->damage))
     {
 	DamageDamageRegion (pBuffer->pDrawable, &pBuffer->damage);
 	REGION_EMPTY (pBuffer->pDrawable->pScreen, &pBuffer->damage);
     }
 }
+}
 
 static void
 xglFinish (void)
 {
-    xglGLBufferPtr pBuffer = cctx->pDrawBuffer;
-    
     glFinish ();
 
+    if (cctx->pDrawBuffer->pDrawable)
+    {
+	xglGLBufferPtr pBuffer = cctx->pDrawBuffer;
+    
     if (REGION_NOTEMPTY (pBuffer->pDrawable->pScreen, &pBuffer->damage))
     {
 	DamageDamageRegion (pBuffer->pDrawable, &pBuffer->damage);
 	REGION_EMPTY (pBuffer->pDrawable->pScreen, &pBuffer->damage);
     }
 }
+}
 
 static void
 xglClear (GLbitfield mask)
@@ -1298,19 +2045,22 @@ xglClear (GLbitfield mask)
     if (mode == GL_COMPILE_AND_EXECUTE)
     {
 	RegionRec region;
-	BoxRec	  box;
+	BoxRec    scissor, box;
+	BoxPtr    pBox;
+	int	  nBox;
 
-	XGL_GLX_DRAW_DECLARATIONS (pBox, nBox);
+	XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
     
 	while (nBox--)
 	{
 	    box = *pBox++;
 	    
-	    XGL_GLX_DRAW_SCISSOR_CLIP (&box);
+	    if (cctx->attrib.scissorTest)
+		XGL_GLX_INTERSECT_BOX (&box, &scissor);
 	    
 	    if (box.x1 < box.x2 && box.y1 < box.y2)
 	    {
-		XGL_GLX_DRAW_SET_SCISSOR_BOX (&box);
+		XGL_GLX_SET_SCISSOR_BOX (&box);
 
 		glClear (mask);
 		
@@ -1347,19 +2097,22 @@ xglAccum (GLenum  op,
 	if (listMode == GL_COMPILE_AND_EXECUTE)
 	{
 	    RegionRec region;
-	    BoxRec    box;
+	    BoxRec    scissor, box;
+	    BoxPtr    pBox;
+	    int	      nBox;
 
-	    XGL_GLX_DRAW_DECLARATIONS (pBox, nBox);
+	    XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
 	
 	    while (nBox--)
 	    {
 		box = *pBox++;
 		
-		XGL_GLX_DRAW_SCISSOR_CLIP (&box);
+		if (cctx->attrib.scissorTest)
+		    XGL_GLX_INTERSECT_BOX (&box, &scissor);
 		
 		if (box.x1 < box.x2 && box.y1 < box.y2)
 		{
-		    XGL_GLX_DRAW_SET_SCISSOR_BOX (&box);
+		    XGL_GLX_SET_SCISSOR_BOX (&box);
 
 		    glAccum (GL_RETURN, value);
 		    
@@ -1397,19 +2150,22 @@ xglDrawArrays (GLenum  mode,
     if (listMode == GL_COMPILE_AND_EXECUTE)
     {
 	RegionRec region;
-	BoxRec    box;
+	BoxRec    scissor, box;
+	BoxPtr    pBox;
+	int	  nBox;
 
-	XGL_GLX_DRAW_DECLARATIONS (pBox, nBox);
+	XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
 
 	while (nBox--)
 	{
 	    box = *pBox++;
 	    
-	    XGL_GLX_DRAW_SCISSOR_CLIP (&box);
+	    if (cctx->attrib.scissorTest)
+		XGL_GLX_INTERSECT_BOX (&box, &scissor);
 	    
 	    if (box.x1 < box.x2 && box.y1 < box.y2)
 	    {
-		XGL_GLX_DRAW_SET_SCISSOR_BOX (&box);
+		XGL_GLX_SET_SCISSOR_BOX (&box);
 
 		glDrawArrays (mode, first, count);
 	
@@ -1445,19 +2201,22 @@ xglDrawElements (GLenum	      mode,
     if (listMode == GL_COMPILE_AND_EXECUTE)
     {
 	RegionRec region;
-	BoxRec    box;
+	BoxRec    scissor, box;
+	BoxPtr    pBox;
+	int	  nBox;
 
-	XGL_GLX_DRAW_DECLARATIONS (pBox, nBox);
+	XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
 
 	while (nBox--)
 	{
 	    box = *pBox++;
 	    
-	    XGL_GLX_DRAW_SCISSOR_CLIP (&box);
+	    if (cctx->attrib.scissorTest)
+		XGL_GLX_INTERSECT_BOX (&box, &scissor);
 	    
 	    if (box.x1 < box.x2 && box.y1 < box.y2)
 	    {
-		XGL_GLX_DRAW_SET_SCISSOR_BOX (&box);
+		XGL_GLX_SET_SCISSOR_BOX (&box);
 
 		glDrawElements (mode, count, type, indices);
 	
@@ -1494,19 +2253,22 @@ xglDrawPixels (GLsizei	    width,
     if (listMode == GL_COMPILE_AND_EXECUTE)
     {
 	RegionRec region;
-	BoxRec    box;
+	BoxRec    scissor, box;
+	BoxPtr    pBox;
+	int	  nBox;
 	    
-	XGL_GLX_DRAW_DECLARATIONS (pBox, nBox);
+	XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
 
 	while (nBox--)
 	{
 	    box = *pBox++;
 	    
-	    XGL_GLX_DRAW_SCISSOR_CLIP (&box);
+	    if (cctx->attrib.scissorTest)
+		XGL_GLX_INTERSECT_BOX (&box, &scissor);
 	    
 	    if (box.x1 < box.x2 && box.y1 < box.y2)
 	    {
-		XGL_GLX_DRAW_SET_SCISSOR_BOX (&box);
+		XGL_GLX_SET_SCISSOR_BOX (&box);
 
 		glDrawPixels (width, height, format, type, pixels);
 
@@ -1535,7 +2297,7 @@ xglBitmap (GLsizei	 width,
     {
 	glEndList ();
 	xglStartList (XGL_LIST_OP_DRAW, GL_COMPILE);
-	glBitmap (width, height, xorig, yorig, xmove, ymove, bitmap);
+	glBitmap (width, height, xorig, yorig, 0, 0, bitmap);
 	glEndList ();
 	    
 	listMode = cctx->listMode;
@@ -1543,24 +2305,27 @@ xglBitmap (GLsizei	 width,
     else
 	listMode = GL_COMPILE_AND_EXECUTE;
 	
-    if (listMode == GL_COMPILE_AND_EXECUTE)
+    if (listMode == GL_COMPILE_AND_EXECUTE && width && height)
     {
 	RegionRec region;
-	BoxRec    box;
+	BoxRec    scissor, box;
+	BoxPtr    pBox;
+	int	  nBox;
 
-	XGL_GLX_DRAW_DECLARATIONS (pBox, nBox);
+	XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
 
 	while (nBox--)
 	{
 	    box = *pBox++;
 	    
-	    XGL_GLX_DRAW_SCISSOR_CLIP (&box);
+	    if (cctx->attrib.scissorTest)
+		XGL_GLX_INTERSECT_BOX (&box, &scissor);
 	    
 	    if (box.x1 < box.x2 && box.y1 < box.y2)
 	    {
-		XGL_GLX_DRAW_SET_SCISSOR_BOX (&box);
+		XGL_GLX_SET_SCISSOR_BOX (&box);
 
-		glBitmap (width, height, xorig, yorig, xmove, ymove, bitmap);
+		glBitmap (width, height, xorig, yorig, 0, 0, bitmap);
 		
 		XGL_GLX_DRAW_DAMAGE (&box, &region);
 	    }
@@ -1569,6 +2334,8 @@ xglBitmap (GLsizei	 width,
     
     if (cctx->list)
 	xglStartList (XGL_LIST_OP_CALLS, cctx->listMode);
+
+    glBitmap (0, 0, 0, 0, xmove, ymove, NULL);
 }
 
 static void
@@ -1592,19 +2359,22 @@ xglRectdv (const GLdouble *v1,
     if (listMode == GL_COMPILE_AND_EXECUTE)
     {
 	RegionRec region;
-	BoxRec    box;
+	BoxRec    scissor, box;
+	BoxPtr    pBox;
+	int	  nBox;
 
-	XGL_GLX_DRAW_DECLARATIONS (pBox, nBox);
+	XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
 
 	while (nBox--)
 	{
 	    box = *pBox++;
 	    
-	    XGL_GLX_DRAW_SCISSOR_CLIP (&box);
+	    if (cctx->attrib.scissorTest)
+		XGL_GLX_INTERSECT_BOX (&box, &scissor);
 	    
 	    if (box.x1 < box.x2 && box.y1 < box.y2)
 	    {
-		XGL_GLX_DRAW_SET_SCISSOR_BOX (&box);
+		XGL_GLX_SET_SCISSOR_BOX (&box);
 
 		glRectdv (v1, v2);
 		
@@ -1672,14 +2442,20 @@ xglBegin (GLenum mode)
     }
     else
     {
-	XGL_GLX_DRAW_DECLARATIONS (pBox, nBox);
+	BoxRec    scissor;
+	BoxPtr    pBox;
+	int	  nBox;
+    
+	XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
 	    
 	if (nBox == 1)
 	{
 	    BoxRec box = *pBox;
 
-	    XGL_GLX_DRAW_SCISSOR_CLIP (&box);
-	    XGL_GLX_DRAW_SET_SCISSOR_BOX (&box);
+	    if (cctx->attrib.scissorTest)
+		XGL_GLX_INTERSECT_BOX (&box, &scissor);
+	    
+	    XGL_GLX_SET_SCISSOR_BOX (&box);
 	}
 	else
 	{
@@ -1701,14 +2477,16 @@ xglEnd (void)
     if (!cctx->list || cctx->listMode == GL_COMPILE_AND_EXECUTE)
     {
 	RegionRec region;
-	BoxRec	  box;
+	BoxRec    scissor, box;
+	BoxPtr    pBox;
+	int	  nBox;
 	GLuint	  list;
 
-	XGL_GLX_DRAW_DECLARATIONS (pBox, nBox);
+	XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
 	
 	if (cctx->list)
 	{
-	    list = cctx->pList->pOp[cctx->pList->nOp - 1].u.name;
+	    list = cctx->pList->pOp[cctx->pList->nOp - 1].u.list;
 	}
 	else
 	{
@@ -1716,7 +2494,9 @@ xglEnd (void)
 	    {
 		box = *pBox++;
 	    
-		XGL_GLX_DRAW_SCISSOR_CLIP (&box);
+		if (cctx->attrib.scissorTest)
+		    XGL_GLX_INTERSECT_BOX (&box, &scissor);
+		
 		XGL_GLX_DRAW_DAMAGE (&box, &region);
 		return;
 	    }
@@ -1730,11 +2510,12 @@ xglEnd (void)
 	{
 	    box = *pBox++;
 	    
-	    XGL_GLX_DRAW_SCISSOR_CLIP (&box);
+	    if (cctx->attrib.scissorTest)
+		XGL_GLX_INTERSECT_BOX (&box, &scissor);
 	    
 	    if (box.x1 < box.x2 && box.y1 < box.y2)
 	    {
-		XGL_GLX_DRAW_SET_SCISSOR_BOX (&box);
+		XGL_GLX_SET_SCISSOR_BOX (&box);
 
 		glCallList (list);
 		
@@ -1748,68 +2529,33 @@ xglEnd (void)
 }
 
 static void
-xglCopyOp (xglCopyOpPtr pOp)
-{
-    if (cctx->list)
-    {
-	xglCopyOpPtr pCopyOp;
-
-	pCopyOp = xalloc (sizeof (xglCopyOpRec));
-	if (!pCopyOp)
-	{
-	    cctx->error = GL_OUT_OF_MEMORY;
-	    return;
-	}
-	
-	if (!xglResizeList (cctx->pList, cctx->pList->nOp + 1))
-	{
-	    xfree (pCopyOp);
-	    cctx->error = GL_OUT_OF_MEMORY;
-	    return;
-	}
-
-	glEndList ();
-
-	*pCopyOp = *pOp;
-	
-	cctx->pList->pOp[cctx->pList->nOp].type   = XGL_LIST_OP_COPY;
-	cctx->pList->pOp[cctx->pList->nOp].u.copy = pCopyOp;
-	cctx->pList->nOp++;
-
-	if (cctx->listMode == GL_COMPILE_AND_EXECUTE)
-	    (*pOp->copyProc) (pOp);
-
-	xglStartList (XGL_LIST_OP_CALLS, cctx->listMode);
-    }
-    else
-	(*pOp->copyProc) (pOp);   
-}
-
-static void
-xglDoCopyPixels (xglCopyOpPtr pOp)
+xglCopyPixelsProc (xglGLOpPtr pOp)
 {
     RegionRec region;
-    BoxRec    box;
+    BoxRec    scissor, box;
+    BoxPtr    pBox;
+    int	      nBox;
 	    
-    XGL_GLX_DRAW_DECLARATIONS (pBox, nBox);
+    XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
 
     while (nBox--)
     {
 	box = *pBox++;
 	
-	XGL_GLX_DRAW_SCISSOR_CLIP (&box);
+	if (cctx->attrib.scissorTest)
+	    XGL_GLX_INTERSECT_BOX (&box, &scissor);
 	
 	if (box.x1 < box.x2 && box.y1 < box.y2)
 	{
-	    XGL_GLX_DRAW_SET_SCISSOR_BOX (&box);
+	    XGL_GLX_SET_SCISSOR_BOX (&box);
 
-	    glCopyPixels (cctx->tx + pOp->u.pixels.x,
-			  cctx->ty + pOp->u.pixels.y,
-			  pOp->u.pixels.width,
-			  pOp->u.pixels.height,
-			  pOp->u.pixels.type);
+	    glCopyPixels (pOp->u.copy_pixels.x + cctx->pReadBuffer->xOff,
+			  pOp->u.copy_pixels.y + cctx->pReadBuffer->yOff,
+			  pOp->u.copy_pixels.width,
+			  pOp->u.copy_pixels.height,
+			  pOp->u.copy_pixels.type);
 
-	    if (pOp->u.pixels.type == GL_COLOR)
+	    if (pOp->u.copy_pixels.type == GL_COLOR)
 		XGL_GLX_DRAW_DAMAGE (&box, &region);
 	}
     }
@@ -1822,16 +2568,17 @@ xglCopyPixels (GLint   x,
 	       GLsizei height,
 	       GLenum  type)
 {
-    xglCopyOpRec copy;
+    xglGLOpRec gl;
     
-    copy.copyProc	 = xglDoCopyPixels;
-    copy.u.pixels.x	 = x;
-    copy.u.pixels.y	 = y;
-    copy.u.pixels.width  = width;
-    copy.u.pixels.height = height;
-    copy.u.pixels.type	 = type;
+    gl.glProc = xglCopyPixelsProc;
 
-    xglCopyOp (&copy);   
+    gl.u.copy_pixels.x	    = x;
+    gl.u.copy_pixels.y	    = y;
+    gl.u.copy_pixels.width  = width;
+    gl.u.copy_pixels.height = height;
+    gl.u.copy_pixels.type   = type;
+
+    xglGLOp (&gl);   
 }
 
 static void
@@ -1843,20 +2590,21 @@ xglReadPixels (GLint   x,
 	       GLenum  type,
 	       GLvoid  *pixels)
 {
-    glReadPixels (cctx->tx + x, cctx->ty + y,
+    glReadPixels (x + cctx->pReadBuffer->xOff,
+		  y + cctx->pReadBuffer->yOff,
 		  width, height, format, type, pixels);
 }
 
 static void
-xglDoCopyTexImage1D (xglCopyOpPtr pOp)
+xglCopyTexImage1DProc (xglGLOpPtr pOp)
 {
-    glCopyTexImage1D (pOp->u.tex_image_1d.target,
-		      pOp->u.tex_image_1d.level,
-		      pOp->u.tex_image_1d.internalformat,
-		      cctx->tx + pOp->u.tex_image_1d.x,
-		      cctx->ty + pOp->u.tex_image_1d.y,
-		      pOp->u.tex_image_1d.width,
-		      pOp->u.tex_image_1d.border);
+    glCopyTexImage1D (pOp->u.copy_tex_image_1d.target,
+		      pOp->u.copy_tex_image_1d.level,
+		      pOp->u.copy_tex_image_1d.internalformat,
+		      pOp->u.copy_tex_image_1d.x + cctx->pReadBuffer->xOff,
+		      pOp->u.copy_tex_image_1d.y + cctx->pReadBuffer->yOff,
+		      pOp->u.copy_tex_image_1d.width,
+		      pOp->u.copy_tex_image_1d.border);
 }
 
 static void
@@ -1868,31 +2616,32 @@ xglCopyTexImage1D (GLenum  target,
 		   GLsizei width,
 		   GLint   border)
 {
-    xglCopyOpRec copy;
+    xglGLOpRec gl;
+    
+    gl.glProc = xglCopyTexImage1DProc;
     
-    copy.copyProc		       = xglDoCopyTexImage1D;
-    copy.u.tex_image_1d.target	       = target;
-    copy.u.tex_image_1d.level	       = level;
-    copy.u.tex_image_1d.internalformat = internalformat;
-    copy.u.tex_image_1d.x	       = x;
-    copy.u.tex_image_1d.y	       = y;
-    copy.u.tex_image_1d.width	       = width;
-    copy.u.tex_image_1d.border	       = border;
+    gl.u.copy_tex_image_1d.target	  = target;
+    gl.u.copy_tex_image_1d.level	  = level;
+    gl.u.copy_tex_image_1d.internalformat = internalformat;
+    gl.u.copy_tex_image_1d.x		  = x;
+    gl.u.copy_tex_image_1d.y		  = y;
+    gl.u.copy_tex_image_1d.width	  = width;
+    gl.u.copy_tex_image_1d.border	  = border;
 
-    xglCopyOp (&copy);
+    xglGLOp (&gl);
 }
 
 static void
-xglDoCopyTexImage2D (xglCopyOpPtr pOp)
+xglCopyTexImage2DProc (xglGLOpPtr pOp)
 {
-    glCopyTexImage2D (pOp->u.tex_image_2d.target,
-		      pOp->u.tex_image_2d.level,
-		      pOp->u.tex_image_2d.internalformat,
-		      cctx->tx + pOp->u.tex_image_2d.x,
-		      cctx->ty + pOp->u.tex_image_2d.y,
-		      pOp->u.tex_image_2d.width,
-		      pOp->u.tex_image_2d.height,
-		      pOp->u.tex_image_2d.border);
+    glCopyTexImage2D (pOp->u.copy_tex_image_2d.target,
+		      pOp->u.copy_tex_image_2d.level,
+		      pOp->u.copy_tex_image_2d.internalformat,
+		      pOp->u.copy_tex_image_2d.x + cctx->pReadBuffer->xOff,
+		      pOp->u.copy_tex_image_2d.y + cctx->pReadBuffer->yOff,
+		      pOp->u.copy_tex_image_2d.width,
+		      pOp->u.copy_tex_image_2d.height,
+		      pOp->u.copy_tex_image_2d.border);
 }
 
 static void
@@ -1905,30 +2654,33 @@ xglCopyTexImage2D (GLenum  target,
 		   GLsizei height,
 		   GLint   border)
 {
-    xglCopyOpRec copy;
+    xglGLOpRec gl;
     
-    copy.copyProc		       = xglDoCopyTexImage2D;
-    copy.u.tex_image_2d.target	       = target;
-    copy.u.tex_image_2d.level	       = level;
-    copy.u.tex_image_2d.internalformat = internalformat;
-    copy.u.tex_image_2d.x	       = x;
-    copy.u.tex_image_2d.y	       = y;
-    copy.u.tex_image_2d.width	       = width;
-    copy.u.tex_image_2d.height	       = height;
-    copy.u.tex_image_2d.border	       = border;
+    gl.glProc = xglCopyTexImage2DProc;
 
-    xglCopyOp (&copy);
+    gl.u.copy_tex_image_2d.target	  = target;
+    gl.u.copy_tex_image_2d.level	  = level;
+    gl.u.copy_tex_image_2d.internalformat = internalformat;
+    gl.u.copy_tex_image_2d.x		  = x;
+    gl.u.copy_tex_image_2d.y		  = y;
+    gl.u.copy_tex_image_2d.width	  = width;
+    gl.u.copy_tex_image_2d.height	  = height;
+    gl.u.copy_tex_image_2d.border	  = border;
+
+    xglGLOp (&gl);
 }
 
 static void
-xglDoCopyTexSubImage1D (xglCopyOpPtr pOp)
+xglCopyTexSubImage1DProc (xglGLOpPtr pOp)
 {
-    glCopyTexSubImage1D (pOp->u.tex_sub_image_1d.target,
-			 pOp->u.tex_sub_image_1d.level,
-			 pOp->u.tex_sub_image_1d.xoffset,
-			 cctx->tx + pOp->u.tex_sub_image_1d.x,
-			 cctx->ty + pOp->u.tex_sub_image_1d.y,
-			 pOp->u.tex_sub_image_1d.width);
+    glCopyTexSubImage1D (pOp->u.copy_tex_sub_image_1d.target,
+			 pOp->u.copy_tex_sub_image_1d.level,
+			 pOp->u.copy_tex_sub_image_1d.xoffset,
+			 pOp->u.copy_tex_sub_image_1d.x +
+			 cctx->pReadBuffer->xOff,
+			 pOp->u.copy_tex_sub_image_1d.y +
+			 cctx->pReadBuffer->yOff,
+			 pOp->u.copy_tex_sub_image_1d.width);
 }
 
 static void
@@ -1939,30 +2691,33 @@ xglCopyTexSubImage1D (GLenum  target,
 		      GLint   y,
 		      GLsizei width)
 {
-    xglCopyOpRec copy;
+    xglGLOpRec gl;
+    
+    gl.glProc = xglCopyTexSubImage1DProc;
     
-    copy.copyProc		    = xglDoCopyTexSubImage1D;
-    copy.u.tex_sub_image_1d.target  = target;
-    copy.u.tex_sub_image_1d.level   = level;
-    copy.u.tex_sub_image_1d.xoffset = xoffset;
-    copy.u.tex_sub_image_1d.x	    = x;
-    copy.u.tex_sub_image_1d.y	    = y;
-    copy.u.tex_sub_image_1d.width   = width;
+    gl.u.copy_tex_sub_image_1d.target  = target;
+    gl.u.copy_tex_sub_image_1d.level   = level;
+    gl.u.copy_tex_sub_image_1d.xoffset = xoffset;
+    gl.u.copy_tex_sub_image_1d.x       = x;
+    gl.u.copy_tex_sub_image_1d.y       = y;
+    gl.u.copy_tex_sub_image_1d.width   = width;
 
-    xglCopyOp (&copy);
+    xglGLOp (&gl);
 }
 
 static void
-xglDoCopyTexSubImage2D (xglCopyOpPtr pOp)
+xglCopyTexSubImage2DProc (xglGLOpPtr pOp)
 {
-    glCopyTexSubImage2D (pOp->u.tex_sub_image_2d.target,
-			 pOp->u.tex_sub_image_2d.level,
-			 pOp->u.tex_sub_image_2d.xoffset,
-			 pOp->u.tex_sub_image_2d.yoffset,
-			 cctx->tx + pOp->u.tex_sub_image_2d.x,
-			 cctx->ty + pOp->u.tex_sub_image_2d.y,
-			 pOp->u.tex_sub_image_2d.width,
-			 pOp->u.tex_sub_image_2d.height);
+    glCopyTexSubImage2D (pOp->u.copy_tex_sub_image_2d.target,
+			 pOp->u.copy_tex_sub_image_2d.level,
+			 pOp->u.copy_tex_sub_image_2d.xoffset,
+			 pOp->u.copy_tex_sub_image_2d.yoffset,
+			 pOp->u.copy_tex_sub_image_2d.x +
+			 cctx->pReadBuffer->xOff,
+			 pOp->u.copy_tex_sub_image_2d.y +
+			 cctx->pReadBuffer->yOff,
+			 pOp->u.copy_tex_sub_image_2d.width,
+			 pOp->u.copy_tex_sub_image_2d.height);
 }
 
 static void
@@ -1975,29 +2730,30 @@ xglCopyTexSubImage2D (GLenum  target,
 		      GLsizei width,
 		      GLsizei height)
 {
-    xglCopyOpRec copy;
+    xglGLOpRec gl;
     
-    copy.copyProc		    = xglDoCopyTexSubImage2D;
-    copy.u.tex_sub_image_2d.target  = target;
-    copy.u.tex_sub_image_2d.level   = level;
-    copy.u.tex_sub_image_2d.xoffset = xoffset;
-    copy.u.tex_sub_image_2d.yoffset = yoffset;
-    copy.u.tex_sub_image_2d.x	    = x;
-    copy.u.tex_sub_image_2d.y	    = y;
-    copy.u.tex_sub_image_2d.width   = width;
-    copy.u.tex_sub_image_2d.height  = height;
+    gl.glProc = xglCopyTexSubImage2DProc;
 
-    xglCopyOp (&copy);
+    gl.u.copy_tex_sub_image_2d.target  = target;
+    gl.u.copy_tex_sub_image_2d.level   = level;
+    gl.u.copy_tex_sub_image_2d.xoffset = xoffset;
+    gl.u.copy_tex_sub_image_2d.yoffset = yoffset;
+    gl.u.copy_tex_sub_image_2d.x       = x;
+    gl.u.copy_tex_sub_image_2d.y       = y;
+    gl.u.copy_tex_sub_image_2d.width   = width;
+    gl.u.copy_tex_sub_image_2d.height  = height;
+
+    xglGLOp (&gl);
 }    
 
 static void
-xglDoCopyColorTable (xglCopyOpPtr pOp)
+xglCopyColorTableProc (xglGLOpPtr pOp)
 {
-    glCopyColorTable (pOp->u.color_table.target,
-		      pOp->u.color_table.internalformat,
-		      cctx->tx + pOp->u.color_table.x,
-		      cctx->ty + pOp->u.color_table.y,
-		      pOp->u.color_table.width);
+    glCopyColorTable (pOp->u.copy_color_table.target,
+		      pOp->u.copy_color_table.internalformat,
+		      pOp->u.copy_color_table.x + cctx->pReadBuffer->xOff,
+		      pOp->u.copy_color_table.y + cctx->pReadBuffer->yOff,
+		      pOp->u.copy_color_table.width);
 }
 
 static void
@@ -2007,26 +2763,27 @@ xglCopyColorTable (GLenum  target,
 		   GLint   y,
 		   GLsizei width)
 {
-    xglCopyOpRec copy;
+    xglGLOpRec gl;
+    
+    gl.glProc = xglCopyColorTableProc;
     
-    copy.copyProc		      = xglDoCopyColorTable;
-    copy.u.color_table.target	      = target;
-    copy.u.color_table.internalformat = internalformat;
-    copy.u.color_table.x	      = x;
-    copy.u.color_table.y	      = y;
-    copy.u.color_table.width	      = width;
+    gl.u.copy_color_table.target	 = target;
+    gl.u.copy_color_table.internalformat = internalformat;
+    gl.u.copy_color_table.x		 = x;
+    gl.u.copy_color_table.y		 = y;
+    gl.u.copy_color_table.width		 = width;
     
-    xglCopyOp (&copy);
+    xglGLOp (&gl);
 }
 
 static void
-xglDoCopyColorSubTable (xglCopyOpPtr pOp)
+xglCopyColorSubTableProc (xglGLOpPtr pOp)
 {
-    glCopyColorTable (pOp->u.color_sub_table.target,
-		      pOp->u.color_sub_table.start,
-		      cctx->tx + pOp->u.color_sub_table.x,
-		      cctx->ty + pOp->u.color_sub_table.y,
-		      pOp->u.color_sub_table.width);
+    glCopyColorTable (pOp->u.copy_color_sub_table.target,
+		      pOp->u.copy_color_sub_table.start,
+		      pOp->u.copy_color_sub_table.x + cctx->pReadBuffer->xOff,
+		      pOp->u.copy_color_sub_table.y + cctx->pReadBuffer->yOff,
+		      pOp->u.copy_color_sub_table.width);
 }
 
 static void
@@ -2036,26 +2793,31 @@ xglCopyColorSubTable (GLenum  target,
 		      GLint   y,
 		      GLsizei width)
 {
-    xglCopyOpRec copy;
+    xglGLOpRec gl;
     
-    copy.copyProc		  = xglDoCopyColorSubTable;
-    copy.u.color_sub_table.target = target;
-    copy.u.color_sub_table.start  = start;
-    copy.u.color_sub_table.x	  = x;
-    copy.u.color_sub_table.y	  = y;
-    copy.u.color_sub_table.width  = width;
+    gl.glProc = xglCopyColorSubTableProc;
     
-    xglCopyOp (&copy);
+    gl.u.copy_color_sub_table.target = target;
+    gl.u.copy_color_sub_table.start  = start;
+    gl.u.copy_color_sub_table.x	     = x;
+    gl.u.copy_color_sub_table.y	     = y;
+    gl.u.copy_color_sub_table.width  = width;
+    
+    xglGLOp (&gl);
 }
 
 static void
-xglDoCopyConvolutionFilter1D (xglCopyOpPtr pOp)
+xglCopyConvolutionFilter1DProc (xglGLOpPtr pOp)
 {
-    glCopyConvolutionFilter1D (pOp->u.convolution_filter_1d.target,
-			       pOp->u.convolution_filter_1d.internalformat,
-			       cctx->tx + pOp->u.convolution_filter_1d.x,
-			       cctx->ty + pOp->u.convolution_filter_1d.y,
-			       pOp->u.convolution_filter_1d.width);
+    GLenum internalformat = pOp->u.copy_convolution_filter_1d.internalformat;
+    
+    glCopyConvolutionFilter1D (pOp->u.copy_convolution_filter_1d.target,
+			       internalformat,
+			       pOp->u.copy_convolution_filter_1d.x +
+			       cctx->pReadBuffer->xOff,
+			       pOp->u.copy_convolution_filter_1d.y +
+			       cctx->pReadBuffer->yOff,
+			       pOp->u.copy_convolution_filter_1d.width);
 }
 
 static void
@@ -2065,27 +2827,32 @@ xglCopyConvolutionFilter1D (GLenum  target,
 			    GLint   y,
 			    GLsizei width)
 {
-    xglCopyOpRec copy;
+    xglGLOpRec gl;
+    
+    gl.glProc = xglCopyConvolutionFilter1DProc;
     
-    copy.copyProc				= xglDoCopyConvolutionFilter1D;
-    copy.u.convolution_filter_1d.target		= target;
-    copy.u.convolution_filter_1d.internalformat = internalformat;
-    copy.u.convolution_filter_1d.x		= x;
-    copy.u.convolution_filter_1d.y		= y;
-    copy.u.convolution_filter_1d.width		= width;
+    gl.u.copy_convolution_filter_1d.target	   = target;
+    gl.u.copy_convolution_filter_1d.internalformat = internalformat;
+    gl.u.copy_convolution_filter_1d.x		   = x;
+    gl.u.copy_convolution_filter_1d.y		   = y;
+    gl.u.copy_convolution_filter_1d.width	   = width;
     
-    xglCopyOp (&copy);
+    xglGLOp (&gl);
 }
 
 static void
-xglDoCopyConvolutionFilter2D (xglCopyOpPtr pOp)
+xglCopyConvolutionFilter2DProc (xglGLOpPtr pOp)
 {
-    glCopyConvolutionFilter2D (pOp->u.convolution_filter_2d.target,
-			       pOp->u.convolution_filter_2d.internalformat,
-			       cctx->tx + pOp->u.convolution_filter_2d.x,
-			       cctx->ty + pOp->u.convolution_filter_2d.y,
-			       pOp->u.convolution_filter_2d.width,
-			       pOp->u.convolution_filter_2d.height);
+    GLenum internalformat = pOp->u.copy_convolution_filter_2d.internalformat;
+    
+    glCopyConvolutionFilter2D (pOp->u.copy_convolution_filter_2d.target,
+			       internalformat,
+			       pOp->u.copy_convolution_filter_2d.x +
+			       cctx->pReadBuffer->xOff,
+			       pOp->u.copy_convolution_filter_2d.y +
+			       cctx->pReadBuffer->yOff,
+			       pOp->u.copy_convolution_filter_2d.width,
+			       pOp->u.copy_convolution_filter_2d.height);
 }
 
 static void
@@ -2096,31 +2863,34 @@ xglCopyConvolutionFilter2D (GLenum  target,
 			    GLsizei width,
 			    GLsizei height)
 {
-    xglCopyOpRec copy;
+    xglGLOpRec gl;
+    
+    gl.glProc = xglCopyConvolutionFilter2DProc;
     
-    copy.copyProc				= xglDoCopyConvolutionFilter2D;
-    copy.u.convolution_filter_2d.target		= target;
-    copy.u.convolution_filter_2d.internalformat = internalformat;
-    copy.u.convolution_filter_2d.x		= x;
-    copy.u.convolution_filter_2d.y		= y;
-    copy.u.convolution_filter_2d.width		= width;
-    copy.u.convolution_filter_2d.height		= height;
+    gl.u.copy_convolution_filter_2d.target	   = target;
+    gl.u.copy_convolution_filter_2d.internalformat = internalformat;
+    gl.u.copy_convolution_filter_2d.x		   = x;
+    gl.u.copy_convolution_filter_2d.y		   = y;
+    gl.u.copy_convolution_filter_2d.width	   = width;
+    gl.u.copy_convolution_filter_2d.height	   = height;
     
-    xglCopyOp (&copy);
+    xglGLOp (&gl);
 }
 
 static void
-xglDoCopyTexSubImage3D (xglCopyOpPtr pOp)
+xglCopyTexSubImage3DProc (xglGLOpPtr pOp)
 {
-    glCopyTexSubImage3D (pOp->u.tex_sub_image_3d.target,
-			 pOp->u.tex_sub_image_3d.level,
-			 pOp->u.tex_sub_image_3d.xoffset,
-			 pOp->u.tex_sub_image_3d.yoffset,
-			 pOp->u.tex_sub_image_3d.zoffset,
-			 cctx->tx + pOp->u.tex_sub_image_3d.x,
-			 cctx->ty + pOp->u.tex_sub_image_3d.y,
-			 pOp->u.tex_sub_image_3d.width,
-			 pOp->u.tex_sub_image_3d.height);
+    glCopyTexSubImage3D (pOp->u.copy_tex_sub_image_3d.target,
+			 pOp->u.copy_tex_sub_image_3d.level,
+			 pOp->u.copy_tex_sub_image_3d.xoffset,
+			 pOp->u.copy_tex_sub_image_3d.yoffset,
+			 pOp->u.copy_tex_sub_image_3d.zoffset,
+			 pOp->u.copy_tex_sub_image_3d.x +
+			 cctx->pReadBuffer->xOff,
+			 pOp->u.copy_tex_sub_image_3d.y +
+			 cctx->pReadBuffer->yOff,
+			 pOp->u.copy_tex_sub_image_3d.width,
+			 pOp->u.copy_tex_sub_image_3d.height);
 }
 
 static void
@@ -2134,20 +2904,21 @@ xglCopyTexSubImage3D (GLenum  target,
 		      GLsizei width,
 		      GLsizei height)
 {
-    xglCopyOpRec copy;
+    xglGLOpRec gl;
     
-    copy.copyProc		    = xglDoCopyTexSubImage3D;
-    copy.u.tex_sub_image_3d.target  = target;
-    copy.u.tex_sub_image_3d.level   = level;
-    copy.u.tex_sub_image_3d.xoffset = xoffset;
-    copy.u.tex_sub_image_3d.yoffset = yoffset;
-    copy.u.tex_sub_image_3d.zoffset = zoffset;
-    copy.u.tex_sub_image_3d.x	    = x;
-    copy.u.tex_sub_image_3d.y	    = y;
-    copy.u.tex_sub_image_3d.width   = width;
-    copy.u.tex_sub_image_3d.height  = height;
+    gl.glProc = xglCopyTexSubImage3DProc;
 
-    xglCopyOp (&copy);
+    gl.u.copy_tex_sub_image_3d.target  = target;
+    gl.u.copy_tex_sub_image_3d.level   = level;
+    gl.u.copy_tex_sub_image_3d.xoffset = xoffset;
+    gl.u.copy_tex_sub_image_3d.yoffset = yoffset;
+    gl.u.copy_tex_sub_image_3d.zoffset = zoffset;
+    gl.u.copy_tex_sub_image_3d.x       = x;
+    gl.u.copy_tex_sub_image_3d.y       = y;
+    gl.u.copy_tex_sub_image_3d.width   = width;
+    gl.u.copy_tex_sub_image_3d.height  = height;
+
+    xglGLOp (&gl);
 }    
 
 __glProcTable __glNativeRenderTable = {
@@ -2259,10 +3030,10 @@ __glProcTable __glNativeRenderTable = {
     glPolygonStipple,
     xglScissor, /* glScissor */
     glShadeModel,
-    glTexParameterf,
-    glTexParameterfv,
-    glTexParameteri,
-    glTexParameteriv,
+    xglTexParameterf, /* glTexParameterf */
+    xglTexParameterfv, /* glTexParameterfv */
+    xglTexParameteri, /* glTexParameteri */
+    xglTexParameteriv, /* glTexParameteriv */
     glTexImage1D,
     glTexImage2D,
     glTexEnvf,
@@ -2361,8 +3132,8 @@ __glProcTable __glNativeRenderTable = {
     glGetTexImage,
     glGetTexParameterfv,
     glGetTexParameteriv,
-    glGetTexLevelParameterfv,
-    glGetTexLevelParameteriv,
+    xglGetTexLevelParameterfv, /* glGetTexLevelParameterfv */
+    xglGetTexLevelParameteriv, /* glGetTexLevelParameteriv */
     xglIsEnabled, /* glIsEnabled */
     xglIsList, /* glIsList */
     glDepthRange,
@@ -2455,6 +3226,33 @@ __glProcTable __glNativeRenderTable = {
 static void
 xglNoOpActiveTextureARB (GLenum texture) {}
 static void
+xglActiveTextureARBProc (xglGLOpPtr pOp)
+{
+    GLenum texUnit;
+
+    texUnit = pOp->u.enumeration - GL_TEXTURE0;
+    if (texUnit < 0 || texUnit >= cctx->maxTexUnits)
+    {
+	xglRecordError (GL_INVALID_ENUM);
+    }
+    else
+    {
+	cctx->activeTexUnit = texUnit;
+	(*cctx->ActiveTextureARB) (pOp->u.enumeration);
+    }
+}
+static void
+xglActiveTextureARB (GLenum texture)
+{
+    xglGLOpRec gl;
+    
+    gl.glProc = xglActiveTextureARBProc;
+
+    gl.u.enumeration = texture;
+
+    xglGLOp (&gl);
+}
+static void
 xglNoOpClientActiveTextureARB (GLenum texture) {}
 static void
 xglNoOpMultiTexCoord1dvARB (GLenum target, const GLdouble *v) {}
@@ -2525,9 +3323,24 @@ xglNoOpPointParameterfvEXT (GLenum pname, const GLfloat *params) {}
 static void
 xglNoOpWindowPos3fMESA (GLfloat x, GLfloat y, GLfloat z) {}
 static void
+xglWindowPos3fMESAProc (xglGLOpPtr pOp)
+{
+    (*cctx->WindowPos3fMESA) (pOp->u.window_pos_3f.x + cctx->pDrawBuffer->xOff,
+			      pOp->u.window_pos_3f.y + cctx->pDrawBuffer->yOff,
+			      pOp->u.window_pos_3f.z);
+}
+static void
 xglWindowPos3fMESA (GLfloat x, GLfloat y, GLfloat z)
 {
-    (*cctx->glRenderTableEXT.WindowPos3fMESA) (cctx->tx + x, cctx->ty + y, z);
+    xglGLOpRec gl;
+    
+    gl.glProc = xglWindowPos3fMESAProc;
+
+    gl.u.window_pos_3f.x = x;
+    gl.u.window_pos_3f.y = y;
+    gl.u.window_pos_3f.z = z;
+
+    xglGLOp (&gl);
 }
 
 /* GL_EXT_blend_func_separate */
@@ -2565,7 +3378,6 @@ static void
 xglNoOpSecondaryColorPointerEXT (GLint size, GLenum type, GLsizei stride,
 				 const GLvoid *pointer) {}
 
-
 /* GL_NV_point_sprite */
 static void
 xglNoOpPointParameteriNV (GLenum pname, GLint params) {}
@@ -2576,6 +3388,136 @@ xglNoOpPointParameterivNV (GLenum pname, const GLint *params) {}
 static void
 xglNoOpActiveStencilFaceEXT (GLenum face) {}
 
+
+/* GL_MESA_render_texture */
+#define GLX_TEXTURE_TARGET_MESA	   0x1
+#define GLX_TEXTURE_2D_MESA	   0x2
+#define GLX_TEXTURE_RECTANGLE_MESA 0x3
+#define GLX_NO_TEXTURE_MESA	   0x4
+#define GLX_FRONT_LEFT_MESA	   0x5
+static int
+xglXBindTexImageMESA (DrawablePtr pDrawable,
+		      int	  buffer)
+{
+    if (buffer != GLX_FRONT_LEFT_MESA)
+	return FALSE;
+
+    if (pDrawable->type != DRAWABLE_WINDOW)
+    {
+        xglGLContextPtr pContext = cctx;
+	xglTexUnitPtr   pTexUnit = &cctx->attrib.texUnits[cctx->activeTexUnit];
+	xglTexObjPtr	pTexObj = NULL;
+	
+	if (xglSyncSurface (pDrawable))
+	{
+	    glitz_point_fixed_t point = { 1 << 16 , 1 << 16 };
+	    
+	    XGL_DRAWABLE_PIXMAP (pDrawable);
+	    XGL_PIXMAP_PRIV (pPixmap);
+    
+	    /* FIXME: doesn't work with 1x1 textures */
+	    glitz_surface_translate_point (pPixmapPriv->surface,
+					   &point, &point);
+	    if (point.x > (1 << 16) || point.y > (1 << 16))
+		pTexObj = pTexUnit->pRect;
+	    else
+		pTexObj = pTexUnit->p2D;
+	    
+	    if (pTexObj)
+	    {
+		pPixmap->refcnt++;
+
+		if (pTexObj->pPixmap)
+		    (*pDrawable->pScreen->DestroyPixmap) (pTexObj->pPixmap);
+	    
+		pTexObj->pPixmap = pPixmap;
+	    }
+	}
+
+	if (pContext != cctx)
+	    xglSetCurrentContext (pContext);
+
+	if (pTexObj)
+	    return TRUE;
+    }
+
+    return FALSE;
+}
+static int
+xglXReleaseTexImageMESA (DrawablePtr pDrawable,
+			 int	     buffer)
+{
+    xglTexObjPtr pTexObj;
+    
+    XGL_DRAWABLE_PIXMAP (pDrawable);
+
+    if (buffer != GLX_FRONT_LEFT_MESA)
+	return FALSE;
+    
+    pTexObj = cctx->attrib.texUnits[cctx->activeTexUnit].p2D;
+    if (pTexObj && pTexObj->pPixmap == pPixmap)
+    {
+	(*pDrawable->pScreen->DestroyPixmap) (pTexObj->pPixmap);
+	pTexObj->pPixmap = NULL;
+    }
+    else
+    {
+	pTexObj = cctx->attrib.texUnits[cctx->activeTexUnit].pRect;
+	if (pTexObj && pTexObj->pPixmap == pPixmap)
+	{
+	    (*pDrawable->pScreen->DestroyPixmap) (pTexObj->pPixmap);
+	    pTexObj->pPixmap = NULL;
+	}
+	else
+	    return FALSE;
+    }
+    
+    return TRUE;
+}
+static int
+xglXQueryDrawableMESA (DrawablePtr  pDrawable,
+		       int	    attribute,
+		       unsigned int *value)
+{
+    switch (attribute) {
+    case GLX_TEXTURE_TARGET_MESA:
+	if (pDrawable->type != DRAWABLE_WINDOW)
+	{
+	    glitz_point_fixed_t point = { 1 << 16 , 1 << 16 };
+	    xglGLContextPtr	pContext = cctx;
+
+	    XGL_DRAWABLE_PIXMAP (pDrawable);
+
+	    if (xglCreatePixmapSurface (pPixmap))
+	    {
+		XGL_PIXMAP_PRIV (pPixmap);
+
+		/* FIXME: doesn't work for 1x1 textures */
+		glitz_surface_translate_point (pPixmapPriv->surface,
+					       &point, &point);
+		if (point.x > (1 << 16) || point.y > (1 << 16))
+		    *value = GLX_TEXTURE_RECTANGLE_MESA;
+		else
+		    *value = GLX_TEXTURE_2D_MESA;
+	    }
+	    else
+		*value = GLX_NO_TEXTURE_MESA;
+
+	    if (pContext != cctx)
+		xglSetCurrentContext (pContext);
+	}
+	else
+	    *value = GLX_NO_TEXTURE_MESA;
+	
+	return TRUE;
+    default:
+	break;
+    }
+
+    *value = 0;
+    return FALSE;
+}
+
 __glProcTableEXT __glNoOpRenderTableEXT = {
     xglNoOpActiveTextureARB,
     xglNoOpClientActiveTextureARB,
@@ -2619,7 +3561,10 @@ __glProcTableEXT __glNoOpRenderTableEXT = {
     xglNoOpSecondaryColorPointerEXT,
     xglNoOpPointParameteriNV,
     xglNoOpPointParameterivNV,
-    xglNoOpActiveStencilFaceEXT
+    xglNoOpActiveStencilFaceEXT,
+    xglXBindTexImageMESA,
+    xglXReleaseTexImageMESA,
+    xglXQueryDrawableMESA
 };
 
 static void
@@ -2633,7 +3578,7 @@ xglInitExtensions (xglGLContextPtr pContext)
 
     if (strstr (extensions, "GL_ARB_multitexture"))
     {
-	pContext->glRenderTableEXT.ActiveTextureARB =
+	pContext->ActiveTextureARB =
 	    (PFNGLACTIVETEXTUREARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glActiveTextureARB");
@@ -2705,7 +3650,16 @@ xglInitExtensions (xglGLContextPtr pContext)
 	    (PFNGLMULTITEXCOORD4SVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord4svARB");
+
+	glGetIntegerv (GL_MAX_LIST_NESTING, &pContext->maxListNesting);
+	glGetIntegerv (GL_MAX_TEXTURE_UNITS_ARB, &pContext->maxTexUnits);
+	if (pContext->maxTexUnits > XGL_MAX_TEXTURE_UNITS)
+	    pContext->maxTexUnits = XGL_MAX_TEXTURE_UNITS;
+
+	pContext->glRenderTableEXT.ActiveTextureARB = xglActiveTextureARB;
     }
+    else
+	pContext->maxTexUnits = 1;
 
     if (strstr (extensions, "GL_ARB_multisample"))
     {
@@ -2839,13 +3793,24 @@ xglInitExtensions (xglGLContextPtr pContext)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glActiveStencilFaceEXT");
     }
+}
     
-    pContext->needInit = FALSE;
+static void
+xglSetCurrentContext (xglGLContextPtr pContext)
+{
+    cctx = pContext;
+
+    glitz_context_make_current (cctx->context);
+
+    __glRenderTable = &__glNativeRenderTable;
+    __glRenderTableEXT = &cctx->glRenderTableEXT;
 }
 
 static void
 xglFreeContext (xglGLContextPtr pContext)
 {
+    int i;
+    
     pContext->refcnt--;
     if (pContext->shared == pContext)
 	pContext->refcnt--;
@@ -2868,10 +3833,8 @@ xglFreeContext (xglGLContextPtr pContext)
 		pTexObj = (xglTexObjPtr) xglHashLookup (pContext->texObjects,
 							key);
 		if (pTexObj)
-		{
-		    glDeleteTextures (1, &pTexObj->name);
-		    xfree (pTexObj);
-		}
+		    xglUnrefTexObj (pTexObj);
+		
 		xglHashRemove (pContext->texObjects, key);
 	    }
 	} while (key);
@@ -2900,12 +3863,22 @@ xglFreeContext (xglGLContextPtr pContext)
 	xglDeleteHashTable (pContext->displayLists);
     }
 
+    for (i = 0; i < pContext->maxTexUnits; i++)
+    {
+	xglUnrefTexObj (pContext->attrib.texUnits[i].p1D);
+	xglUnrefTexObj (pContext->attrib.texUnits[i].p2D);
+	xglUnrefTexObj (pContext->attrib.texUnits[i].p3D);
+	xglUnrefTexObj (pContext->attrib.texUnits[i].pRect);
+	xglUnrefTexObj (pContext->attrib.texUnits[i].pCubeMap);
+    }
+    
     if (pContext->groupList)
 	glDeleteLists (pContext->groupList, 1);
 
     if (pContext->pAttribStack)
 	xfree (pContext->pAttribStack);
     
+    if (pContext->context)
     glitz_context_destroy (pContext->context);
 
     if (pContext->versionString)
@@ -2922,6 +3895,9 @@ xglDestroyContext (__GLcontext *gc)
 
     xglFreeContext (pContext);
 
+    if (!iface)
+	return GL_TRUE;
+
     return (*iface->exports.destroyContext) ((__GLcontext *) iface);
 }
 
@@ -2933,6 +3909,9 @@ xglLoseCurrent (__GLcontext *gc)
 
     __glXFlushContextCache ();
 
+    if (!iface)
+	return GL_TRUE;
+
     return (*iface->exports.loseCurrent) ((__GLcontext *) iface);   
 }
 
@@ -2940,92 +3919,91 @@ static GLboolean
 xglMakeCurrent (__GLcontext *gc)
 {
     xglGLContextPtr	pContext = (xglGLContextPtr) gc;
-    __GLinterface	*iface = pContext->mIface;
+    __GLinterface	*iface = &pContext->iface;
+    __GLinterface	*mIface = pContext->mIface;
     __GLdrawablePrivate *drawPriv = iface->imports.getDrawablePrivate (gc);
     __GLdrawablePrivate *readPriv = iface->imports.getReadablePrivate (gc);
     xglGLBufferPtr	pDrawBufferPriv = drawPriv->private;
     xglGLBufferPtr	pReadBufferPriv = readPriv->private;
-    ScreenPtr		pScreen = pDrawBufferPriv->pScreen;
-    DrawablePtr		pDrawable = pDrawBufferPriv->pDrawable;
-    PixmapPtr		pPixmap = pDrawBufferPriv->pPixmap;
-    GLboolean		status;
+    GLboolean		status = GL_TRUE;
 
-    pContext->target = xglPrepareTarget (pDrawable);
-    if (pContext->target && pPixmap)
+    if (pReadBufferPriv->pDrawable && pDrawBufferPriv->pDrawable)
     {
-	pContext->target = xglPrepareTarget (&pPixmap->drawable);
-	if (pContext->target)
-	{
-	    xglPixmapPtr pFront = XGL_GET_DRAWABLE_PIXMAP_PRIV (pDrawable);
-	    xglPixmapPtr pBack  = XGL_GET_PIXMAP_PRIV (pPixmap);
-	    XID		 value = FALSE;
+	XID values[2] = { ClipByChildren, 0 };
 	    int		 status;
 	    
-	    pContext->attrib.scissor.x = pContext->attrib.scissor.y = 0;
-	    pContext->attrib.scissor.width = pDrawable->width;
-	    pContext->attrib.scissor.height = pDrawable->height;
-
-	    pContext->attrib.viewport.x = pContext->attrib.viewport.y = 0;
-	    pContext->attrib.viewport.width = pDrawable->width;
-	    pContext->attrib.viewport.height = pDrawable->height;
-
-	    pContext->draw = pBack->surface;
-
-	    if (pBack->pArea)
-	    {
-		xglOffscreenPtr pOffscreen = (xglOffscreenPtr)
-		    pBack->pArea->pRoot->closure;
+#ifdef COMPOSITE
+	/* XXX: temporary hack for root window drawing using
+	   IncludeInferiors */
+	if (pDrawBufferPriv->pDrawable->type == DRAWABLE_WINDOW &&
+	    (!((WindowPtr) (pDrawBufferPriv->pDrawable))->parent))
+	    values[0] = IncludeInferiors;
+#endif
+	    
+	/* this happens if client previously used this context with a buffer
+	   not supported by the native GL stack */
+	if (!pContext->context)
+	    return GL_FALSE;
 
-		pContext->tx = pBack->pArea->x;
-		pContext->ty =
-		    glitz_drawable_get_height (pOffscreen->drawable) -
-		    pBack->pArea->y - pDrawable->height;
-	    }
-	    else
-		pContext->tx = pContext->ty = 0;
+	/* XXX: GLX_SGI_make_current_read disabled for now */
+	if (pDrawBufferPriv != pReadBufferPriv)
+	    return GL_FALSE;
 	    
+	pContext->pReadBuffer = pReadBufferPriv;
 	    pContext->pDrawBuffer = pDrawBufferPriv;
 	    
-	    if (!pFront->lock) pFront->lock++;
-	    if (!pBack->lock) pBack->lock++;
+	if (!pReadBufferPriv->pGC)
+	    pReadBufferPriv->pGC =
+		CreateGC (pReadBufferPriv->pDrawable,
+			  GCSubwindowMode | GCGraphicsExposures, values,
+			  &status);
 
-	    glitz_context_set_surface (pContext->context, pContext->draw);
+	ValidateGC (pReadBufferPriv->pDrawable, pReadBufferPriv->pGC);
 
 	    if (!pDrawBufferPriv->pGC)
 		pDrawBufferPriv->pGC =
-		    CreateGC (&pPixmap->drawable,
-			      GCGraphicsExposures, &value,
+		CreateGC (pDrawBufferPriv->pDrawable,
+			  GCSubwindowMode | GCGraphicsExposures, values,
 			      &status);
 	    
-	    ValidateGC (&pPixmap->drawable, pDrawBufferPriv->pGC);
-	    
-	    if (!pDrawBufferPriv->swapGC)
-		pDrawBufferPriv->swapGC =
-		    CreateGC (pDrawable,
-			      GCGraphicsExposures, &value,
-			      &status);
+	ValidateGC (pDrawBufferPriv->pDrawable, pDrawBufferPriv->pGC);
 	    
-	    ValidateGC (pDrawable, pDrawBufferPriv->swapGC);
+	pContext->pReadBuffer = pReadBufferPriv;
+	pContext->pDrawBuffer = pDrawBufferPriv;
 
-	    return GL_TRUE;
-	}
-    } else
-	pContext->target = xglPixmapTargetNo;
+	pReadBufferPriv->pPixmap = (PixmapPtr) 0;
+	pDrawBufferPriv->pPixmap = (PixmapPtr) 0;
 
-    if (pPixmap)
+	/* from now on this context can only be used with native GL stack */
+	if (mIface)
     {
-	(*pScreen->DestroyPixmap) (pPixmap);
-	pDrawBufferPriv->pPixmap = NULL;
+	    (*mIface->exports.destroyContext) ((__GLcontext *) mIface);
+	    pContext->mIface = NULL;
     }
+    }
+    else
+    {
+	/* this happens if client previously used this context with a buffer
+	   supported by the native GL stack */
+	if (!mIface)
+	    return GL_FALSE;
     
     drawPriv->private = pDrawBufferPriv->private;
     readPriv->private = pReadBufferPriv->private;
 
-    status = (*iface->exports.makeCurrent) ((__GLcontext *) iface);
+	status = (*mIface->exports.makeCurrent) ((__GLcontext *) mIface);
 
     drawPriv->private = pDrawBufferPriv;
     readPriv->private = pReadBufferPriv;
 
+	/* from now on this context can not be used with native GL stack */
+	if (status == GL_TRUE && pContext->context)
+	{
+	    glitz_context_destroy (pContext->context);
+	    pContext->context = NULL;
+	}
+    }
+
     return status;
 }
 
@@ -3038,6 +4016,9 @@ xglShareContext (__GLcontext *gc,
     __GLinterface   *iface = pContext->mIface;
     __GLinterface   *ifaceShare = pContextShare->mIface;
 
+    if (!iface || !ifaceShare)
+	return GL_TRUE;
+    
     return (*iface->exports.shareContext) ((__GLcontext *) iface,
 					   (__GLcontext *) ifaceShare);
 }
@@ -3049,14 +4030,21 @@ xglCopyContext (__GLcontext	  *dst,
 {
     xglGLContextPtr pDst = (xglGLContextPtr) dst;
     xglGLContextPtr pSrc = (xglGLContextPtr) src;
-    __GLinterface   *dstIface = pDst->mIface;
-    __GLinterface   *srcIface = pSrc->mIface;
+    const __GLcontext *srcCtx = (const __GLcontext *) pSrc->mIface;
+    __GLinterface     *dstIface = (__GLinterface *) pDst->mIface;
+    GLboolean	      status = GL_TRUE;
 
+    if (pSrc->context && pDst->context)
     glitz_context_copy (pSrc->context, pDst->context, mask);
+    else
+	status = GL_FALSE;
     
-    return (*dstIface->exports.copyContext) ((__GLcontext *) dstIface,
-					     (const __GLcontext *) srcIface,
+    if (dstIface && srcCtx)
+	status = (*dstIface->exports.copyContext) ((__GLcontext *) dstIface,
+						   srcCtx,
 					     mask);
+
+    return status;
 }
 
 static GLboolean
@@ -3064,27 +4052,138 @@ xglForceCurrent (__GLcontext *gc)
 {
     xglGLContextPtr pContext = (xglGLContextPtr) gc;
     __GLinterface   *iface = pContext->mIface;
+    GLboolean	    status = GL_TRUE;
 
-    if (pContext->target)
+    if (pContext->context)
     {
 	cctx = pContext;
 	
-	glitz_context_make_current (cctx->context);
+	if (cctx->pReadBuffer->pDrawable && cctx->pDrawBuffer->pDrawable)
+	{
+	    DrawablePtr pDrawable;
+	    PixmapPtr   pReadPixmap, pDrawPixmap;
+	
+	    pDrawable = cctx->pReadBuffer->pDrawable;
+	    if (pDrawable->type != DRAWABLE_PIXMAP)
+	    {
+		pReadPixmap = XGL_GET_WINDOW_PIXMAP (pDrawable);
+		cctx->pReadBuffer->xOff = pDrawable->x +
+		    __XGL_OFF_X_WIN (pReadPixmap);
+		cctx->pReadBuffer->yOff = pReadPixmap->drawable.height -
+		    ((pDrawable->y + __XGL_OFF_Y_WIN (pReadPixmap)) +
+		     pDrawable->height);
+		cctx->pReadBuffer->yFlip = pReadPixmap->drawable.height;
+	    }
+	    else
+	    {
+		pReadPixmap = (PixmapPtr) pDrawable;
+		cctx->pReadBuffer->xOff = cctx->pReadBuffer->yOff = 0;
+		cctx->pReadBuffer->yFlip = pDrawable->height;
+	    }
+	    
+	    pDrawable = cctx->pDrawBuffer->pDrawable;
+	    if (pDrawable->type != DRAWABLE_PIXMAP)
+	    {
+		pDrawPixmap = XGL_GET_WINDOW_PIXMAP (pDrawable);
+		cctx->pDrawBuffer->xOff = pDrawable->x +
+		    __XGL_OFF_X_WIN (pDrawPixmap);
+		cctx->pDrawBuffer->yOff = pDrawPixmap->drawable.height -
+		    ((pDrawable->y + __XGL_OFF_Y_WIN (pDrawPixmap)) +
+		     pDrawable->height);
+		cctx->pDrawBuffer->yFlip = pDrawPixmap->drawable.height;
+	    }
+	    else
+	    {
+		pDrawPixmap = (PixmapPtr) pDrawable;
+		cctx->pDrawBuffer->xOff = cctx->pDrawBuffer->yOff = 0;
+		cctx->pDrawBuffer->yFlip = pDrawable->height;
+	    }
+	    
+	    /* check if buffers have changed */
+	    if (cctx->pReadBuffer->pPixmap != pReadPixmap ||
+		cctx->pDrawBuffer->pPixmap != pDrawPixmap)
+	    {
+		XGL_SCREEN_PRIV (pDrawable->pScreen);
+		XGL_PIXMAP_PRIV (pDrawPixmap);
+		
+		if (!xglPrepareTarget (pDrawable))
+		    return FALSE;
+		
+		/* draw buffer is offscreen */
+		if (pPixmapPriv->surface != pScreenPriv->surface)
+		{
+		    /* NYI: framebuffer object setup */
+		    FatalError ("NYI: offscreen GL drawable\n");
+		}
+
+		cctx->pReadBuffer->pPixmap = pReadPixmap;
+		cctx->pDrawBuffer->pPixmap = pDrawPixmap;
+	    }
+	}
+
+	xglSetCurrentContext (pContext);
 	
 	if (cctx->needInit)
+	{
+	    int i;
+	    
 	    xglInitExtensions (cctx);
 	
-	__glRenderTable = &__glNativeRenderTable;
-	__glRenderTableEXT = &cctx->glRenderTableEXT;
+	    cctx->attrib.scissorTest = GL_FALSE;
+	    cctx->attrib.scissor.x = cctx->attrib.scissor.y = 0;
+	    cctx->attrib.scissor.width = cctx->pDrawBuffer->pDrawable->width;
+	    cctx->attrib.scissor.height = cctx->pDrawBuffer->pDrawable->height;
+	    cctx->attrib.viewport = cctx->attrib.scissor;
 	
-	return GL_TRUE;
+	    cctx->activeTexUnit = 0;
+
+	    for (i = 0; i < cctx->maxTexUnits; i++)
+	    {
+		cctx->attrib.texUnits[i].enabled = 0;
+		
+		cctx->attrib.texUnits[i].p1D	  = NULL;
+		cctx->attrib.texUnits[i].p2D	  = NULL;
+		cctx->attrib.texUnits[i].p3D	  = NULL;
+		cctx->attrib.texUnits[i].pRect	  = NULL;
+		cctx->attrib.texUnits[i].pCubeMap = NULL;
     }
 
+	    glEnable (GL_SCISSOR_TEST);
+
+	    cctx->needInit = FALSE;
+	}
+
+	/* update viewport and raster position */
+	if (cctx->pDrawBuffer->xOff != cctx->drawXoff ||
+	    cctx->pDrawBuffer->yOff != cctx->drawYoff)
+	{
+	    glViewport (cctx->attrib.scissor.x + cctx->pDrawBuffer->xOff,
+			cctx->attrib.scissor.y + cctx->pDrawBuffer->yOff,
+			cctx->attrib.scissor.width,
+			cctx->attrib.scissor.height);
+
+	    glBitmap (0, 0, 0, 0,
+		      cctx->pDrawBuffer->xOff - cctx->drawXoff,
+		      cctx->pDrawBuffer->yOff - cctx->drawYoff,
+		      NULL);
+
+	    cctx->drawXoff = cctx->pDrawBuffer->xOff;
+	    cctx->drawYoff = cctx->pDrawBuffer->yOff;
+	}
+
+	glDrawBuffer (cctx->attrib.drawBuffer);
+	glReadBuffer (cctx->attrib.readBuffer);
+    }
+    else
+    {
     cctx = NULL;
     __glRenderTable = &__glMesaRenderTable;
     __glRenderTableEXT = &__glMesaRenderTableEXT;
 	
-    return (*iface->exports.forceCurrent) ((__GLcontext *) iface);
+	status = (*iface->exports.forceCurrent) ((__GLcontext *) iface);
+    }
+
+    return status;
 }
 
 static GLboolean
@@ -3093,6 +4192,9 @@ xglNotifyResize (__GLcontext *gc)
     xglGLContextPtr pContext = (xglGLContextPtr) gc;
     __GLinterface   *iface = pContext->mIface;
 
+    if (!iface)
+	return GL_TRUE;
+    
     return (*iface->exports.notifyResize) ((__GLcontext *) iface);
 }
 
@@ -3102,7 +4204,8 @@ xglNotifyDestroy (__GLcontext *gc)
     xglGLContextPtr pContext = (xglGLContextPtr) gc;
     __GLinterface   *iface = pContext->mIface;
 
-    return (*iface->exports.notifyDestroy) ((__GLcontext *) iface);
+    if (iface)
+	(*iface->exports.notifyDestroy) ((__GLcontext *) iface);
 }
 
 static void
@@ -3111,7 +4214,8 @@ xglNotifySwapBuffers (__GLcontext *gc)
     xglGLContextPtr pContext = (xglGLContextPtr) gc;
     __GLinterface   *iface = pContext->mIface;
 
-    return (*iface->exports.notifySwapBuffers) ((__GLcontext *) iface);
+    if (iface)
+	(*iface->exports.notifySwapBuffers) ((__GLcontext *) iface);
 }
 
 static struct __GLdispatchStateRec *
@@ -3120,6 +4224,9 @@ xglDispatchExec (__GLcontext *gc)
     xglGLContextPtr pContext = (xglGLContextPtr) gc;
     __GLinterface   *iface = pContext->mIface;
 
+    if (!iface)
+	return NULL;
+    
     return (*iface->exports.dispatchExec) ((__GLcontext *) iface);
 }
 
@@ -3129,7 +4236,8 @@ xglBeginDispatchOverride (__GLcontext *gc)
     xglGLContextPtr pContext = (xglGLContextPtr) gc;
     __GLinterface   *iface = pContext->mIface;
 
-    return (*iface->exports.beginDispatchOverride) ((__GLcontext *) iface);
+    if (iface)
+	(*iface->exports.beginDispatchOverride) ((__GLcontext *) iface);
 }
 
 static void
@@ -3138,7 +4246,8 @@ xglEndDispatchOverride (__GLcontext *gc)
     xglGLContextPtr pContext = (xglGLContextPtr) gc;
     __GLinterface   *iface = pContext->mIface;
 
-    return (*iface->exports.endDispatchOverride) ((__GLcontext *) iface);
+    if (iface)
+	(*iface->exports.endDispatchOverride) ((__GLcontext *) iface);
 }
 
 static void
@@ -3176,19 +4285,32 @@ xglCreateContext (__GLimports      *imports,
 				 xglLoseCurrentContext);
 	
     pContext->needInit	    = TRUE;
-    pContext->draw	    = NULL;
-    pContext->target	    = FALSE;
     pContext->versionString = NULL;
-    pContext->error	    = GL_NO_ERROR;
+    pContext->errorValue    = GL_NO_ERROR;
     pContext->shared	    = NULL;
     pContext->list	    = 0;
     pContext->groupList	    = 0;
     pContext->pAttribStack  = NULL;
     pContext->nAttribStack  = 0;
     pContext->refcnt	    = 1;
+    pContext->doubleBuffer  = glxCtx->pGlxVisual->doubleBuffer;
+    pContext->depthBits     = glxCtx->pGlxVisual->depthSize;
+    pContext->stencilBits   = glxCtx->pGlxVisual->stencilSize;
+    pContext->drawXoff	    = 0;
+    pContext->drawYoff	    = 0;
+    pContext->maxTexUnits   = 0;
 
+    if (pContext->doubleBuffer)
+    {
     pContext->attrib.drawBuffer  = GL_BACK;
     pContext->attrib.readBuffer  = GL_BACK;
+    }
+    else
+    {
+	pContext->attrib.drawBuffer = GL_FRONT;
+	pContext->attrib.readBuffer = GL_FRONT;
+    }
+    
     pContext->attrib.scissorTest = GL_FALSE;
     
     if (shareGC)
@@ -3252,35 +4374,64 @@ xglSwapBuffers (__GLXdrawablePrivate *glxPriv)
     __GLdrawablePrivate	*glPriv = &glxPriv->glPriv;
     xglGLBufferPtr	pBufferPriv = glPriv->private;
     DrawablePtr		pDrawable = pBufferPriv->pDrawable;
-    PixmapPtr		pPixmap = pBufferPriv->pPixmap;
-    GCPtr		pGC = pBufferPriv->swapGC;
-    GLboolean		ret;
+    GLboolean		status = GL_TRUE;
     
-    if (pPixmap)
+    if (pDrawable)
     {
-	/* Discard front buffer damage */
-	REGION_EMPTY (pGC->pScreen, &pBufferPriv->damage);
-	
-	if (pGC)
+	if (glPriv->modes->doubleBufferMode)
 	{
-	    (*pGC->ops->CopyArea) ((DrawablePtr) pPixmap,
-				   pDrawable, pGC,
-				   0, 0,
-				   pPixmap->drawable.width,
-				   pPixmap->drawable.height,
-				   0, 0);
+	    glitz_surface_t *surface;
+	    int		    xOff, yOff;
+	    GCPtr	    pGC  = pBufferPriv->pGC;
+	    BoxPtr	    pBox = REGION_RECTS (pGC->pCompositeClip);
+	    int		    nBox = REGION_NUM_RECTS (pGC->pCompositeClip);
 	    
-	    return GL_TRUE;
-	}
+	    XGL_SCREEN_PRIV (pGC->pScreen);
 
+	    if (!xglPrepareTarget (pDrawable))
 	return GL_FALSE;
+	    
+	    XGL_GET_DRAWABLE (pDrawable, surface, xOff, yOff);
+
+	    /* native swap buffers for fullscreen windows */
+	    if (surface == pScreenPriv->surface &&
+		nBox == 1 &&
+		pBox->x1 <= 0 &&
+		pBox->y1 <= 0 &&
+		pBox->x2 >= pGC->pScreen->width &&
+		pBox->y2 >= pGC->pScreen->height)
+	    {
+		glitz_drawable_swap_buffers (pScreenPriv->drawable);
+	    }
+	    else
+	    {
+		glitz_surface_set_clip_region (surface, xOff, yOff,
+					       (glitz_box_t *) pBox, nBox);
+
+		glitz_copy_area (pBufferPriv->backSurface,
+				 surface,
+				 pDrawable->x + xOff,
+				 pDrawable->y + yOff,
+				 pDrawable->width,
+				 pDrawable->height,
+				 pDrawable->x + xOff,
+				 pDrawable->y + yOff);
+		
+		glitz_surface_set_clip_region (surface, 0, 0, NULL, 0);
     }
     
+	    DamageDamageRegion (pDrawable, pGC->pCompositeClip);
+	    REGION_EMPTY (pGC->pScreen, &pBufferPriv->damage);
+	}
+    }
+    else if (pBufferPriv->private)
+    {
     glPriv->private = pBufferPriv->private;
-    ret = (*pBufferPriv->swapBuffers) (glxPriv);
+	status = (*pBufferPriv->swapBuffers) (glxPriv);
     glPriv->private = pBufferPriv;
+    }
     
-    return ret;
+    return status;
 }
 
 static GLboolean
@@ -3294,32 +4445,47 @@ xglResizeBuffers (__GLdrawableBuffer  *buffer,
 {
     xglGLBufferPtr pBufferPriv = glPriv->private;
     DrawablePtr    pDrawable = pBufferPriv->pDrawable;
-    PixmapPtr	   pPixmap = pBufferPriv->pPixmap;
-    ScreenPtr      pScreen = pBufferPriv->pScreen;
-    Bool	   status;
+    GLboolean	   status = GL_TRUE;
     
-    if (pPixmap)
+    if (pDrawable)
     {
-	if (pPixmap->drawable.width  != width ||
-	    pPixmap->drawable.height != height)
+	if (glPriv->modes->doubleBufferMode)
 	{   
-	    (*pScreen->DestroyPixmap) (pPixmap);
-	    pPixmap = (*pScreen->CreatePixmap) (pScreen, width, height,
-						pDrawable->depth);
+	    glitz_surface_t *surface = pBufferPriv->backSurface;
+
+	    XGL_SCREEN_PRIV (pDrawable->pScreen);
+	
+	    /* FIXME: copy color buffer bits, stencil bits and depth bits */
 
-	    /* give good initial score */
-	    XGL_GET_PIXMAP_PRIV (pPixmap)->score = 4000;
-	    pBufferPriv->pPixmap = pPixmap;
+	    if (surface != pScreenPriv->backSurface &&
+		(glitz_surface_get_width (surface)  != width ||
+		 glitz_surface_get_height (surface) != height))
+	    {
+		glitz_format_t *format;
+
+		format = pScreenPriv->pixmapFormats[pDrawable->depth].format;
+		
+		glitz_surface_destroy (surface);
+		
+		pBufferPriv->backSurface =
+		    glitz_surface_create (pScreenPriv->drawable, format,
+					  width, height, 0, NULL);
+		if (!pBufferPriv->backSurface)
+		    status = GL_FALSE;
 	}
-	ValidateGC (pDrawable, pBufferPriv->swapGC);
     }
     
+	ValidateGC (pDrawable, pBufferPriv->pGC);
+    }
+    else if (pBufferPriv->private)
+    {
     glPriv->private = pBufferPriv->private;
     status = (*pBufferPriv->resizeBuffers) (buffer,
 					    x, y, width, height,
 					    glPriv,
 					    bufferMask);
     glPriv->private = pBufferPriv;
+    }
     
     return status;
 }
@@ -3328,20 +4494,17 @@ static void
 xglFreeBuffers (__GLdrawablePrivate *glPriv)
 {
     xglGLBufferPtr pBufferPriv = glPriv->private;
-    ScreenPtr      pScreen = pBufferPriv->pScreen;
     
     glPriv->private = pBufferPriv->private;
 
+    if (pBufferPriv->freeBuffers)
     (*pBufferPriv->freeBuffers) (glPriv);
     
-    if (pBufferPriv->pPixmap)
-	(*pScreen->DestroyPixmap) (pBufferPriv->pPixmap);
-
     if (pBufferPriv->pGC)
 	FreeGC (pBufferPriv->pGC, (GContext) 0);
 
-    if (pBufferPriv->swapGC)
-	FreeGC (pBufferPriv->swapGC, (GContext) 0);
+    if (pBufferPriv->backSurface)
+	glitz_surface_destroy (pBufferPriv->backSurface);
     
     xfree (pBufferPriv);
 }
@@ -3354,43 +4517,77 @@ xglCreateBuffer (__GLXdrawablePrivate *glxPriv)
     ScreenPtr		pScreen = pDrawable->pScreen;
     xglGLBufferPtr	pBufferPriv;
 
-    XGL_DRAWABLE_PIXMAP_PRIV (pDrawable);
+    XGL_SCREEN_PRIV (pScreen);
     
     pBufferPriv = xalloc (sizeof (xglGLBufferRec));
     if (!pBufferPriv)
-	FatalError ("No memory");
+	FatalError ("xglCreateBuffer: No memory\n");
 
     pBufferPriv->pScreen = pScreen;
-    pBufferPriv->pDrawable = pDrawable;
+    pBufferPriv->pDrawable     = NULL;
     pBufferPriv->pPixmap = NULL;
     pBufferPriv->pGC = NULL;
-    pBufferPriv->swapGC = NULL;
+    pBufferPriv->backSurface   = NULL;
+
+    pBufferPriv->swapBuffers   = NULL;
+    pBufferPriv->resizeBuffers = NULL;
+    pBufferPriv->private       = NULL;
+    pBufferPriv->freeBuffers   = NULL;
 
     REGION_INIT (pScreen, &pBufferPriv->damage, NullBox, 0);
     
+    /* use native back buffer for regular windows */
+    if (pDrawable->type == DRAWABLE_WINDOW
+
+#ifdef COMPOSITE
+	/* this is a root window, can't be redirected */
+	&& (!((WindowPtr) pDrawable)->parent)
+#endif
+
+	)
+    {
+	pBufferPriv->pDrawable = pDrawable;
+	
     if (glxPriv->pGlxVisual->doubleBuffer)
-	pBufferPriv->pPixmap =
-	    (*pScreen->CreatePixmap) (pScreen,
-				      pDrawable->width,
-				      pDrawable->height,
-				      pDrawable->depth);
+	{
+	    pBufferPriv->backSurface = pScreenPriv->backSurface;
+	    glitz_surface_reference (pScreenPriv->backSurface);
+	}
+    }
+    else if (0) /*pScreenPriv->features &
+		 GLITZ_FEATURE_FRAMEBUFFER_OBJECT_MASK) */
+    {
+	pBufferPriv->pDrawable = pDrawable;
 
-    /* give good initial score */
-    pPixmapPriv->score = 4000;
+	if (glxPriv->pGlxVisual->doubleBuffer)
+	{
+	    int depth = pDrawable->depth;
 
+	    pBufferPriv->backSurface =
+	    	glitz_surface_create (pScreenPriv->drawable,
+				      pScreenPriv->pixmapFormats[depth].format,
+				      pDrawable->width, pDrawable->height,
+				      0, NULL);
+	    if (!pBufferPriv->backSurface)
+		FatalError ("xglCreateBuffer: glitz_surface_create\n");
+	}
+    }
+    else
+    {
     (*screenInfoPriv.createBuffer) (glxPriv);
 
-    /* Wrap the front buffer's resize routine */
+	/* wrap the swap buffers routine */
+	pBufferPriv->swapBuffers = glxPriv->swapBuffers;
+	
+	/* wrap the front buffer's resize routine and freePrivate */
     pBufferPriv->resizeBuffers = glPriv->frontBuffer.resize;
-    glPriv->frontBuffer.resize = xglResizeBuffers;
+	pBufferPriv->freeBuffers   = glPriv->freePrivate;
+	pBufferPriv->private	   = glPriv->private;
+    }
 
-    /* Wrap the swap buffers routine */
-    pBufferPriv->swapBuffers = glxPriv->swapBuffers;
     glxPriv->swapBuffers = xglSwapBuffers;
 
-    /* Wrap private and freePrivate */
-    pBufferPriv->private = glPriv->private;
-    pBufferPriv->freeBuffers = glPriv->freePrivate;
+    glPriv->frontBuffer.resize = xglResizeBuffers;
     glPriv->private = (void *) pBufferPriv;
     glPriv->freePrivate = xglFreeBuffers;
 }
@@ -3419,6 +4616,68 @@ xglScreenProbe (int screen)
     return status;
 }
 
+static int
+xglXWaitX (__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXWaitXReq *req = (xGLXWaitXReq *) pc;
+    __GLXcontext *cx;
+    
+    cx = (__GLXcontext *) __glXLookupContextByTag (cl, req->contextTag);
+    if (cx)
+    {
+	xglGLContextPtr pContext = (xglGLContextPtr) cx->gc;
+	__GLXcontext    *glxCtx = (__GLXcontext *)
+	    pContext->iface.imports.other;
+	
+	XGL_SCREEN_PRIV (glxCtx->pScreen);
+	
+	glitz_drawable_finish (pScreenPriv->drawable);
+
+	return Success;
+    }
+    else
+    { 
+	cl->client->errorValue = req->contextTag;
+	return __glXBadContextTag;
+    }
+}
+
+static int
+xglXSwapWaitX (__GLXclientState *cl, GLbyte *pc)
+{
+    xGLXWaitXReq *req = (xGLXWaitXReq *) pc;
+    __GLX_DECLARE_SWAP_VARIABLES;
+
+    __GLX_SWAP_SHORT (&req->length);
+    __GLX_SWAP_INT (&req->contextTag);
+
+    return xglXWaitX (cl, pc);
+}
+
+static Bool
+xglDestroyWindow (WindowPtr pWin)
+{
+    ScreenPtr pScreen = pWin->drawable.pScreen;
+    Bool      ret;
+    
+    XGL_SCREEN_PRIV (pScreen);
+
+    if (cctx)
+    {
+	if (cctx->pDrawBuffer->pDrawable == &pWin->drawable)
+	    cctx->pDrawBuffer->pDrawable = NULL;
+
+	if (cctx->pReadBuffer->pDrawable == &pWin->drawable)
+	    cctx->pReadBuffer->pDrawable = NULL;
+    }
+    
+    XGL_SCREEN_UNWRAP (DestroyWindow);
+    ret = (*pScreen->DestroyWindow) (pWin);
+    XGL_SCREEN_WRAP (DestroyWindow, xglDestroyWindow);
+
+    return ret;
+}
+
 Bool
 xglInitVisualConfigs (ScreenPtr pScreen)
 {
@@ -3441,11 +4700,31 @@ xglInitVisualConfigs (ScreenPtr pScreen)
 
     XGL_SCREEN_PRIV (pScreen);
     
+    XGL_SCREEN_WRAP (DestroyWindow, xglDestroyWindow);
+    
     depth  = pScreenPriv->pVisual->pPixel->depth;
     bpp    = pScreenPriv->pVisual->pPixel->masks.bpp;
     format = glitz_drawable_get_format (pScreenPriv->drawable);
     pPixel = pScreenPriv->pixmapFormats[depth].pPixel;
 
+    if (format->doublebuffer)
+    {
+	pScreenPriv->backSurface =
+	    glitz_surface_create (pScreenPriv->drawable,
+				  pScreenPriv->pixmapFormats[depth].format,
+				  pScreen->width, pScreen->height,
+				  0, NULL);
+	if (!pScreenPriv->backSurface)
+	    return FALSE;
+
+	glitz_surface_attach (pScreenPriv->backSurface,
+			      pScreenPriv->drawable,
+			      GLITZ_DRAWABLE_BUFFER_BACK_COLOR,
+			      0, 0);
+
+	numConfig *= 2;
+    }
+
     pConfig = xcalloc (sizeof (__GLXvisualConfig), numConfig);
     if (!pConfig)
 	return FALSE;
@@ -3501,9 +4780,20 @@ xglInitVisualConfigs (ScreenPtr pScreen)
 	    pConfig[i].alphaMask = 0;
 	}
 
+	if (i == 1)
+	{
+	    pConfig[i].doubleBuffer = FALSE;
+	    pConfig[i].depthSize    = 0;
+	    pConfig[i].stencilSize  = 0;
+	
+	}
+	else
+	{
 	pConfig[i].doubleBuffer = TRUE;
 	pConfig[i].depthSize = format->depth_size;
 	pConfig[i].stencilSize = format->stencil_size;
+	}
+	
 	pConfig[i].stereo = FALSE;
 	
 	if (depth == 16)
@@ -3531,6 +4821,9 @@ xglInitVisualConfigs (ScreenPtr pScreen)
     {
 	screenInfoPriv.screenProbe    = __glDDXScreenInfo.screenProbe;
 	__glDDXScreenInfo.screenProbe = xglScreenProbe;
+
+	__glXSingleTable[9]     = xglXWaitX;
+	__glXSwapSingleTable[9] = xglXSwapWaitX;
     }
 
     visuals    = pScreen->visuals;
@@ -3572,8 +4865,6 @@ xglInitVisualConfigs (ScreenPtr pScreen)
     xfree (pConfigPriv);
     xfree (pConfig);
 
-    ErrorF ("[glx] initialized\n");
-    
     return TRUE;
 }
 
