diff --git a/hw/dmx/glxProxy/glxcmds.c b/hw/dmx/glxProxy/glxcmds.c
index fb4bce8..49c6ef1 100644
--- a/hw/dmx/glxProxy/glxcmds.c
+++ b/hw/dmx/glxProxy/glxcmds.c
@@ -69,11 +69,13 @@ extern int __glXGetFBConfigsSGIX(__GLXclientState *cl, GLbyte *pc);
              (x) - dmxScreen->glxErrorBase + __glXerrorBase \
 	     : (x) )
 
-static __GLXFBConfig *glxLookupFBConfig( GLXFBConfigID id )
+static __GLXFBConfig *
+glxLookupFBConfig(GLXFBConfigID id)
 {
    int i,j;
 
-   for (i=0, j=0; i<__glXNumFBConfigs; i++,j+=(__glXNumActiveScreens+1) ) {
+    for (i = 0, j = 0; i < __glXNumFBConfigs;
+         i++, j += (__glXNumActiveScreens + 1)) {
       if ( __glXFBConfigs[j]->id == id)
 	 return __glXFBConfigs[j];
    }
@@ -81,11 +83,13 @@ static __GLXFBConfig *glxLookupFBConfig( GLXFBConfigID id )
    return NULL;
 }
 
-static __GLXFBConfig *glxLookupFBConfigByVID( VisualID vid )
+static __GLXFBConfig *
+glxLookupFBConfigByVID(VisualID vid)
 {
    int i,j;
 
-   for (i=0, j=0; i<__glXNumFBConfigs; i++,j+=(__glXNumActiveScreens+1) ) {
+    for (i = 0, j = 0; i < __glXNumFBConfigs;
+         i++, j += (__glXNumActiveScreens + 1)) {
       if ( __glXFBConfigs[j]->associatedVisualId == vid)
 	 return __glXFBConfigs[j];
    }
@@ -93,12 +97,14 @@ static __GLXFBConfig *glxLookupFBConfigByVID( VisualID vid )
    return NULL;
 }
 
-static __GLXFBConfig *glxLookupBackEndFBConfig( GLXFBConfigID id, int screen )
+static __GLXFBConfig *
+glxLookupBackEndFBConfig(GLXFBConfigID id, int screen)
 {
    int i;
    int j;
 
-   for (i=0, j=0; i<__glXNumFBConfigs; i++,j+=(__glXNumActiveScreens+1) ) {
+    for (i = 0, j = 0; i < __glXNumFBConfigs;
+         i++, j += (__glXNumActiveScreens + 1)) {
       if ( __glXFBConfigs[j]->id == id)
 	 return __glXFBConfigs[j+screen+1];
    }
@@ -107,10 +113,12 @@ static __GLXFBConfig *glxLookupBackEndFBConfig( GLXFBConfigID id, int screen )
 
 }
 
-Display *GetBackEndDisplay( __GLXclientState *cl, int s )
+Display *
+GetBackEndDisplay(__GLXclientState * cl, int s)
 {
    if (! cl->be_displays[s] ) {
-      cl->be_displays[s] = XOpenDisplay( DisplayString(dmxScreens[s].beDisplay) );
+        cl->be_displays[s] =
+            XOpenDisplay(DisplayString(dmxScreens[s].beDisplay));
    }
    return cl->be_displays[s];
 }
@@ -118,12 +126,11 @@ Display *GetBackEndDisplay( __GLXclientState *cl, int s )
 /*
 ** Create a GL context with the given properties.
 */
-static int CreateContext(__GLXclientState *cl, 
+static int
+CreateContext(__GLXclientState * cl,
                          GLXContextID gcId,
 			 VisualID vid, GLXFBConfigID fbconfigId,
-			 int screen,
-			 GLXContextID shareList,
-			 int isDirect )
+              int screen, GLXContextID shareList, int isDirect)
 {
     ClientPtr client = cl->client;
     xGLXCreateContextReq *be_req;
@@ -151,7 +158,6 @@ static int CreateContext(__GLXclientState *cl,
 	return BadValue;
     }
 
-
 #ifdef PANORAMIX
     if (!noPanoramiXExtension) {
        from_screen = 0;
@@ -165,7 +171,8 @@ static int CreateContext(__GLXclientState *cl,
      */
     if (shareList == None) {
        shareglxc = NULL;
-    } else {
+    }
+    else {
        dixLookupResourceByType((pointer*) &shareglxc, shareList,
                                __glXContextRes, NullClient, DixUnknownAccess);
        if (!shareglxc) {
@@ -267,13 +274,16 @@ static int CreateContext(__GLXclientState *cl,
 
     for (screen = from_screen; screen <= to_screen; screen++) {
        int sent = 0;
+
        pScreen = screenInfo.screens[screen];
        pGlxScreen = &__glXActiveScreens[screen];
        dmxScreen = &dmxScreens[screen];
 
        if (glxc->pFBConfig) {
-	  __GLXFBConfig *beFBConfig = glxLookupBackEndFBConfig( glxc->pFBConfig->id, 
+            __GLXFBConfig *beFBConfig =
+                glxLookupBackEndFBConfig(glxc->pFBConfig->id,
 		                                                screen );
+
 	  be_fbconfigId = beFBConfig->id;
        }
 
@@ -292,7 +302,8 @@ static int CreateContext(__GLXclientState *cl,
 	  }
        }
 
-       glxc->real_ids[screen-from_screen] = XAllocID(GetBackEndDisplay(cl,screen));
+        glxc->real_ids[screen - from_screen] =
+            XAllocID(GetBackEndDisplay(cl, screen));
 
        /* send the create context request to the back-end server */
        dpy = GetBackEndDisplay(cl,screen);
@@ -303,6 +314,7 @@ static int CreateContext(__GLXclientState *cl,
 	      * classes does not support RGB mode only COLOR INDEX ,
 	      * and so TrueColor and DirectColor does not support COLOR INDEX*/
 	     int renderType =  glxc->pFBConfig->renderType;  
+
 	     if ( pVisual ) {
 		 switch ( pVisual->class ){
 		     case PseudoColor:
@@ -323,12 +335,14 @@ static int CreateContext(__GLXclientState *cl,
 	     GetReq(GLXCreateNewContext,be_new_req);
 	     be_new_req->reqType = dmxScreen->glxMajorOpcode;
 	     be_new_req->glxCode = X_GLXCreateNewContext;
-	     be_new_req->context = (unsigned int)glxc->real_ids[screen-from_screen];
+                be_new_req->context =
+                    (unsigned int) glxc->real_ids[screen - from_screen];
 	     be_new_req->fbconfig = (unsigned int)be_fbconfigId;
 	     be_new_req->screen = DefaultScreen(dpy);
 	     be_new_req->renderType = renderType;  
 
-	     be_new_req->shareList = (shareglxc ? shareglxc->real_ids[screen-from_screen] : 0);
+                be_new_req->shareList =
+                    (shareglxc ? shareglxc->real_ids[screen - from_screen] : 0);
 	     be_new_req->isDirect = 0;
 	     UnlockDisplay(dpy);
 	     glxc->real_vids[screen-from_screen] = be_fbconfigId;
@@ -338,19 +352,22 @@ static int CreateContext(__GLXclientState *cl,
 
 	     xGLXCreateContextWithConfigSGIXReq *ext_req;
 	     xGLXVendorPrivateReq *vpreq;
+
 	     LockDisplay(dpy);
 	     GetReqExtra(GLXVendorPrivate,
-		         sz_xGLXCreateContextWithConfigSGIXReq - sz_xGLXVendorPrivateReq,
-			vpreq);
+                            sz_xGLXCreateContextWithConfigSGIXReq -
+                            sz_xGLXVendorPrivateReq, vpreq);
 	     ext_req = (xGLXCreateContextWithConfigSGIXReq *)vpreq;
 	     ext_req->reqType = dmxScreen->glxMajorOpcode;
 	     ext_req->glxCode = X_GLXVendorPrivate;
 	     ext_req->vendorCode = X_GLXvop_CreateContextWithConfigSGIX;
-	     ext_req->context = (unsigned int)glxc->real_ids[screen-from_screen];
+                ext_req->context =
+                    (unsigned int) glxc->real_ids[screen - from_screen];
 	     ext_req->fbconfig = (unsigned int)be_fbconfigId;
 	     ext_req->screen = DefaultScreen(dpy);
 	     ext_req->renderType = renderType;  
-	     ext_req->shareList = (shareglxc ? shareglxc->real_ids[screen-from_screen] : 0);
+                ext_req->shareList =
+                    (shareglxc ? shareglxc->real_ids[screen - from_screen] : 0);
 	     ext_req->isDirect = 0;
 	     UnlockDisplay(dpy);
 	     glxc->real_vids[screen-from_screen] = be_fbconfigId;
@@ -363,10 +380,12 @@ static int CreateContext(__GLXclientState *cl,
 	  GetReq(GLXCreateContext,be_req);
 	  be_req->reqType = dmxScreen->glxMajorOpcode;
 	  be_req->glxCode = X_GLXCreateContext;
-	  be_req->context = (unsigned int)glxc->real_ids[screen-from_screen];
+            be_req->context =
+                (unsigned int) glxc->real_ids[screen - from_screen];
 	  be_req->visual = (unsigned int)be_vid;
 	  be_req->screen = DefaultScreen(dpy);
-	  be_req->shareList = (shareglxc ? shareglxc->real_ids[screen-from_screen] : 0);
+            be_req->shareList =
+                (shareglxc ? shareglxc->real_ids[screen - from_screen] : 0);
 	  be_req->isDirect = 0;
 	  UnlockDisplay(dpy);
 	  glxc->real_vids[screen-from_screen] = be_vid;
@@ -398,7 +417,8 @@ static int CreateContext(__GLXclientState *cl,
     return Success;
 }
 
-int __glXCreateContext(__GLXclientState *cl, GLbyte *pc)
+int
+__glXCreateContext(__GLXclientState * cl, GLbyte * pc)
 {
     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;
 
@@ -407,7 +427,8 @@ int __glXCreateContext(__GLXclientState *cl, GLbyte *pc)
 
 }
 
-int __glXCreateNewContext(__GLXclientState *cl, GLbyte *pc)
+int
+__glXCreateNewContext(__GLXclientState * cl, GLbyte * pc)
 {
     xGLXCreateNewContextReq *req = (xGLXCreateNewContextReq *) pc;
 
@@ -416,16 +437,19 @@ int __glXCreateNewContext(__GLXclientState *cl, GLbyte *pc)
 
 }
 
-int __glXCreateContextWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)
+int
+__glXCreateContextWithConfigSGIX(__GLXclientState * cl, GLbyte * pc)
 {
-    xGLXCreateContextWithConfigSGIXReq *req = (xGLXCreateContextWithConfigSGIXReq *) pc;
+    xGLXCreateContextWithConfigSGIXReq *req =
+        (xGLXCreateContextWithConfigSGIXReq *) pc;
 
     return( CreateContext(cl, req->context, None, req->fbconfig,
 	                  req->screen, req->shareList, req->isDirect) );
 
 }
 
-int __glXQueryMaxSwapBarriersSGIX(__GLXclientState *cl, GLbyte *pc)
+int
+__glXQueryMaxSwapBarriersSGIX(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXQueryMaxSwapBarriersSGIXReq *req =
@@ -439,7 +463,8 @@ int __glXQueryMaxSwapBarriersSGIX(__GLXclientState *cl, GLbyte *pc)
 
     if (client->swapped) {
 	__glXSwapQueryMaxSwapBarriersSGIXReply(client, &reply);
-    } else {
+    }
+    else {
 	WriteToClient(client, sz_xGLXQueryMaxSwapBarriersSGIXReply,
 		      (char *)&reply);
     }
@@ -447,7 +472,8 @@ int __glXQueryMaxSwapBarriersSGIX(__GLXclientState *cl, GLbyte *pc)
     return Success;
 }
 
-int __glXBindSwapBarrierSGIX(__GLXclientState *cl, GLbyte *pc)
+int
+__glXBindSwapBarrierSGIX(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXBindSwapBarrierSGIXReq *req = (xGLXBindSwapBarrierSGIXReq *)pc;
@@ -460,13 +486,15 @@ int __glXBindSwapBarrierSGIX(__GLXclientState *cl, GLbyte *pc)
     if (rc != Success) {
 	dixLookupResourceByType((pointer*) &pGlxPixmap, req->drawable,
 				__glXPixmapRes, NullClient, DixUnknownAccess);
-	if (pGlxPixmap) pDraw = pGlxPixmap->pDraw;
+        if (pGlxPixmap)
+            pDraw = pGlxPixmap->pDraw;
     }
 
     if (!pDraw && __GLX_IS_VERSION_SUPPORTED(1,3) ) {
        dixLookupResourceByType((pointer*) &pGlxWindow, req->drawable,
                                __glXWindowRes, NullClient, DixUnknownAccess);
-       if (pGlxWindow) pDraw = pGlxWindow->pDraw;
+        if (pGlxWindow)
+            pDraw = pGlxWindow->pDraw;
     }
 
     if (!pDraw) {
@@ -477,7 +505,8 @@ int __glXBindSwapBarrierSGIX(__GLXclientState *cl, GLbyte *pc)
     return BindSwapBarrierSGIX(pDraw, req->barrier);
 }
 
-int __glXJoinSwapGroupSGIX(__GLXclientState *cl, GLbyte *pc)
+int
+__glXJoinSwapGroupSGIX(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXJoinSwapGroupSGIXReq *req = (xGLXJoinSwapGroupSGIXReq *)pc;
@@ -490,13 +519,15 @@ int __glXJoinSwapGroupSGIX(__GLXclientState *cl, GLbyte *pc)
     if (rc != Success) {
 	dixLookupResourceByType((pointer*) &pGlxPixmap, req->drawable,
 				__glXPixmapRes, NullClient, DixUnknownAccess);
-	if (pGlxPixmap) pDraw = pGlxPixmap->pDraw;
+        if (pGlxPixmap)
+            pDraw = pGlxPixmap->pDraw;
     }
 
     if (!pDraw && __GLX_IS_VERSION_SUPPORTED(1,3) ) {
        dixLookupResourceByType((pointer*) &pGlxWindow, req->drawable,
                                __glXWindowRes, NullClient, DixUnknownAccess);
-       if (pGlxWindow) pDraw = pGlxWindow->pDraw;
+        if (pGlxWindow)
+            pDraw = pGlxWindow->pDraw;
     }
 
     if (!pDraw) {
@@ -511,14 +542,16 @@ int __glXJoinSwapGroupSGIX(__GLXclientState *cl, GLbyte *pc)
 	    dixLookupResourceByType((pointer*) &pGlxPixmap, req->member,
                                     __glXPixmapRes, NullClient,
                                     DixUnknownAccess);
-	    if (pGlxPixmap) pMember = pGlxPixmap->pDraw;
+            if (pGlxPixmap)
+                pMember = pGlxPixmap->pDraw;
 	}
 
 	if (!pMember && __GLX_IS_VERSION_SUPPORTED(1,3) ) {
 	    dixLookupResourceByType((pointer*) &pGlxWindow, req->member,
                                     __glXWindowRes, NullClient,
                                     DixUnknownAccess);
-	    if (pGlxWindow) pMember = pGlxWindow->pDraw;
+            if (pGlxWindow)
+                pMember = pGlxWindow->pDraw;
 	}
 
 	if (!pMember) {
@@ -530,11 +563,11 @@ int __glXJoinSwapGroupSGIX(__GLXclientState *cl, GLbyte *pc)
     return JoinSwapGroupSGIX(pDraw, pMember);
 }
 
-
 /*
 ** Destroy a GL context as an X resource.
 */
-int __glXDestroyContext(__GLXclientState *cl, GLbyte *pc)
+int
+__glXDestroyContext(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXDestroyContextReq *req = (xGLXDestroyContextReq *) pc;
@@ -558,7 +591,8 @@ int __glXDestroyContext(__GLXclientState *cl, GLbyte *pc)
 
 	from_screen = to_screen = glxc->pScreen->myNum;
 
-    } else {
+    }
+    else {
 	client->errorValue = gcId;
 	return __glXBadContext;
     }
@@ -600,13 +634,15 @@ int __glXDestroyContext(__GLXclientState *cl, GLbyte *pc)
 /*
 ** Add a current context, and return the tag that will be used to refer to it.
 */
-static int AddCurrentContext(__GLXclientState *cl, __GLXcontext *glxc, DrawablePtr pDraw)
+static int
+AddCurrentContext(__GLXclientState * cl, __GLXcontext * glxc, DrawablePtr pDraw)
 {
     int i;
     int num = cl->numCurrentContexts;
     __GLXcontext **table = cl->currentContexts;
 
-    if (!glxc) return -1;
+    if (!glxc)
+        return -1;
     
     /*
     ** Try to find an empty slot and use it.
@@ -623,15 +659,22 @@ static int AddCurrentContext(__GLXclientState *cl, __GLXcontext *glxc, DrawableP
     if (!num) {
 	table = (__GLXcontext **) malloc(sizeof(__GLXcontext *));
 	cl->currentDrawables = (DrawablePtr *) malloc(sizeof(DrawablePtr));
-	cl->be_currentCTag = (GLXContextTag *) malloc(screenInfo.numScreens *sizeof(GLXContextTag));
-    } else {
+        cl->be_currentCTag =
+            (GLXContextTag *) malloc(screenInfo.numScreens *
+                                     sizeof(GLXContextTag));
+    }
+    else {
 	table = (__GLXcontext **) realloc(table,
 					   (num+1)*sizeof(__GLXcontext *));
-	cl->currentDrawables = (DrawablePtr *) realloc(
-	                                          cl->currentDrawables ,
-						  (num+1)*sizeof(DrawablePtr));
-	cl->be_currentCTag = (GLXContextTag *) realloc(cl->be_currentCTag,
-	            (num+1)*screenInfo.numScreens*sizeof(GLXContextTag));
+        cl->currentDrawables = (DrawablePtr *) realloc(cl->currentDrawables,
+                                                       (num +
+                                                        1) *
+                                                       sizeof(DrawablePtr));
+        cl->be_currentCTag =
+            (GLXContextTag *) realloc(cl->be_currentCTag,
+                                      (num +
+                                       1) * screenInfo.numScreens *
+                                      sizeof(GLXContextTag));
     }
     table[num] = glxc;
     cl->currentDrawables[num] = pDraw;
@@ -647,10 +690,12 @@ static int AddCurrentContext(__GLXclientState *cl, __GLXcontext *glxc, DrawableP
 /*
 ** Given a tag, change the current context for the corresponding entry.
 */
-static void ChangeCurrentContext(__GLXclientState *cl, __GLXcontext *glxc,
+static void
+ChangeCurrentContext(__GLXclientState * cl, __GLXcontext * glxc,
 				GLXContextTag tag)
 {
     __GLXcontext **table = cl->currentContexts;
+
     table[tag-1] = glxc;
 }
 
@@ -658,7 +703,8 @@ static void ChangeCurrentContext(__GLXclientState *cl, __GLXcontext *glxc,
 ** Given a tag, and back-end screen number, retrives the current back-end
 ** tag.
 */
-int GetCurrentBackEndTag(__GLXclientState *cl, GLXContextTag tag, int s)
+int
+GetCurrentBackEndTag(__GLXclientState * cl, GLXContextTag tag, int s)
 {
    if (tag >0) {
       return( cl->be_currentCTag[ (tag-1)*screenInfo.numScreens + s ] );
@@ -672,7 +718,9 @@ int GetCurrentBackEndTag(__GLXclientState *cl, GLXContextTag tag, int s)
 ** Given a tag, and back-end screen number, sets the current back-end
 ** tag.
 */
-static void SetCurrentBackEndTag(__GLXclientState *cl, GLXContextTag tag, int s, GLXContextTag be_tag)
+static void
+SetCurrentBackEndTag(__GLXclientState * cl, GLXContextTag tag, int s,
+                     GLXContextTag be_tag)
 {
    if (tag >0) {
       cl->be_currentCTag[ (tag-1)*screenInfo.numScreens + s ] = be_tag;
@@ -684,31 +732,36 @@ static void SetCurrentBackEndTag(__GLXclientState *cl, GLXContextTag tag, int s,
 ** context's entry in the table as the context tag.  A tag must be greater
 ** than 0.
 */
-__GLXcontext *__glXLookupContextByTag(__GLXclientState *cl, GLXContextTag tag)
+__GLXcontext *
+__glXLookupContextByTag(__GLXclientState * cl, GLXContextTag tag)
 {
     int num = cl->numCurrentContexts;
 
     if (tag < 1 || tag > num) {
 	return 0;
-    } else {
+    }
+    else {
 	return cl->currentContexts[tag-1];
     }
 }
 
-DrawablePtr __glXLookupDrawableByTag(__GLXclientState *cl, GLXContextTag tag)
+DrawablePtr
+__glXLookupDrawableByTag(__GLXclientState * cl, GLXContextTag tag)
 {
     int num = cl->numCurrentContexts;
 
     if (tag < 1 || tag > num) {
 	return 0;
-    } else {
+    }
+    else {
 	return cl->currentDrawables[tag-1];
     }
 }
 
 /*****************************************************************************/
 
-static void StopUsingContext(__GLXcontext *glxc)
+static void
+StopUsingContext(__GLXcontext * glxc)
 {
     if (glxc) {
 	if (glxc == __glXLastContext) {
@@ -722,7 +775,8 @@ static void StopUsingContext(__GLXcontext *glxc)
     }
 }
 
-static void StartUsingContext(__GLXclientState *cl, __GLXcontext *glxc)
+static void
+StartUsingContext(__GLXclientState * cl, __GLXcontext * glxc)
 {
     glxc->isCurrent = GL_TRUE;
 }
@@ -731,11 +785,11 @@ static void StartUsingContext(__GLXclientState *cl, __GLXcontext *glxc)
 /*
 ** Make an OpenGL context and drawable current.
 */
-static int MakeCurrent(__GLXclientState *cl,
+static int
+MakeCurrent(__GLXclientState * cl,
                        GLXDrawable drawable,
                        GLXDrawable readdrawable,
-		       GLXContextID context,
-		       GLXContextTag oldContextTag)
+            GLXContextID context, GLXContextTag oldContextTag)
 {
     ClientPtr client = cl->client;
     DrawablePtr pDraw = NULL;
@@ -758,6 +812,7 @@ static int MakeCurrent(__GLXclientState *cl,
     __glXWindow *pGlxReadWindow = NULL;
     __glXPbuffer *pGlxPbuffer = NULL;
     __glXPbuffer *pGlxReadPbuffer = NULL;
+
 #ifdef PANORAMIX
     PanoramiXRes *pXinDraw = NULL;
     PanoramiXRes *pXinReadDraw = NULL;
@@ -785,7 +840,8 @@ static int MakeCurrent(__GLXclientState *cl,
 	    */
 	    return __glXBadContextTag;
 	}
-    } else {
+    }
+    else {
 	prevglxc = 0;
     }
 
@@ -803,7 +859,8 @@ static int MakeCurrent(__GLXclientState *cl,
 	    /* Context is current to somebody else */
 	    return BadAccess;
 	}
-    } else {
+    }
+    else {
 	/* Switching to no context.  Ignore new drawable. */
 	glxc = 0;
     }
@@ -816,10 +873,12 @@ static int MakeCurrent(__GLXclientState *cl,
 		** Drawable is an X Window.
 		*/
 	        VisualID vid;
+
 		pWin = (WindowPtr)pDraw;
 		vid = wVisual(pWin);
 
-		new_reply.writeVid = (glxc->pFBConfig ? glxc->pFBConfig->id : vid);
+                new_reply.writeVid =
+                    (glxc->pFBConfig ? glxc->pFBConfig->id : vid);
 		new_reply.writeType = GLX_WINDOW_TYPE;
 
 		/*
@@ -833,7 +892,8 @@ static int MakeCurrent(__GLXclientState *cl,
 
 		from_screen = to_screen = pWin->drawable.pScreen->myNum;
 
-	    } else {
+            }
+            else {
 		/*
 		** An X Pixmap is not allowed as a parameter (a GLX Pixmap
 		** is, but it must first be created with glxCreateGLXPixmap).
@@ -916,7 +976,8 @@ static int MakeCurrent(__GLXclientState *cl,
 	   return __glXBadDrawable;
 	}
 
-    } else {
+    }
+    else {
 	pDraw = 0;
     }
 
@@ -928,10 +989,12 @@ static int MakeCurrent(__GLXclientState *cl,
 		** Drawable is an X Window.
 		*/
 	        VisualID vid;
+
 		pReadWin = (WindowPtr)pDraw;
 		vid = wVisual(pReadWin);
 
-		new_reply.readVid = (glxc->pFBConfig ? glxc->pFBConfig->id : vid);
+                new_reply.readVid =
+                    (glxc->pFBConfig ? glxc->pFBConfig->id : vid);
 		new_reply.readType = GLX_WINDOW_TYPE;
 
 		/*
@@ -943,7 +1006,8 @@ static int MakeCurrent(__GLXclientState *cl,
 		    return BadMatch;
 		}
 
-	    } else {
+            }
+            else {
 
 		/*
 		** An X Pixmap is not allowed as a parameter (a GLX Pixmap
@@ -1023,7 +1087,8 @@ static int MakeCurrent(__GLXclientState *cl,
 	   return __glXBadDrawable;
 	}
 
-    } else {
+    }
+    else {
 	pReadDraw = pDraw;
 	pReadGlxPixmap = pGlxPixmap;
 	pReadWin = pWin;
@@ -1090,7 +1155,8 @@ static int MakeCurrent(__GLXclientState *cl,
 	ChangeCurrentContext(cl, glxc, tag);
 	ChangeCurrentContext(cl, glxc, tag);
 	StopUsingContext(prevglxc);
-    } else {
+    }
+    else {
 	tag = AddCurrentContext(cl, glxc, pDraw);
     }
     if (glxc) {
@@ -1128,7 +1194,8 @@ static int MakeCurrent(__GLXclientState *cl,
 
 	StartUsingContext(cl, glxc);
 	new_reply.contextTag = tag;
-    } else {
+    }
+    else {
 	new_reply.contextTag = 0;
     }
     new_reply.length = 0;
@@ -1158,7 +1225,6 @@ static int MakeCurrent(__GLXclientState *cl,
     }
 #endif
 
-
     /* send the MakeCurrent request to all required
      * back-end servers.
      */
@@ -1207,7 +1273,8 @@ static int MakeCurrent(__GLXclientState *cl,
 	  be_req->reqType = dmxScreen->glxMajorOpcode;
 	  be_req->glxCode = X_GLXMakeCurrent;
 	  be_req->drawable = be_draw;
-	  be_req->context = (unsigned int)(glxc ? glxc->real_ids[s-from_screen] : 0);
+            be_req->context =
+                (unsigned int) (glxc ? glxc->real_ids[s - from_screen] : 0);
 	  be_req->oldContextTag = GetCurrentBackEndTag(cl, tag, s);
 	  if (!_XReply(dpy, (xReply *) &be_reply, 0, False)) {
 
@@ -1241,13 +1308,15 @@ static int MakeCurrent(__GLXclientState *cl,
 	  }
 
       	  if (pReadWin && be_read_draw == None) {
-  	     be_read_draw = (unsigned int)(DMX_GET_WINDOW_PRIV(pReadWin))->window;
+                be_read_draw =
+                    (unsigned int) (DMX_GET_WINDOW_PRIV(pReadWin))->window;
 	   if (!be_read_draw) {
 	      /* it might be that the window did not created yet on the */
 	      /* back-end server (lazy window creation option), force   */
 	      /* creation of the window */
 	      dmxCreateAndRealizeWindow( pReadWin, TRUE );
-	      be_read_draw = (unsigned int)(DMX_GET_WINDOW_PRIV(pReadWin))->window;
+                    be_read_draw =
+                        (unsigned int) (DMX_GET_WINDOW_PRIV(pReadWin))->window;
               dmxSync( dmxScreen, 1 ); 
 	   }
      	  }
@@ -1259,7 +1328,8 @@ static int MakeCurrent(__GLXclientState *cl,
 	     be_new_req->glxCode = X_GLXMakeContextCurrent;
 	     be_new_req->drawable = be_draw;
 	     be_new_req->readdrawable = be_read_draw;
-	     be_new_req->context = (unsigned int)(glxc ? glxc->real_ids[s-from_screen] : 0);
+                be_new_req->context =
+                    (unsigned int) (glxc ? glxc->real_ids[s - from_screen] : 0);
 	     be_new_req->oldContextTag = GetCurrentBackEndTag(cl, tag, s);
 	     if (!_XReply(dpy, (xReply *) &be_new_reply, 0, False)) {
 
@@ -1281,15 +1351,16 @@ static int MakeCurrent(__GLXclientState *cl,
 
 	     LockDisplay(dpy);
 	     GetReqExtra(GLXVendorPrivateWithReply, 
-		         sz_xGLXMakeCurrentReadSGIReq - sz_xGLXVendorPrivateWithReplyReq,
-		         vpreq);
+                            sz_xGLXMakeCurrentReadSGIReq -
+                            sz_xGLXVendorPrivateWithReplyReq, vpreq);
 	     ext_req = (xGLXMakeCurrentReadSGIReq *)vpreq;
 	     ext_req->reqType = dmxScreen->glxMajorOpcode;
 	     ext_req->glxCode = X_GLXVendorPrivateWithReply;
 	     ext_req->vendorCode = X_GLXvop_MakeCurrentReadSGI;
 	     ext_req->drawable = be_draw;
 	     ext_req->readable = be_read_draw;
-	     ext_req->context = (unsigned int)(glxc ? glxc->real_ids[s-from_screen] : 0);
+                ext_req->context =
+                    (unsigned int) (glxc ? glxc->real_ids[s - from_screen] : 0);
 	     ext_req->oldContextTag = GetCurrentBackEndTag(cl, tag, s);
 	     if (!_XReply(dpy, (xReply *) &ext_reply, 0, False)) {
 
@@ -1315,14 +1386,17 @@ static int MakeCurrent(__GLXclientState *cl,
 
     if (client->swapped) {
 	__glXSwapMakeCurrentReply(client, &new_reply);
-    } else {
-	WriteToClient(client, sz_xGLXMakeContextCurrentReply, (char *)&new_reply);
+    }
+    else {
+        WriteToClient(client, sz_xGLXMakeContextCurrentReply,
+                      (char *) &new_reply);
     }
 
     return Success;
 }
 
-int __glXMakeCurrent(__GLXclientState *cl, GLbyte *pc)
+int
+__glXMakeCurrent(__GLXclientState * cl, GLbyte * pc)
 {
     xGLXMakeCurrentReq *req = (xGLXMakeCurrentReq *) pc;
 
@@ -1330,7 +1404,8 @@ int __glXMakeCurrent(__GLXclientState *cl, GLbyte *pc)
 	                req->context, req->oldContextTag ) );
 }
 
-int __glXMakeContextCurrent(__GLXclientState *cl, GLbyte *pc)
+int
+__glXMakeContextCurrent(__GLXclientState * cl, GLbyte * pc)
 {
     xGLXMakeContextCurrentReq *req = (xGLXMakeContextCurrentReq *) pc;
 
@@ -1338,7 +1413,8 @@ int __glXMakeContextCurrent(__GLXclientState *cl, GLbyte *pc)
 	                req->context, req->oldContextTag ) );
 }
 
-int __glXMakeCurrentReadSGI(__GLXclientState *cl, GLbyte *pc)
+int
+__glXMakeCurrentReadSGI(__GLXclientState * cl, GLbyte * pc)
 {
     xGLXMakeCurrentReadSGIReq *req = (xGLXMakeCurrentReadSGIReq *) pc;
 
@@ -1346,7 +1422,8 @@ int __glXMakeCurrentReadSGI(__GLXclientState *cl, GLbyte *pc)
 	                req->context, req->oldContextTag ) );
 }
 
-int __glXIsDirect(__GLXclientState *cl, GLbyte *pc)
+int
+__glXIsDirect(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXIsDirectReq *req = (xGLXIsDirectReq *) pc;
@@ -1370,16 +1447,19 @@ int __glXIsDirect(__GLXclientState *cl, GLbyte *pc)
 
     if (client->swapped) {
 	__glXSwapIsDirectReply(client, &reply);
-    } else {
+    }
+    else {
 	WriteToClient(client, sz_xGLXIsDirectReply, (char *)&reply);
     }
 
     return Success;
 }
 
-int __glXQueryVersion(__GLXclientState *cl, GLbyte *pc)
+int
+__glXQueryVersion(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
+
 /*    xGLXQueryVersionReq *req = (xGLXQueryVersionReq *) pc; */
     xGLXQueryVersionReply reply;
 
@@ -1396,13 +1476,15 @@ int __glXQueryVersion(__GLXclientState *cl, GLbyte *pc)
 
     if (client->swapped) {
 	__glXSwapQueryVersionReply(client, &reply);
-    } else {
+    }
+    else {
 	WriteToClient(client, sz_xGLXQueryVersionReply, (char *)&reply);
     }
     return Success;
 }
 
-int __glXWaitGL(__GLXclientState *cl, GLbyte *pc)
+int
+__glXWaitGL(__GLXclientState * cl, GLbyte * pc)
 {
     xGLXWaitGLReq *req = (xGLXWaitGLReq *)pc;
     xGLXWaitGLReq *be_req = (xGLXWaitGLReq *)pc;
@@ -1433,7 +1515,8 @@ int __glXWaitGL(__GLXclientState *cl, GLbyte *pc)
        GetReq(GLXWaitGL,be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = X_GLXWaitGL;
-       be_req->contextTag = (glxc ? GetCurrentBackEndTag(cl,req->contextTag,s) : 0);
+        be_req->contextTag =
+            (glxc ? GetCurrentBackEndTag(cl, req->contextTag, s) : 0);
        UnlockDisplay(dpy);
        SyncHandle();
 
@@ -1443,7 +1526,8 @@ int __glXWaitGL(__GLXclientState *cl, GLbyte *pc)
     return Success;
 }
 
-int __glXWaitX(__GLXclientState *cl, GLbyte *pc)
+int
+__glXWaitX(__GLXclientState * cl, GLbyte * pc)
 {
     xGLXWaitXReq *req = (xGLXWaitXReq *)pc;
     xGLXWaitXReq *be_req;
@@ -1476,7 +1560,8 @@ int __glXWaitX(__GLXclientState *cl, GLbyte *pc)
        GetReq(GLXWaitX,be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = X_GLXWaitX;
-       be_req->contextTag = (glxc ? GetCurrentBackEndTag(cl,req->contextTag,s) : 0);
+        be_req->contextTag =
+            (glxc ? GetCurrentBackEndTag(cl, req->contextTag, s) : 0);
        UnlockDisplay(dpy);
        SyncHandle();
 
@@ -1486,7 +1571,8 @@ int __glXWaitX(__GLXclientState *cl, GLbyte *pc)
     return Success;
 }
 
-int __glXCopyContext(__GLXclientState *cl, GLbyte *pc)
+int
+__glXCopyContext(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXCopyContextReq *be_req;
@@ -1567,7 +1653,8 @@ int __glXCopyContext(__GLXclientState *cl, GLbyte *pc)
        be_req->source = (unsigned int)src->real_ids[s-from_screen];
        be_req->dest = (unsigned int)dst->real_ids[s-from_screen];
        be_req->mask = mask;
-       be_req->contextTag = (tag ? GetCurrentBackEndTag(cl,req->contextTag,s) : 0);
+        be_req->contextTag =
+            (tag ? GetCurrentBackEndTag(cl, req->contextTag, s) : 0);
        UnlockDisplay(dpy);
        SyncHandle();
     }
@@ -1575,7 +1662,8 @@ int __glXCopyContext(__GLXclientState *cl, GLbyte *pc)
     return Success;
 }
 
-int __glXGetVisualConfigs(__GLXclientState *cl, GLbyte *pc)
+int
+__glXGetVisualConfigs(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXGetVisualConfigsReq *req = (xGLXGetVisualConfigsReq *) pc;
@@ -1664,7 +1752,8 @@ int __glXGetVisualConfigs(__GLXclientState *cl, GLbyte *pc)
 /*
 ** Create a GLX Pixmap from an X Pixmap.
 */
-static int CreateGLXPixmap(__GLXclientState *cl,
+static int
+CreateGLXPixmap(__GLXclientState * cl,
                     VisualID visual, GLXFBConfigID fbconfigId,
 		    int screenNum, XID pixmapId, XID glxpixmapId )
 {
@@ -1680,6 +1769,7 @@ static int CreateGLXPixmap(__GLXclientState *cl,
     __GLXFBConfig *pFBConfig;
     int i, s, rc;
     int from_screen, to_screen;
+
 #ifdef PANORAMIX
     PanoramiXRes *pXinDraw = NULL;
 #endif
@@ -1753,7 +1843,6 @@ static int CreateGLXPixmap(__GLXclientState *cl,
 	  return BadValue;
        }
 
-
        /* find the FBConfig for that visual (if any) */
        if ( pFBConfig == NULL ) {
 	   pFBConfig = glxLookupFBConfigByVID( visual );
@@ -1831,7 +1920,8 @@ static int CreateGLXPixmap(__GLXclientState *cl,
        dmxSync( dmxScreen, 1 );
 
        if ( pFBConfig && __GLX_IS_VERSION_SUPPORTED(1,3) ) {
-       	  __GLXFBConfig *be_FBConfig = glxLookupBackEndFBConfig( pFBConfig->id, s );
+            __GLXFBConfig *be_FBConfig =
+                glxLookupBackEndFBConfig(pFBConfig->id, s);
 	  
 	  LockDisplay(dpy);
 	  pGlxPixmap->be_xids[s] = XAllocID(dpy);
@@ -1847,15 +1937,16 @@ static int CreateGLXPixmap(__GLXclientState *cl,
 	  SyncHandle();
        }
        else if (pFBConfig && glxIsExtensionSupported("GLX_SGIX_fbconfig")) {
-	  __GLXFBConfig *be_FBConfig = glxLookupBackEndFBConfig( pFBConfig->id, s );
+            __GLXFBConfig *be_FBConfig =
+                glxLookupBackEndFBConfig(pFBConfig->id, s);
 	  xGLXCreateGLXPixmapWithConfigSGIXReq *ext_req;
 	  xGLXVendorPrivateReq *vpreq;
 	  
 	  LockDisplay(dpy);
 	  pGlxPixmap->be_xids[s] = XAllocID(dpy);
 	  GetReqExtra(GLXVendorPrivate,
-		      sz_xGLXCreateGLXPixmapWithConfigSGIXReq-sz_xGLXVendorPrivateReq,
-		      vpreq);
+                        sz_xGLXCreateGLXPixmapWithConfigSGIXReq -
+                        sz_xGLXVendorPrivateReq, vpreq);
 	  ext_req = (xGLXCreateGLXPixmapWithConfigSGIXReq *)vpreq;
 	  ext_req->reqType = dmxScreen->glxMajorOpcode;
 	  ext_req->glxCode = X_GLXVendorPrivate;
@@ -1874,10 +1965,12 @@ static int CreateGLXPixmap(__GLXclientState *cl,
 	  be_req->reqType = dmxScreen->glxMajorOpcode;
 	  be_req->glxCode = X_GLXCreateGLXPixmap;
 	  be_req->screen = DefaultScreen(dpy);
-	  be_req->visual = (unsigned int)glxMatchGLXVisualInConfigList( 
-	 	pGlxVisual,
-		dmxScreen->glxVisuals,
-		dmxScreen->numGlxVisuals );
+            be_req->visual =
+                (unsigned int) glxMatchGLXVisualInConfigList(pGlxVisual,
+                                                             dmxScreen->
+                                                             glxVisuals,
+                                                             dmxScreen->
+                                                             numGlxVisuals);
    	  be_req->pixmap = (unsigned int)be_pixmap;
       	  be_req->glxpixmap = (unsigned int)pGlxPixmap->be_xids[s];
 	  UnlockDisplay(dpy);
@@ -1900,7 +1993,8 @@ static int CreateGLXPixmap(__GLXclientState *cl,
     return Success;
 }
 
-int __glXCreateGLXPixmap(__GLXclientState *cl, GLbyte *pc)
+int
+__glXCreateGLXPixmap(__GLXclientState * cl, GLbyte * pc)
 {
     xGLXCreateGLXPixmapReq *req = (xGLXCreateGLXPixmapReq *) pc;
 
@@ -1908,7 +2002,8 @@ int __glXCreateGLXPixmap(__GLXclientState *cl, GLbyte *pc)
 	                    req->screen, req->pixmap, req->glxpixmap) );
 }
 
-int __glXCreatePixmap(__GLXclientState *cl, GLbyte *pc)
+int
+__glXCreatePixmap(__GLXclientState * cl, GLbyte * pc)
 {
     xGLXCreatePixmapReq *req = (xGLXCreatePixmapReq *) pc;
 
@@ -1916,7 +2011,8 @@ int __glXCreatePixmap(__GLXclientState *cl, GLbyte *pc)
 	                    req->screen, req->pixmap, req->glxpixmap) );
 }
 
-int __glXDestroyGLXPixmap(__GLXclientState *cl, GLbyte *pc)
+int
+__glXDestroyGLXPixmap(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXDestroyGLXPixmapReq *req = (xGLXDestroyGLXPixmapReq *) pc;
@@ -1963,7 +2059,6 @@ int __glXDestroyGLXPixmap(__GLXclientState *cl, GLbyte *pc)
        SyncHandle();
     }
 
-    
     return Success;
 }
 
@@ -1974,7 +2069,8 @@ int __glXDestroyGLXPixmap(__GLXclientState *cl, GLbyte *pc)
 ** this time that is of value.  Consequently, this code must be
 ** implemented by somebody other than SGI.
 */
-int __glXDoSwapBuffers(__GLXclientState *cl, XID drawId, GLXContextTag tag)
+int
+__glXDoSwapBuffers(__GLXclientState * cl, XID drawId, GLXContextTag tag)
 {
     ClientPtr client = cl->client;
     DrawablePtr pDraw;
@@ -1982,6 +2078,7 @@ int __glXDoSwapBuffers(__GLXclientState *cl, XID drawId, GLXContextTag tag)
     WindowPtr pWin = NULL;
     __GLXpixmap *pGlxPixmap = NULL;
     __GLXcontext *glxc = NULL;
+
 #ifdef PANORAMIX
     PanoramiXRes *pXinDraw = NULL;
 #endif
@@ -2002,7 +2099,8 @@ int __glXDoSwapBuffers(__GLXclientState *cl, XID drawId, GLXContextTag tag)
 	    ** Drawable is an X window.
 	    */
 	   pWin = (WindowPtr)pDraw;
-	} else {
+        }
+        else {
 	    /*
 	    ** Drawable is an X pixmap, which is not allowed.
 	    */
@@ -2074,7 +2172,8 @@ int __glXDoSwapBuffers(__GLXclientState *cl, XID drawId, GLXContextTag tag)
 	    GetReq(GLXSingle,finishReq);
 	    finishReq->reqType = dmxScreen->glxMajorOpcode;
 	    finishReq->glxCode = X_GLsop_Finish;
-	    finishReq->contextTag = (tag ? GetCurrentBackEndTag(cl,tag,s) : 0);
+            finishReq->contextTag =
+                (tag ? GetCurrentBackEndTag(cl, tag, s) : 0);
 	    (void) _XReply(dpy, (xReply*) &reply, 0, False);
 	    UnlockDisplay(dpy);
 	    SyncHandle();
@@ -2087,7 +2186,6 @@ int __glXDoSwapBuffers(__GLXclientState *cl, XID drawId, GLXContextTag tag)
 	    XSync(GetBackEndDisplay(cl,s), False);
     }
 
-
     /* send the SwapBuffers request to all back-end servers */
 
     for (s=from_screen; s<=to_screen; s++) {
@@ -2134,7 +2232,8 @@ int __glXDoSwapBuffers(__GLXclientState *cl, XID drawId, GLXContextTag tag)
     return Success;
 }
 
-int __glXSwapBuffers(__GLXclientState *cl, GLbyte *pc)
+int
+__glXSwapBuffers(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     DrawablePtr pDraw;
@@ -2206,7 +2305,6 @@ int __glXSwapBuffers(__GLXclientState *cl, GLbyte *pc)
     return __glXDoSwapBuffers(cl, drawId, tag);
 }
 
-
 /************************************************************************/
 
 /*
@@ -2217,7 +2315,8 @@ int __glXSwapBuffers(__GLXclientState *cl, GLbyte *pc)
 /*
 ** Execute all the drawing commands in a request.
 */
-int __glXRender(__GLXclientState *cl, GLbyte *pc)
+int
+__glXRender(__GLXclientState * cl, GLbyte * pc)
 {
     xGLXRenderReq *req;
     xGLXRenderReq *be_req;
@@ -2275,7 +2374,8 @@ int __glXRender(__GLXclientState *cl, GLbyte *pc)
 /*
 ** Execute a large rendering request (one that spans multiple X requests).
 */
-int __glXRenderLarge(__GLXclientState *cl, GLbyte *pc)
+int
+__glXRenderLarge(__GLXclientState * cl, GLbyte * pc)
 {
     xGLXRenderLargeReq *req;
     xGLXRenderLargeReq *be_req;
@@ -2330,10 +2430,10 @@ int __glXRenderLarge(__GLXclientState *cl, GLbyte *pc)
     return Success;
 }
 
-
 /************************************************************************/
 
-int __glXVendorPrivate(__GLXclientState *cl, GLbyte *pc)
+int
+__glXVendorPrivate(__GLXclientState * cl, GLbyte * pc)
 {
     xGLXVendorPrivateReq *req;
 
@@ -2392,7 +2492,8 @@ int __glXVendorPrivate(__GLXclientState *cl, GLbyte *pc)
 
 }
 
-int __glXVendorPrivateWithReply(__GLXclientState *cl, GLbyte *pc)
+int
+__glXVendorPrivateWithReply(__GLXclientState * cl, GLbyte * pc)
 {
     xGLXVendorPrivateWithReplyReq *req;
 
@@ -2418,7 +2519,6 @@ int __glXVendorPrivateWithReply(__GLXclientState *cl, GLbyte *pc)
 	  return( __glXVForwardAllWithReply(cl, pc) );
 	  break;
 
-
 #if 0 /* glx1.3 */
        case X_GLvop_GetDetailTexFuncSGIS:
        case X_GLvop_GetSharpenTexFuncSGIS:
@@ -2463,7 +2563,8 @@ int __glXVendorPrivateWithReply(__GLXclientState *cl, GLbyte *pc)
 
 }
 
-int __glXQueryExtensionsString(__GLXclientState *cl, GLbyte *pc)
+int
+__glXQueryExtensionsString(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXQueryExtensionsStringReq *req = (xGLXQueryExtensionsStringReq *) pc;
@@ -2509,9 +2610,11 @@ int __glXQueryExtensionsString(__GLXclientState *cl, GLbyte *pc)
     if (!be_buf) {
         /* Throw data on the floor */
         _XEatData(dpy, len);
-    } else {
+    }
+    else {
         _XRead(dpy, (char *)be_buf, numbytes);
-        if (slop) _XEatData(dpy,4-slop);
+        if (slop)
+            _XEatData(dpy, 4 - slop);
     }
     UnlockDisplay(dpy);
     SyncHandle();
@@ -2532,15 +2635,18 @@ int __glXQueryExtensionsString(__GLXclientState *cl, GLbyte *pc)
 
     if (client->swapped) {
         glxSwapQueryExtensionsStringReply(client, &reply, be_buf);
-    } else {
-        WriteToClient(client, sz_xGLXQueryExtensionsStringReply,(char *)&reply);
+    }
+    else {
+        WriteToClient(client, sz_xGLXQueryExtensionsStringReply,
+                      (char *) &reply);
         WriteToClient(client, (int)(length << 2), (char *)be_buf);
     }
 
     return Success;
 }
 
-int __glXQueryServerString(__GLXclientState *cl, GLbyte *pc)
+int
+__glXQueryServerString(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXQueryServerStringReq *req = (xGLXQueryServerStringReq *) pc;
@@ -2550,6 +2656,7 @@ int __glXQueryServerString(__GLXclientState *cl, GLbyte *pc)
     size_t length;
     int len, numbytes;
     char *be_buf;
+
 #ifdef FWD_QUERY_REQ
     xGLXQueryServerStringReq *be_req;
     xGLXQueryServerStringReply be_reply;
@@ -2587,9 +2694,11 @@ int __glXQueryServerString(__GLXclientState *cl, GLbyte *pc)
     if (!be_buf) {
         /* Throw data on the floor */
         _XEatData(dpy, len);
-    } else {
+    }
+    else {
         _XRead(dpy, (char *)be_buf, numbytes);
-        if (slop) _XEatData(dpy,4-slop);
+        if (slop)
+            _XEatData(dpy, 4 - slop);
     }
     UnlockDisplay(dpy);
     SyncHandle();
@@ -2608,7 +2717,8 @@ int __glXQueryServerString(__GLXclientState *cl, GLbyte *pc)
 
     if (client->swapped) {
         glxSwapQueryServerStringReply(client, &reply, be_buf);
-    } else {
+    }
+    else {
         WriteToClient(client, sz_xGLXQueryServerStringReply, (char *)&reply);
         WriteToClient(client, (int)(length << 2), be_buf);
     }
@@ -2616,7 +2726,8 @@ int __glXQueryServerString(__GLXclientState *cl, GLbyte *pc)
     return Success;
 }
 
-int __glXClientInfo(__GLXclientState *cl, GLbyte *pc)
+int
+__glXClientInfo(__GLXclientState * cl, GLbyte * pc)
 {
     xGLXClientInfoReq *req = (xGLXClientInfoReq *) pc;
     xGLXClientInfoReq *be_req;
@@ -2633,8 +2744,7 @@ int __glXClientInfo(__GLXclientState *cl, GLbyte *pc)
 
     to_screen = screenInfo.numScreens - 1;
 
-    for (s=from_screen; s<=to_screen; s++)
-    {
+    for (s = from_screen; s <= to_screen; s++) {
        DMXScreenInfo *dmxScreen = &dmxScreens[s];
        Display *dpy = GetBackEndDisplay(cl,s);
 
@@ -2655,7 +2765,8 @@ int __glXClientInfo(__GLXclientState *cl, GLbyte *pc)
     return Success;
 }
 
-int __glXUseXFont(__GLXclientState *cl, GLbyte *pc)
+int
+__glXUseXFont(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXUseXFontReq *req;
@@ -2686,9 +2797,9 @@ int __glXUseXFont(__GLXclientState *cl, GLbyte *pc)
                             NullClient, DixUnknownAccess);
     if (!pFont) {
         GC *pGC;
+
         dixLookupResourceByType((pointer*) &pGC, req->font,
-				RT_GC, NullClient,
-				DixUnknownAccess);
+                                RT_GC, NullClient, DixUnknownAccess);
         if (!pGC) {
 	    client->errorValue = req->font;
             return BadFont;
@@ -2705,7 +2816,6 @@ int __glXUseXFont(__GLXclientState *cl, GLbyte *pc)
     }
 #endif
 
-
     for (s=from_screen; s<=to_screen; s++) {
        dmxScreen = &dmxScreens[s];
        dpy = GetBackEndDisplay(cl,s);
@@ -2716,7 +2826,8 @@ int __glXUseXFont(__GLXclientState *cl, GLbyte *pc)
        GetReq(GLXUseXFont,be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = X_GLXUseXFont;
-       be_req->contextTag = (glxc ? GetCurrentBackEndTag(cl,req->contextTag,s) : 0);
+        be_req->contextTag =
+            (glxc ? GetCurrentBackEndTag(cl, req->contextTag, s) : 0);
        be_req->font = pFontPriv->font[s]->fid;
        be_req->first = req->first;
        be_req->count = req->count;
@@ -2734,7 +2845,8 @@ int __glXUseXFont(__GLXclientState *cl, GLbyte *pc)
  * start GLX 1.3 here
  */
 
-int __glXGetFBConfigs(__GLXclientState *cl, GLbyte *pc)
+int
+__glXGetFBConfigs(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXGetFBConfigsReq *req = (xGLXGetFBConfigsReq *) pc;
@@ -2773,6 +2885,7 @@ int __glXGetFBConfigs(__GLXclientState *cl, GLbyte *pc)
     for (i=0; i < numFBConfigs; i++) {
        int associatedVisualId = 0;
        int drawableTypeIndex;
+
        pFBConfig = __glXFBConfigs[ i * (screenInfo.numScreens+1) ];
 
 	p = 0;
@@ -2844,12 +2957,15 @@ int __glXGetFBConfigs(__GLXclientState *cl, GLbyte *pc)
 	 */
 	if (pFBConfig->associatedVisualId == (unsigned int)-1) {
 	   DMXScreenInfo *dmxScreen = &dmxScreens[screen];
-	   __GLXFBConfig *be_pFBConfig = __glXFBConfigs[ i * (screenInfo.numScreens+1)+screen+1 ];
+            __GLXFBConfig *be_pFBConfig =
+                __glXFBConfigs[i * (screenInfo.numScreens + 1) + screen + 1];
 	   __GLXvisualConfig *pGlxVisual = NULL;
 	   int v;
 	   int found = 0;
+
 	   for (v=0; v<dmxScreen->numGlxVisuals; v++) {
-	      if (dmxScreen->glxVisuals[v].vid == be_pFBConfig->associatedVisualId) {
+                if (dmxScreen->glxVisuals[v].vid ==
+                    be_pFBConfig->associatedVisualId) {
 		 pGlxVisual = &dmxScreen->glxVisuals[v];
 		 break;
 	      }
@@ -2910,7 +3026,8 @@ int __glXGetFBConfigs(__GLXclientState *cl, GLbyte *pc)
     return Success;
 }
 
-int __glXGetFBConfigsSGIX(__GLXclientState *cl, GLbyte *pc)
+int
+__glXGetFBConfigsSGIX(__GLXclientState * cl, GLbyte * pc)
 {
    xGLXGetFBConfigsSGIXReq *req = (xGLXGetFBConfigsSGIXReq *)pc;
    xGLXGetFBConfigsReq new_req;
@@ -2923,8 +3040,8 @@ int __glXGetFBConfigsSGIX(__GLXclientState *cl, GLbyte *pc)
    return( __glXGetFBConfigs( cl, (GLbyte *)&new_req ) );
 }
 
-
-int __glXCreateWindow(__GLXclientState *cl, GLbyte *pc)
+int
+__glXCreateWindow(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXCreateWindowReq *req = (xGLXCreateWindowReq *) pc;
@@ -2995,7 +3112,8 @@ int __glXCreateWindow(__GLXclientState *cl, GLbyte *pc)
         if (pVisual->nplanes != pDraw->depth) {
 	    return BadMatch;
 	}
-    } else
+    }
+    else
 	/*
 	** The window was created with no visual that corresponds
 	** to fbconfig 
@@ -3034,7 +3152,8 @@ int __glXCreateWindow(__GLXclientState *cl, GLbyte *pc)
     return Success;
 }
 
-int __glXDestroyWindow(__GLXclientState *cl, GLbyte *pc)
+int
+__glXDestroyWindow(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXDestroyWindowReq *req = (xGLXDestroyWindowReq *) pc;
@@ -3059,7 +3178,8 @@ int __glXDestroyWindow(__GLXclientState *cl, GLbyte *pc)
     return Success;
 }
 
-int __glXQueryContext(__GLXclientState *cl, GLbyte *pc)
+int
+__glXQueryContext(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     __GLXcontext *ctx;
@@ -3096,7 +3216,8 @@ int __glXQueryContext(__GLXclientState *cl, GLbyte *pc)
 
     if (client->swapped) {
         __glXSwapQueryContextReply(client, &reply, sendBuf);
-    } else {
+    }
+    else {
         WriteToClient(client, sz_xGLXQueryContextReply, (char *)&reply);
         WriteToClient(client, nReplyBytes, (char *)sendBuf);
     }
@@ -3105,7 +3226,8 @@ int __glXQueryContext(__GLXclientState *cl, GLbyte *pc)
     return Success;
 }
 
-int __glXQueryContextInfoEXT(__GLXclientState *cl, GLbyte *pc)
+int
+__glXQueryContextInfoEXT(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     __GLXcontext *ctx;
@@ -3146,7 +3268,8 @@ int __glXQueryContextInfoEXT(__GLXclientState *cl, GLbyte *pc)
 
     if (client->swapped) {
         __glXSwapQueryContextInfoEXTReply(client, &reply, sendBuf);
-    } else {
+    }
+    else {
         WriteToClient(client, sz_xGLXQueryContextInfoEXTReply, (char *)&reply);
         WriteToClient(client, nReplyBytes, (char *)sendBuf);
     }
@@ -3155,7 +3278,8 @@ int __glXQueryContextInfoEXT(__GLXclientState *cl, GLbyte *pc)
     return Success;
 }
 
-int __glXCreatePbuffer(__GLXclientState *cl, GLbyte *pc)
+int
+__glXCreatePbuffer(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXCreatePbufferReq *req = (xGLXCreatePbufferReq *)pc;
@@ -3227,7 +3351,8 @@ int __glXCreatePbuffer(__GLXclientState *cl, GLbyte *pc)
        attr = (int *)( req+1 );
 
        LockDisplay(dpy);
-       GetReqExtra(GLXCreatePbuffer, 2 * numAttribs * __GLX_SIZE_CARD32, be_req);
+        GetReqExtra(GLXCreatePbuffer, 2 * numAttribs * __GLX_SIZE_CARD32,
+                    be_req);
        be_req->reqType = dmxScreen->glxMajorOpcode;
        be_req->glxCode = X_GLXCreatePbuffer;
        be_req->screen = be_pGlxFBConfig->screen;
@@ -3251,7 +3376,6 @@ int __glXCreatePbuffer(__GLXclientState *cl, GLbyte *pc)
        pGlxPbuffer->be_xids[s] = be_xid;
     }
 
-
     pGlxPbuffer->idExists = True;
     pGlxPbuffer->refcnt = 0;
     pGlxPbuffer->pFBConfig = pGlxFBConfig;
@@ -3268,7 +3392,8 @@ int __glXCreatePbuffer(__GLXclientState *cl, GLbyte *pc)
 
 }
 
-int __glXDestroyPbuffer(__GLXclientState *cl, GLbyte *pc)
+int
+__glXDestroyPbuffer(__GLXclientState * cl, GLbyte * pc)
 {
     ClientPtr client = cl->client;
     xGLXDestroyPbufferReq *req = (xGLXDestroyPbufferReq *) pc;
@@ -3320,7 +3445,8 @@ int __glXDestroyPbuffer(__GLXclientState *cl, GLbyte *pc)
     return Success;
 }
 
-int __glXGetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
+int
+__glXGetDrawableAttributes(__GLXclientState * cl, GLbyte * pc)
 {
    xGLXGetDrawableAttributesReq *req = (xGLXGetDrawableAttributesReq *)pc;
    xGLXGetDrawableAttributesReq *be_req;
@@ -3334,6 +3460,7 @@ int __glXGetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
    DMXScreenInfo *dmxScreen;
    CARD32 *attribs = NULL;
    int attribs_size = 0;
+
 #ifdef PANORAMIX
     PanoramiXRes *pXinDraw = NULL;
 #endif
@@ -3342,9 +3469,11 @@ int __glXGetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
       rc = dixLookupDrawable(&pDraw, drawId, client, 0, DixGetAttrAccess);
       if (rc == Success && pDraw->type == DRAWABLE_WINDOW) {
 	 WindowPtr pWin = (WindowPtr)pDraw;
+
 	 be_drawable = 0;
 	 screen = pWin->drawable.pScreen->myNum;
-      } else {
+        }
+        else {
 	 /*
 	  ** Drawable is not a Window , GLXWindow or a GLXPixmap.
 	  */
@@ -3354,6 +3483,7 @@ int __glXGetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
 
       if (!pDraw) {
 	 __GLXpixmap *pGlxPixmap;
+
 	 dixLookupResourceByType((pointer*) &pGlxPixmap,
 				 drawId, __glXPixmapRes,
 				 NullClient, DixUnknownAccess);
@@ -3366,6 +3496,7 @@ int __glXGetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
 
       if (!pDraw) {
 	 __glXWindow *pGlxWindow;
+
 	 dixLookupResourceByType((pointer*) &pGlxWindow,
 				 drawId, __glXWindowRes,
 				 NullClient, DixUnknownAccess);
@@ -3378,6 +3509,7 @@ int __glXGetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
 
       if (!pDraw) {
 	 __glXPbuffer *pGlxPbuffer;
+
 	 dixLookupResourceByType((pointer*) &pGlxPbuffer,
 				 drawId, __glXPbufferRes,
 				 NullClient, DixUnknownAccess);
@@ -3424,7 +3556,8 @@ int __glXGetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
 	      /* back-end server (lazy window creation option), force   */
 	      /* creation of the window */
 	      dmxCreateAndRealizeWindow( pWin, TRUE );
-	      be_drawable = (unsigned int)(DMX_GET_WINDOW_PRIV(pWin))->window;
+                be_drawable =
+                    (unsigned int) (DMX_GET_WINDOW_PRIV(pWin))->window;
 	   }
        }
        else {
@@ -3433,7 +3566,6 @@ int __glXGetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
        }
    }
 
-
    /* send the request to the back-end server */
    dpy = GetBackEndDisplay(cl,screen);
    dmxScreen = &dmxScreens[screen];
@@ -3468,14 +3600,14 @@ int __glXGetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
    UnlockDisplay(dpy);
    SyncHandle();
 
-
    /* send the reply back to the client */
    reply.sequenceNumber = client->sequence;
    if (client->swapped) {
       __glXSwapGetDrawableAttributesReply(client, &reply, (int *)attribs);
    }
    else {
-      WriteToClient(client, sz_xGLXGetDrawableAttributesReply, (char *)&reply);
+        WriteToClient(client, sz_xGLXGetDrawableAttributesReply,
+                      (char *) &reply);
       WriteToClient(client, attribs_size, (char *)attribs);
    }
 
@@ -3484,9 +3616,11 @@ int __glXGetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
    return Success;
 }
 
-int __glXChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
+int
+__glXChangeDrawableAttributes(__GLXclientState * cl, GLbyte * pc)
 {
-   xGLXChangeDrawableAttributesReq *req = (xGLXChangeDrawableAttributesReq *)pc;
+    xGLXChangeDrawableAttributesReq *req =
+        (xGLXChangeDrawableAttributesReq *) pc;
    xGLXChangeDrawableAttributesReq *be_req;
    ClientPtr client = cl->client;
    GLXDrawable drawId = req->drawable;
@@ -3501,7 +3635,8 @@ int __glXChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
       if (rc == Success && pDraw->type == DRAWABLE_WINDOW) {
 	  be_drawable = 0;
 	  screen = pDraw->pScreen->myNum;
-      } else {
+        }
+        else {
 	 /*
 	  ** Drawable is not a Window , GLXWindow or a GLXPixmap.
 	  */
@@ -3511,6 +3646,7 @@ int __glXChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
 
       if (!pDraw) {
 	 __GLXpixmap *pGlxPixmap;
+
 	 dixLookupResourceByType((pointer*) &pGlxPixmap,
 				 drawId, __glXPixmapRes,
 				 NullClient, DixUnknownAccess);
@@ -3523,6 +3659,7 @@ int __glXChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
 
       if (!pDraw) {
 	 __glXWindow *pGlxWindow;
+
 	 dixLookupResourceByType((pointer*) &pGlxWindow,
 				 drawId, __glXWindowRes,
 				 NullClient, DixUnknownAccess);
@@ -3535,6 +3672,7 @@ int __glXChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
 
       if (!pDraw) {
 	 __glXPbuffer *pGlxPbuffer;
+
 	 dixLookupResourceByType((pointer*) &pGlxPbuffer,
 				 drawId, __glXPbufferRes,
 				 NullClient, DixUnknownAccess);
@@ -3563,6 +3701,7 @@ int __glXChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
 #ifdef PANORAMIX
        if (!noPanoramiXExtension) {
 	  PanoramiXRes *pXinDraw;
+
 	  if (Success != dixLookupResourceByClass((pointer*) &pXinDraw,
 						  pDraw->id, XRC_DRAWABLE,
 						  client, DixReadAccess)) {
@@ -3582,7 +3721,8 @@ int __glXChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
 	      /* back-end server (lazy window creation option), force   */
 	      /* creation of the window */
 	      dmxCreateAndRealizeWindow( pWin, TRUE );
-	      be_drawable = (unsigned int)(DMX_GET_WINDOW_PRIV(pWin))->window;
+                be_drawable =
+                    (unsigned int) (DMX_GET_WINDOW_PRIV(pWin))->window;
 	   }
        }
        else {
@@ -3591,7 +3731,6 @@ int __glXChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
        }
    }
 
-
    /* send the request to the back-end server */
    dpy = GetBackEndDisplay(cl,screen);
    dmxScreen = &dmxScreens[screen];
@@ -3614,7 +3753,8 @@ int __glXChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)
    return Success;
 }
 
-int __glXSendLargeCommand(__GLXclientState *cl, GLXContextTag contextTag)
+int
+__glXSendLargeCommand(__GLXclientState * cl, GLXContextTag contextTag)
 {
    ClientPtr client = cl->client;
     xGLXRenderLargeReq *req;
@@ -3629,7 +3769,8 @@ int __glXSendLargeCommand(__GLXclientState *cl, GLXContextTag contextTag)
     maxSize = cl->largeCmdMaxReqDataSize - (GLint)sizeof(xGLXRenderLargeReq);
     dataLen = cl->largeCmdBytesTotal;
     totalRequests = (dataLen / maxSize);
-    if (dataLen % maxSize) totalRequests++;
+    if (dataLen % maxSize)
+        totalRequests++;
 
     glxc = __glXLookupContextByTag(cl, contextTag);
     if (!glxc) {
