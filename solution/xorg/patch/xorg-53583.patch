diff --git a/hw/xfree86/vgahw/vgaHW.c b/hw/xfree86/vgahw/vgaHW.c
index ee045d1..2ecea1c 100644
--- a/hw/xfree86/vgahw/vgaHW.c
+++ b/hw/xfree86/vgahw/vgaHW.c
@@ -1992,3 +1992,93 @@ SaveScreenProcPtr vgaHWSaveScreenWeak(void)
 {
     return vgaHWSaveScreen;
 }
+
+/*
+ * xf86GetClocks -- get the dot-clocks via a BIG BAD hack ...
+ */
+void
+xf86GetClocks(ScrnInfoPtr pScrn, int num, Bool (*ClockFunc)(ScrnInfoPtr, int),
+	      void (*ProtectRegs)(ScrnInfoPtr, Bool),
+	      void (*BlankScreen)(ScrnInfoPtr, Bool), IOADDRESS vertsyncreg,
+	      int maskval, int knownclkindex, int knownclkvalue)
+{
+    register int status = vertsyncreg;
+    unsigned long i, cnt, rcnt, sync;
+
+    /* First save registers that get written on */
+    (*ClockFunc)(pScrn, CLK_REG_SAVE);
+
+    if (num > MAXCLOCKS)
+	num = MAXCLOCKS;
+
+    for (i = 0; i < num; i++)
+    {
+	if (ProtectRegs)
+	    (*ProtectRegs)(pScrn, TRUE);
+	if (!(*ClockFunc)(pScrn, i))
+	{
+	    pScrn->clock[i] = -1;
+	    continue;
+	}
+	if (ProtectRegs)
+	    (*ProtectRegs)(pScrn, FALSE);
+	if (BlankScreen)
+	    (*BlankScreen)(pScrn, FALSE);
+
+	usleep(50000);     /* let VCO stabilise */
+
+	cnt  = 0;
+	sync = 200000;
+
+	while ((inb(status) & maskval) == 0x00)
+	    if (sync-- == 0) goto finish;
+	/* Something appears to be happening, so reset sync count */
+	sync = 200000;
+	while ((inb(status) & maskval) == maskval)
+	    if (sync-- == 0) goto finish;
+	/* Something appears to be happening, so reset sync count */
+	sync = 200000;
+	while ((inb(status) & maskval) == 0x00)
+	    if (sync-- == 0) goto finish;
+
+	for (rcnt = 0; rcnt < 5; rcnt++)
+	{
+	    while (!(inb(status) & maskval))
+		cnt++;
+	    while ((inb(status) & maskval))
+		cnt++;
+	}
+
+finish:
+	pScrn->clock[i] = cnt ? cnt : -1;
+	if (BlankScreen)
+            (*BlankScreen)(pScrn, TRUE);
+    }
+
+    for (i = 0; i < num; i++)
+    {
+	if (i != knownclkindex)
+	{
+	    if (pScrn->clock[i] == -1)
+	    {
+		pScrn->clock[i] = 0;
+	    }
+	    else
+	    {
+		pScrn->clock[i] = (int)(0.5 +
+                    (((float)knownclkvalue) * pScrn->clock[knownclkindex]) /
+	            (pScrn->clock[i]));
+		/* Round to nearest 10KHz */
+		pScrn->clock[i] += 5;
+		pScrn->clock[i] /= 10;
+		pScrn->clock[i] *= 10;
+	    }
+	}
+    }
+
+    pScrn->clock[knownclkindex] = knownclkvalue;
+    pScrn->numClocks = num;
+
+    /* Restore registers that were written on */
+    (*ClockFunc)(pScrn, CLK_REG_RESTORE);
+}
