diff --git a/hw/xquartz/quartzKeyboard.c b/hw/xquartz/quartzKeyboard.c
index 264f6f8..cee582b 100644
--- a/hw/xquartz/quartzKeyboard.c
+++ b/hw/xquartz/quartzKeyboard.c
@@ -5,9 +5,6 @@
    Copyright (c) 2001-2004 Torrey T. Lyons. All Rights Reserved.
    Copyright 2004 Kaleb S. KEITHLEY. All Rights Reserved.
 
-   The code to parse the Darwin keymap is derived from dumpkeymap.c
-   by Eric Sunshine, which includes the following copyright:
-
    Copyright (C) 1999,2000 by Eric Sunshine <sunshine@sunshineco.com>
    All rights reserved.
 
@@ -40,9 +37,6 @@
 #include <dix-config.h>
 #endif
 
-// Define this to get a diagnostic output to stderr which is helpful
-// in determining how the X server is interpreting the Darwin keymap.
-#define DUMP_DARWIN_KEYMAP
 //#define XQUARTZ_USE_XKB 
 #define HACK_MISSING 1
 #define HACK_KEYPAD 1
@@ -310,8 +304,6 @@ const static struct {
 };
 
 darwinKeyboardInfo keyInfo;
-static FILE *fref = NULL;
-static char *inBuffer = NULL;
 
 static void DarwinChangeKeyboardControl( DeviceIntPtr device, KeybdCtrl *ctrl )
 {
@@ -320,411 +312,10 @@ static void DarwinChangeKeyboardControl( DeviceIntPtr device, KeybdCtrl *ctrl )
 }
 
 //-----------------------------------------------------------------------------
-// Data Stream Object
-//      Can be configured to treat embedded "numbers" as being composed of
-//      either 1, 2, or 4 bytes, apiece.
-//-----------------------------------------------------------------------------
-typedef struct _DataStream {
-    unsigned char const *data;
-    unsigned char const *data_end;
-    short number_size;  // Size in bytes of a "number" in the stream.
-} DataStream;
-
-static DataStream* new_data_stream(unsigned char const* data, int size) {
-    DataStream* s = (DataStream*)xalloc( sizeof(DataStream) );
-    if(s) {
-        s->data = data;
-        s->data_end = data + size;
-        s->number_size = 1; // Default to byte-sized numbers.
-    }
-    return s;
-}
-
-static void destroy_data_stream(DataStream* s) {
-    xfree(s);
-}
-
-static unsigned char get_byte(DataStream* s) {
-    assert(s->data + 1 <= s->data_end);
-    return *s->data++;
-}
-
-static short get_word(DataStream* s) {
-    short hi, lo;
-    assert(s->data + 2 <= s->data_end);
-    hi = *s->data++;
-    lo = *s->data++;
-    return ((hi << 8) | lo);
-}
-
-static int get_dword(DataStream* s) {
-    int b1, b2, b3, b4;
-    assert(s->data + 4 <= s->data_end);
-    b4 = *s->data++;
-    b3 = *s->data++;
-    b2 = *s->data++;
-    b1 = *s->data++;
-    return ((b4 << 24) | (b3 << 16) | (b2 << 8) | b1);
-}
-
-static int get_number(DataStream* s) {
-    switch (s->number_size) {
-        case 4:  return get_dword(s);
-        case 2:  return get_word(s);
-        default: return get_byte(s);
-    }
-}
-
-//-----------------------------------------------------------------------------
 // Utility functions to help parse Darwin keymap
 //-----------------------------------------------------------------------------
 
 /*
- * bits_set
- *      Calculate number of bits set in the modifier mask.
- */
-static short bits_set(short mask) {
-    short n = 0;
-
-    for ( ; mask != 0; mask >>= 1)
-        if ((mask & 0x01) != 0)
-            n++;
-    return n;
-}
-
-/*
- * parse_next_char_code
- *      Read the next character code from the Darwin keymapping
- *      and write it to the X keymap.
- */
-static void parse_next_char_code(DataStream *s, KeySym *k) {
-    const short charSet = get_number(s);
-    const short charCode = get_number(s);
-
-    if (charSet == 0) {                 // ascii character
-        if (charCode >= 0 && charCode < 256)
-            *k = next_to_x[charCode];
-    } else if (charSet == 0x01) {       // symbol character
-        if (charCode >= MIN_SYMBOL &&
-            charCode <= MIN_SYMBOL + NUM_SYMBOL)
-            *k = symbol_to_x[charCode - MIN_SYMBOL];
-    } else if (charSet == 0xFE) {       // function key
-        if (charCode >= MIN_FUNCKEY &&
-            charCode <= MIN_FUNCKEY + NUM_FUNCKEY)
-            *k = funckey_to_x[charCode - MIN_FUNCKEY];
-    }
-}
-
-
-/*
- * DarwinReadKeymapFile
- *      Read the appropriate keymapping from a keymapping file.
- */
-static Bool DarwinReadKeymapFile(NXKeyMapping *keyMap) {
-    struct stat         st;
-    NXEventSystemDevice info[20];
-    int                 interface = 0, handler_id = 0;
-    int                 map_interface, map_handler_id, map_size = 0;
-    unsigned int        i, size;
-    int                 *bufferEnd;
-    union km_tag {
-        int             *intP;
-        char            *charP;
-    } km;
-
-    fref = fopen( darwinKeymapFile, "rb" );
-    if (fref == NULL) {
-        ErrorF("Unable to open keymapping file '%s': %s.\n",
-               darwinKeymapFile, strerror(errno));
-        return FALSE;
-    }
-    if (fstat(fileno(fref), &st) == -1) {
-        ErrorF("Could not stat keymapping file '%s': %s.\n",
-               darwinKeymapFile, strerror(errno));
-        return FALSE;
-    }
-
-    // check to make sure we don't crash later
-    if (st.st_size <= 16*sizeof(int)) {
-        ErrorF("Keymapping file '%s' is invalid (too small).\n",
-               darwinKeymapFile);
-        return FALSE;
-    }
-
-    inBuffer = (char*) xalloc( st.st_size );
-    bufferEnd = (int *) (inBuffer + st.st_size);
-    if (fread(inBuffer, st.st_size, 1, fref) != 1) {
-        ErrorF("Could not read %qd bytes from keymapping file '%s': %s.\n",
-               st.st_size, darwinKeymapFile, strerror(errno));
-        return FALSE;
-    }
-
-    if (strncmp( inBuffer, "KYM1", 4 ) == 0) {
-        // Magic number OK.
-    } else if (strncmp( inBuffer, "KYMP", 4 ) == 0) {
-        ErrorF("Keymapping file '%s' is intended for use with the original NeXT keyboards and cannot be used by XDarwin.\n", darwinKeymapFile);
-        return FALSE;
-    } else {
-        ErrorF("Keymapping file '%s' has a bad magic number and cannot be used by XDarwin.\n", darwinKeymapFile);
-        return FALSE;
-    }
-
-    // find the keyboard interface and handler id
-    size = sizeof( info ) / sizeof( int );
-    if (!NXEventSystemInfo( darwinParamConnect, NX_EVS_DEVICE_INFO,
-                            (NXEventSystemInfoType) info, &size )) {
-        ErrorF("Error reading event status driver info.\n");
-        return FALSE;
-    }
-
-    size = size * sizeof( int ) / sizeof( info[0] );
-    for( i = 0; i < size; i++) {
-        if (info[i].dev_type == NX_EVS_DEVICE_TYPE_KEYBOARD) {
-            Bool hasInterface = FALSE;
-            Bool hasMatch = FALSE;
-
-            interface = info[i].interface;
-            handler_id = info[i].id;
-
-            // Find an appropriate keymapping:
-            // The first time we try to match both interface and handler_id.
-            // If we can't match both, we take the first match for interface.
-
-            do {
-                km.charP = inBuffer;
-                km.intP++;
-                while (km.intP+3 < bufferEnd) {
-                    map_interface = NXSwapBigIntToHost(*(km.intP++));
-                    map_handler_id = NXSwapBigIntToHost(*(km.intP++));
-                    map_size = NXSwapBigIntToHost(*(km.intP++));
-                    if (map_interface == interface) {
-                        if (map_handler_id == handler_id || hasInterface) {
-                            hasMatch = TRUE;
-                            break;
-                        } else {
-                            hasInterface = TRUE;
-                        }
-                    }
-                    km.charP += map_size;
-                }
-            } while (hasInterface && !hasMatch);
-
-            if (hasMatch) {
-                // fill in NXKeyMapping structure
-                keyMap->size = map_size;
-                keyMap->mapping = (char*) xalloc(map_size);
-                memcpy(keyMap->mapping, km.charP, map_size);
-                return TRUE;
-            }
-        } // if dev_id == keyboard device
-    } // foreach info struct
-
-    // The keymapping file didn't match any of the info structs
-    // returned by NXEventSystemInfo.
-    ErrorF("Keymapping file '%s' did not contain appropriate keyboard interface.\n", darwinKeymapFile);
-    return FALSE;
-}
-
-
-/*
- * DarwinParseNXKeyMapping
- */
-static Bool DarwinParseNXKeyMapping(darwinKeyboardInfo  *info) {
-    KeySym              *k;
-    int                 i;
-    short               numMods, numKeys, numPadKeys = 0;
-    Bool                haveKeymap = FALSE;
-    NXKeyMapping        keyMap;
-    DataStream          *keyMapStream;
-    unsigned char const *numPadStart = 0;
-
-    if (darwinKeymapFile) {
-        haveKeymap = DarwinReadKeymapFile(&keyMap);
-        if (fref)
-            fclose(fref);
-        if (inBuffer)
-            xfree(inBuffer);
-        if (!haveKeymap) {
-            ErrorF("Reverting to kernel keymapping.\n");
-        }
-    }
-
-    if (!haveKeymap) {
-        // get the Darwin keyboard map
-        keyMap.size = NXKeyMappingLength( darwinParamConnect );
-        keyMap.mapping = (char*) xalloc( keyMap.size );
-        if (!NXGetKeyMapping( darwinParamConnect, &keyMap )) {
-            return FALSE;
-        }
-    }
-
-    keyMapStream = new_data_stream( (unsigned char const*)keyMap.mapping,
-                                    keyMap.size );
-
-    // check the type of map
-    if (get_word(keyMapStream)) {
-        keyMapStream->number_size = 2;
-        ErrorF("Current 16-bit keymapping may not be interpreted correctly.\n");
-    }
-
-    // Insert X modifier KeySyms into the keyboard map.
-    numMods = get_number(keyMapStream);
-    while (numMods-- > 0) {
-        int             left = 1;               // first keycode is left
-        short const     charCode = get_number(keyMapStream);
-        short           numKeyCodes = get_number(keyMapStream);
-
-        // This is just a marker, not a real modifier.
-        // Store numeric keypad keys for later.
-        if (charCode == NX_MODIFIERKEY_NUMERICPAD) {
-            numPadStart = keyMapStream->data;
-            numPadKeys = numKeyCodes;
-        }
-
-        while (numKeyCodes-- > 0) {
-            const short keyCode = get_number(keyMapStream);
-            if (charCode != NX_MODIFIERKEY_NUMERICPAD) {
-                switch (charCode) {
-                    case NX_MODIFIERKEY_ALPHALOCK:
-                        info->keyMap[keyCode * GLYPHS_PER_KEY] = XK_Caps_Lock;
-                        break;
-                    case NX_MODIFIERKEY_SHIFT:
-                        info->keyMap[keyCode * GLYPHS_PER_KEY] =
-                                (left ? XK_Shift_L : XK_Shift_R);
-                        break;
-                    case NX_MODIFIERKEY_CONTROL:
-                        info->keyMap[keyCode * GLYPHS_PER_KEY] =
-                                (left ? XK_Control_L : XK_Control_R);
-                        break;
-                    case NX_MODIFIERKEY_ALTERNATE:
-                        // info->keyMap[keyCode * GLYPHS_PER_KEY] = XK_Mode_switch;
-                        info->keyMap[keyCode * GLYPHS_PER_KEY] =
-                                (left ? XK_Alt_L : XK_Alt_R);
-                        break;
-                    case NX_MODIFIERKEY_COMMAND:
-                        info->keyMap[keyCode * GLYPHS_PER_KEY] =
-                                (left ? XK_Meta_L : XK_Meta_R);
-                        break;
-                    case NX_MODIFIERKEY_SECONDARYFN:
-                        info->keyMap[keyCode * GLYPHS_PER_KEY] =
-                                (left ? XK_Control_L : XK_Control_R);
-                        break;
-                    case NX_MODIFIERKEY_HELP:
-                        // Help is not an X11 modifier; treat as normal key
-                        info->keyMap[keyCode * GLYPHS_PER_KEY] = XK_Help;
-                        break;
-                }
-            }
-            left = 0;
-        }
-    }
-
-    // Convert the Darwin keyboard mapping to an X keyboard map.
-    // A key can have a different character code for each combination of
-    // modifiers. We currently ignore all modifier combinations except
-    // those with Shift, AlphaLock, and Alt.
-    numKeys = get_number(keyMapStream);
-    for (i = 0, k = info->keyMap; i < numKeys; i++, k += GLYPHS_PER_KEY) {
-        short const     charGenMask = get_number(keyMapStream);
-        if (charGenMask != 0xFF) {              // is key bound?
-            short       numKeyCodes = 1 << bits_set(charGenMask);
-
-            // Record unmodified case
-            parse_next_char_code( keyMapStream, k );
-            numKeyCodes--;
-
-            // If AlphaLock and Shift modifiers produce different codes,
-            // we record the Shift case since X handles AlphaLock.
-            if (charGenMask & 0x01) {       // AlphaLock
-                parse_next_char_code( keyMapStream, k+1 );
-                numKeyCodes--;
-            }
-
-            if (charGenMask & 0x02) {       // Shift
-                parse_next_char_code( keyMapStream, k+1 );
-                numKeyCodes--;
-
-                if (charGenMask & 0x01) {   // Shift-AlphaLock
-                    get_number(keyMapStream); get_number(keyMapStream);
-                    numKeyCodes--;
-                }
-            }
-
-            // Skip the Control cases
-            if (charGenMask & 0x04) {       // Control
-                get_number(keyMapStream); get_number(keyMapStream);
-                numKeyCodes--;
-
-                if (charGenMask & 0x01) {   // Control-AlphaLock
-                    get_number(keyMapStream); get_number(keyMapStream);
-                    numKeyCodes--;
-                }
-
-                if (charGenMask & 0x02) {   // Control-Shift
-                    get_number(keyMapStream); get_number(keyMapStream);
-                    numKeyCodes--;
-
-                    if (charGenMask & 0x01) {   // Shift-Control-AlphaLock
-                        get_number(keyMapStream); get_number(keyMapStream);
-                        numKeyCodes--;
-                    }
-                }
-            }
-
-            // Process Alt cases
-            if (charGenMask & 0x08) {       // Alt
-                parse_next_char_code( keyMapStream, k+2 );
-                numKeyCodes--;
-
-                if (charGenMask & 0x01) {   // Alt-AlphaLock
-                    parse_next_char_code( keyMapStream, k+3 );
-                    numKeyCodes--;
-                }
-
-                if (charGenMask & 0x02) {   // Alt-Shift
-                    parse_next_char_code( keyMapStream, k+3 );
-                    numKeyCodes--;
-
-                    if (charGenMask & 0x01) {   // Alt-Shift-AlphaLock
-                        get_number(keyMapStream); get_number(keyMapStream);
-                        numKeyCodes--;
-                    }
-                }
-            }
-
-            while (numKeyCodes-- > 0) {
-                get_number(keyMapStream); get_number(keyMapStream);
-            }
-
-            if (k[3] == k[2]) k[3] = NoSymbol;
-            if (k[2] == k[1]) k[2] = NoSymbol;
-            if (k[1] == k[0]) k[1] = NoSymbol;
-            if (k[0] == k[2] && k[1] == k[3]) k[2] = k[3] = NoSymbol;
-        }
-    }
-
-    // Now we have to go back through the list of keycodes that are on the
-    // numeric keypad and update the X keymap.
-    keyMapStream->data = numPadStart;
-    while(numPadKeys-- > 0) {
-        const short keyCode = get_number(keyMapStream);
-        k = &info->keyMap[keyCode * GLYPHS_PER_KEY];
-        for (i = 0; i < NUM_KEYPAD; i++) {
-            if (*k == normal_to_keypad[i].normalSym) {
-                k[0] = normal_to_keypad[i].keypadSym;
-                break;
-            }
-        }
-    }
-
-    // free Darwin keyboard map
-    destroy_data_stream( keyMapStream );
-    xfree( keyMap.mapping );
-
-    return TRUE;
-}
-
-/*
  * DarwinBuildModifierMaps
  *      Use the keyMap field of keyboard info structure to populate
  *      the modMap and modifierKeycodes fields.
@@ -822,37 +413,12 @@ static void DarwinBuildModifierMaps(darwinKeyboardInfo *info) {
 static void DarwinLoadKeyboardMapping(KeySymsRec *keySyms) {
     memset(keyInfo.keyMap, 0, sizeof(keyInfo.keyMap));
 
-    /* TODO: Clean this up
-     * QuartzReadSystemKeymap is in quartz/quartzKeyboard.c
-     * DarwinParseNXKeyMapping is here
-     */
-    if (!DarwinParseNXKeyMapping(&keyInfo)) {
-        DEBUG_LOG("DarwinParseNXKeyMapping returned 0... running QuartzReadSystemKeymap().\n");
         if (!QuartzReadSystemKeymap(&keyInfo)) {
             FatalError("Could not build a valid keymap.");
         }
-    }
 
     DarwinBuildModifierMaps(&keyInfo);
 
-#ifdef DUMP_DARWIN_KEYMAP
-    int i;
-    KeySym *k;
-    DEBUG_LOG("Darwin -> X converted keyboard map\n");
-    for (i = 0, k = keyInfo.keyMap; i < NX_NUMKEYCODES;
-         i++, k += GLYPHS_PER_KEY)
-    {
-        int j;
-        for (j = 0; j < GLYPHS_PER_KEY; j++) {
-            if (k[j] == NoSymbol) {
-                DEBUG_LOG("0x%02x:\tNoSym\n", i);
-            } else {
-                DEBUG_LOG("0x%02x:\t0x%lx\n", i, k[j]);
-            }
-        }
-    }
-#endif
-
     keySyms->map        = keyInfo.keyMap;
     keySyms->mapWidth   = GLYPHS_PER_KEY;
     keySyms->minKeyCode = MIN_KEYCODE;
