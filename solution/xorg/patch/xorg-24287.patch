diff --git a/hw/xfree86/common/xf86Io.c b/hw/xfree86/common/xf86Io.c
index 318b245..d10ad43 100644
--- a/hw/xfree86/common/xf86Io.c
+++ b/hw/xfree86/common/xf86Io.c
@@ -160,313 +160,3 @@ xf86KbdLeds ()
   xf86SetKbdLeds(real_leds);
   (void)leds;
 }
-
-/*
- * xf86KbdCtrl --
- *      Alter some of the keyboard control parameters. All special protocol
- *      values are handled by dix (ProgChangeKeyboardControl)
- */
-
-void
-xf86KbdCtrl (pKeyboard, ctrl)
-     DevicePtr     pKeyboard;        /* Keyboard to alter */
-     KeybdCtrl     *ctrl;
-{
-  int leds;
-  xf86Info.bell_pitch    = ctrl->bell_pitch;
-  xf86Info.bell_duration = ctrl->bell_duration;
-  xf86Info.autoRepeat    = ctrl->autoRepeat;
-
-  xf86Info.composeLock   = (ctrl->leds & XCOMP) ? TRUE : FALSE;
-
-  leds = (ctrl->leds & ~(XCAPS | XNUM | XSCR));
-#ifdef XKB
-  if (noXkbExtension) {
-#endif
-      xf86Info.leds = (leds & xf86Info.xleds)|(xf86Info.leds & ~xf86Info.xleds);
-#ifdef XKB
-  } else {
-      xf86Info.leds = leds;
-  }
-#endif
-
-  xf86KbdLeds();
-}
-
-/*
- * xf86InitKBD --
- *      Reinitialize the keyboard. Only set Lockkeys according to ours leds.
- *      Depress all other keys.
- */
-
-void
-xf86InitKBD(init)
-Bool init;
-{
-  char            leds = 0, rad;
-  unsigned int    i;
-  xEvent          kevent;
-  DeviceIntPtr    pKeyboard = xf86Info.pKeyboard;
-  KeyClassRec     *keyc = xf86Info.pKeyboard->key;
-  KeySym          *map = keyc->curKeySyms.map;
-
-  kevent.u.keyButtonPointer.time = GetTimeInMillis();
-  kevent.u.keyButtonPointer.rootX = 0;
-  kevent.u.keyButtonPointer.rootY = 0;
-
-  /*
-   * Hmm... here is the biggest hack of every time !
-   * It may be possible that a switch-vt procedure has finished BEFORE
-   * you released all keys neccessary to do this. That peculiar behavior
-   * can fool the X-server pretty much, cause it assumes that some keys
-   * were not released. TWM may stuck alsmost completly....
-   * OK, what we are doing here is after returning from the vt-switch
-   * exeplicitely unrelease all keyboard keys before the input-devices
-   * are reenabled.
-   */
-  for (i = keyc->curKeySyms.minKeyCode, map = keyc->curKeySyms.map;
-       i < keyc->curKeySyms.maxKeyCode;
-       i++, map += keyc->curKeySyms.mapWidth)
-    if (KeyPressed(i))
-      {
-        switch (*map) {
-	/* Don't release the lock keys */
-        case XK_Caps_Lock:
-        case XK_Shift_Lock:
-        case XK_Num_Lock:
-        case XK_Scroll_Lock:
-        case XK_Kana_Lock:
-	  break;
-        default:
-	  kevent.u.u.detail = i;
-	  kevent.u.u.type = KeyRelease;
-	  (* pKeyboard->public.processInputProc)(&kevent, pKeyboard, 1);
-        }
-      }
-  
-  xf86Info.scanPrefix      = 0;
-
-  if (init)
-    {
-      /*
-       * we must deal here with the fact, that on some cases the numlock or
-       * capslock key are enabled BEFORE the server is started up. So look
-       * here at the state on the according LEDS to determine whether a
-       * lock-key is already set.
-       */
-
-      xf86Info.capsLock        = FALSE;
-      xf86Info.numLock         = FALSE;
-      xf86Info.scrollLock      = FALSE;
-      xf86Info.modeSwitchLock  = FALSE;
-      xf86Info.composeLock     = FALSE;
-    
-#ifdef LED_CAP
-#ifdef INHERIT_LOCK_STATE
-      leds = xf86Info.leds;
-
-      for (i = keyc->curKeySyms.minKeyCode, map = keyc->curKeySyms.map;
-           i < keyc->curKeySyms.maxKeyCode;
-           i++, map += keyc->curKeySyms.mapWidth)
-
-        switch(*map) {
-
-        case XK_Caps_Lock:
-        case XK_Shift_Lock:
-          if (leds & LED_CAP) 
-	    {
-	      xf86InitialCaps = i;
-	      xf86Info.capsLock = TRUE;
-	    }
-          break;
-
-        case XK_Num_Lock:
-          if (leds & LED_NUM)
-	    {
-	      xf86InitialNum = i;
-	      xf86Info.numLock = TRUE;
-	    }
-          break;
-
-        case XK_Scroll_Lock:
-        case XK_Kana_Lock:
-          if (leds & LED_SCR)
-	    {
-	      xf86InitialScroll = i;
-	      xf86Info.scrollLock = TRUE;
-	    }
-          break;
-        }
-#endif /* INHERIT_LOCK_STATE */
-      xf86SetKbdLeds(leds);
-#endif /* LED_CAP */
-      (void)leds;
-
-      if      (xf86Info.kbdDelay <= 375) rad = 0x00;
-      else if (xf86Info.kbdDelay <= 625) rad = 0x20;
-      else if (xf86Info.kbdDelay <= 875) rad = 0x40;
-      else                               rad = 0x60;
-    
-      if      (xf86Info.kbdRate <=  2)   rad |= 0x1F;
-      else if (xf86Info.kbdRate >= 30)   rad |= 0x00;
-      else                               rad |= ((58 / xf86Info.kbdRate) - 2);
-    
-      xf86SetKbdRepeat(rad);
-    }
-}
-
-/*
- * xf86KbdProc --
- *	Handle the initialization, etc. of a keyboard.
- */
-
-int
-xf86KbdProc (pKeyboard, what)
-     DeviceIntPtr pKeyboard;	/* Keyboard to manipulate */
-     int       what;	    	/* What to do to it */
-{
-  KeySymsRec           keySyms;
-  CARD8                modMap[MAP_LENGTH];
-  int                  kbdFd;
-
-  switch (what) {
-
-  case DEVICE_INIT:
-    /*
-     * First open and find the current state of the keyboard.
-     */
-
-    xf86KbdInit();
-
-    xf86KbdGetMapping(&keySyms, modMap);
-    
-
-#ifndef XKB
-    defaultKeyboardControl.leds = xf86GetKbdLeds();
-#else
-    defaultKeyboardControl.leds = 0;
-#endif
-
-    /*
-     * Perform final initialization of the system private keyboard
-     * structure and fill in various slots in the device record
-     * itself which couldn't be filled in before.
-     */
-
-    pKeyboard->public.on = FALSE;
-
-#ifdef XKB
-    if (noXkbExtension) {
-#endif
-    InitKeyboardDeviceStruct((DevicePtr)xf86Info.pKeyboard,
-			     &keySyms,
-			     modMap,
-			     xf86KbdBell,
-			     (KbdCtrlProcPtr)xf86KbdCtrl);
-#ifdef XKB
-    } else {
- 	XkbComponentNamesRec	names;
-	XkbDescPtr		desc;
-	Bool			foundTerminate = FALSE;
-	int			keyc;
-	if (xf86Info.xkbkeymap) {
-	    names.keymap = xf86Info.xkbkeymap;
-	    names.keycodes = NULL;
-	    names.types = NULL;
-	    names.compat = NULL;
-	    names.symbols = NULL;
-	    names.geometry = NULL;
-	} else {
-	    names.keymap = NULL;
-	    names.keycodes = xf86Info.xkbkeycodes;
-	    names.types = xf86Info.xkbtypes;
-	    names.compat = xf86Info.xkbcompat;
-	    names.symbols = xf86Info.xkbsymbols;
-	    names.geometry = xf86Info.xkbgeometry;
-	}
-	if ((xf86Info.xkbkeymap || xf86Info.xkbcomponents_specified)
-	   && (xf86Info.xkbmodel == NULL || xf86Info.xkblayout == NULL)) {
-		xf86Info.xkbrules = NULL;
-	}
-	XkbSetRulesDflts(xf86Info.xkbrules, xf86Info.xkbmodel,
-			 xf86Info.xkblayout, xf86Info.xkbvariant,
-			 xf86Info.xkboptions);
-	
-	XkbInitKeyboardDeviceStruct(pKeyboard, 
-				    &names,
-				    &keySyms, 
-				    modMap, 
-				    xf86KbdBell,
-				    (KbdCtrlProcPtr)xf86KbdCtrl);
-
-	/* Search keymap for Terminate action */
-	desc  = pKeyboard->key->xkbInfo->desc;
-	for (keyc = desc->min_key_code; keyc <= desc->max_key_code; keyc++) {
-	    int i;
-	    for (i = 1; i <= XkbKeyNumActions(desc, keyc); i++) {
-		if (XkbKeyAction(desc, keyc, i)
-		  && XkbKeyAction(desc, keyc, i)->type == XkbSA_Terminate) {
-		    foundTerminate = TRUE;
-		    goto searchdone;
-		}
-	    }
-  	}
-searchdone:
-	xf86Info.ActionKeyBindingsSet = foundTerminate;
-	if (!foundTerminate)
-	    xf86Msg(X_INFO, "Server_Terminate keybinding not found\n");
-    }
-#endif
-    
-    xf86InitKBD(TRUE);
-    break;
-    
-  case DEVICE_ON:
-    /*
-     * Set the keyboard into "direct" mode and turn on
-     * event translation.
-     */
-
-    kbdFd = xf86KbdOn();
-    /*
-     * Discard any pending input after a VT switch to prevent the server
-     * passing on parts of the VT switch sequence.
-     */
-    sleep(1);
-#if defined(WSCONS_SUPPORT)
-    if (xf86Info.consType != WSCONS) {
-#endif
-	if (kbdFd != -1) {
-		char buf[16];
-		read(kbdFd, buf, 16);
-    	}
-#if defined(WSCONS_SUPPORT)
-    }
-#endif
-
-#if !defined(__UNIXOS2__) /* Under EMX, keyboard cannot be select()'ed */
-    if (kbdFd != -1)
-      AddEnabledDevice(kbdFd);
-#endif  /* __UNIXOS2__ */
-
-    pKeyboard->public.on = TRUE;
-    xf86InitKBD(FALSE);
-    break;
-    
-  case DEVICE_CLOSE:
-  case DEVICE_OFF:
-    /*
-     * Restore original keyboard directness and translation.
-     */
-
-    kbdFd = xf86KbdOff();
-
-    if (kbdFd != -1)
-      RemoveEnabledDevice(kbdFd);
-
-    pKeyboard->public.on = FALSE;
-    break;
-
-  }
-  return (Success);
-}
