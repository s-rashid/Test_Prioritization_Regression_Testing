diff --git a/hw/xfree86/common/xf86pciBus.c b/hw/xfree86/common/xf86pciBus.c
index 4d587a1..fa88e74 100644
--- a/hw/xfree86/common/xf86pciBus.c
+++ b/hw/xfree86/common/xf86pciBus.c
@@ -29,8 +29,6 @@
 /*
  * This file contains the interfaces to the bus-specific code
  */
-#define INCLUDE_DEPRECATED 1
-
 #ifdef HAVE_XORG_CONFIG_H
 #include <xorg-config.h>
 #endif
@@ -39,6 +37,7 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <X11/X.h>
+#include <pciaccess.h>
 #include "os.h"
 #include "Pci.h"
 #include "xf86.h"
@@ -46,8 +45,6 @@
 #include "xf86Resources.h"
 
 /* Bus-specific headers */
-#include "xf86PciData.h"
-
 #include "xf86Bus.h"
 
 #define XF86_OS_PRIVS
@@ -58,67 +55,56 @@
 
 /* Bus-specific globals */
 Bool pciSlotClaimed = FALSE;
-pciConfigPtr *xf86PciInfo = NULL;		/* Full PCI probe info */
-pciVideoPtr *xf86PciVideoInfo = NULL;		/* PCI probe for video hw */
-pciAccPtr * xf86PciAccInfo = NULL;              /* PCI access related */
-
-/* pcidata globals */
-ScanPciSetupProcPtr xf86SetupPciIds = NULL;
-ScanPciCloseProcPtr xf86ClosePciIds = NULL;
-ScanPciFindByDeviceProcPtr xf86FindPciNamesByDevice = NULL;
-ScanPciFindBySubsysProcPtr xf86FindPciNamesBySubsys = NULL;
-
-static resPtr pciAvoidRes = NULL;
+static pciConfigPtr *xf86PciInfo = NULL;	/* Full PCI probe info */
+struct pci_device ** xf86PciVideoInfo = NULL;	/* PCI probe for video hw */
 
 /* PCI buses */
 static PciBusPtr xf86PciBus = NULL;
 /* Bus-specific probe/sorting functions */
 
 /* PCI classes that get included in xf86PciVideoInfo */
-#define PCIINFOCLASSES(b,s)						      \
-    (((b) == PCI_CLASS_PREHISTORIC) ||					      \
-     ((b) == PCI_CLASS_DISPLAY) ||					      \
-     ((b) == PCI_CLASS_MULTIMEDIA && (s) == PCI_SUBCLASS_MULTIMEDIA_VIDEO) || \
-     ((b) == PCI_CLASS_PROCESSOR && (s) == PCI_SUBCLASS_PROCESSOR_COPROC))
+#define PCIINFOCLASSES(c) \
+    ( (((c) & 0x00ff0000) == (PCI_CLASS_PREHISTORIC << 16)) \
+      || (((c) & 0x00ff0000) == (PCI_CLASS_DISPLAY << 16)) \
+      || ((((c) & 0x00ffff00) \
+	   == ((PCI_CLASS_MULTIMEDIA << 16) | (PCI_SUBCLASS_MULTIMEDIA_VIDEO << 8)))) \
+      || ((((c) & 0x00ffff00) \
+	   == ((PCI_CLASS_PROCESSOR << 16) | (PCI_SUBCLASS_PROCESSOR_COPROC << 8)))) )
 
 /*
  * PCI classes that have messages printed always.  The others are only
  * have a message printed when the vendor/dev IDs are recognised.
  */
-#define PCIALWAYSPRINTCLASSES(b,s)					      \
-    (((b) == PCI_CLASS_PREHISTORIC && (s) == PCI_SUBCLASS_PREHISTORIC_VGA) || \
-     ((b) == PCI_CLASS_DISPLAY) ||					      \
-     ((b) == PCI_CLASS_MULTIMEDIA && (s) == PCI_SUBCLASS_MULTIMEDIA_VIDEO))
+#define PCIALWAYSPRINTCLASSES(c) \
+    ( (((c) & 0x00ffff00) \
+       == ((PCI_CLASS_PREHISTORIC << 16) | (PCI_SUBCLASS_PREHISTORIC_VGA << 8))) \
+      || (((c) & 0x00ff0000) == (PCI_CLASS_DISPLAY << 16)) \
+      || ((((c) & 0x00ffff00) \
+	   == ((PCI_CLASS_MULTIMEDIA << 16) | (PCI_SUBCLASS_MULTIMEDIA_VIDEO << 8)))) )
+
+#define IS_VGA(c) \
+    (((c) & 0x00ffff00) \
+	 == ((PCI_CLASS_DISPLAY << 16) | (PCI_SUBCLASS_DISPLAY_VGA << 8)))
  
 /*
  * PCI classes for which potentially destructive checking of the map sizes
  * may be done.  Any classes where this may be unsafe should be omitted
  * from this list.
  */
-#define PCINONSYSTEMCLASSES(b,s) PCIALWAYSPRINTCLASSES(b,s)
+#define PCINONSYSTEMCLASSES(c) PCIALWAYSPRINTCLASSES(c)
 
 /* 
  * PCI classes that use RAC 
  */
-#define PCISHAREDIOCLASSES(b,s)					      \
-    (((b) == PCI_CLASS_PREHISTORIC && (s) == PCI_SUBCLASS_PREHISTORIC_VGA) || \
-     ((b) == PCI_CLASS_DISPLAY && (s) == PCI_SUBCLASS_DISPLAY_VGA))
+#define PCISHAREDIOCLASSES(c) \
+    ( (((c) & 0x00ffff00) \
+       == ((PCI_CLASS_PREHISTORIC << 16) | (PCI_SUBCLASS_PREHISTORIC_VGA << 8))) \
+      || IS_VGA(c) )
 
-#define PCI_MEM32_LENGTH_MAX 0xFFFFFFFF
 
 #define B2M(tag,base) pciBusAddrToHostAddr(tag,PCI_MEM,base)
 #define B2I(tag,base) pciBusAddrToHostAddr(tag,PCI_IO,base)
-#define B2H(tag,base,type) (((type & ResPhysMask) == ResMem) ? \
-			B2M(tag, base) : B2I(tag, base))
-#define M2B(tag,base) pciHostAddrToBusAddr(tag,PCI_MEM,base)
-#define I2B(tag,base) pciHostAddrToBusAddr(tag,PCI_IO,base)
-#define H2B(tag,base,type) (((type & ResPhysMask) == ResMem) ? \
-			M2B(tag, base) : I2B(tag, base))
-#define TAG(pvp) (pciTag(pvp->bus,pvp->device,pvp->func))
-#define SIZE(size) ((1 << size) - 1)
-#define PCI_SIZE(type,tag,size) (((type & ResPhysMask) == ResMem) \
-                        ? pciBusAddrToHostAddr(tag,PCI_MEM_SIZE,size) \
-                        : pciBusAddrToHostAddr(tag,PCI_IO_SIZE,size))
+
 #define PCI_M_RANGE(range,tag,begin,end,type) \
 	{ \
 	    RANGE(range, B2M(tag, begin), B2M(tag, end), \
@@ -129,24 +115,7 @@ static PciBusPtr xf86PciBus = NULL;
 	    RANGE(range, B2I(tag, begin), B2I(tag, end), \
 		  RANGE_TYPE(type, xf86GetPciDomain(tag))); \
 	}
-#define PCI_X_RANGE(range,tag,begin,end,type) \
-{ if ((type & ResPhysMask) == ResMem)  PCI_M_RANGE(range,tag,begin,end,type); \
-                else PCI_I_RANGE(range,tag,begin,end,type); } 
-#define P_M_RANGE(range,tag,begin,size,type) \
-                    PCI_M_RANGE(range,tag,begin,(begin + SIZE(size)),type)
-#define P_I_RANGE(range,tag,begin,size,type) \
-                    PCI_I_RANGE(range,tag,begin,(begin + SIZE(size)),type)
-#define P_X_RANGE(range,tag,begin,size,type) \
-{ if ((type & ResPhysMask) == ResMem)  P_M_RANGE(range,tag,begin,size,type); \
-                else P_I_RANGE(range,tag,begin,size,type); }
-#define PV_M_RANGE(range,pvp,i,type) \
-                  P_M_RANGE(range,TAG(pvp),pvp->memBase[i],pvp->size[i],type)
-#define PV_B_RANGE(range,pvp,type) \
-                  P_M_RANGE(range,TAG(pvp),pvp->biosBase,pvp->biosSize,type)
-#define PV_I_RANGE(range,pvp,i,type) \
-                  P_I_RANGE(range,TAG(pvp),pvp->ioBase[i],pvp->size[i],type)
-
-static void pciConvertListToHost(int bus, int dev, int func, resPtr list);
+
 static PciBusPtr xf86GetPciBridgeInfo(void);
 
 _X_EXPORT void
@@ -159,92 +128,64 @@ xf86FormatPciBusNumber(int busnum, char *buffer)
 	sprintf(buffer, "%d@%d", busnum & 0x00ff, busnum >> 8);
 }
 
-static Bool
-IsBaseUnassigned(CARD32 base)
-{
-    CARD32 mask;
-
-    if (base & PCI_MAP_IO)
-	mask = ~PCI_MAP_IO_ATTR_MASK;
-    else
-	mask = ~PCI_MAP_MEMORY_ATTR_MASK;
-
-    base &= mask;
-    return (!base || (base == mask));
-}
-
-static Bool
-IsBaseUnassigned64(CARD32 base0, CARD32 base1)
-{
-    base0 &= ~PCI_MAP_MEMORY_ATTR_MASK;
-    base1 &= 0xffffffff;
-    
-    return ((!base0 && !base1)
-	    || ((base0 == ~PCI_MAP_MEMORY_ATTR_MASK)
-		&& (base1 == 0xffffffff)));
-}
-
 static void
 FindPCIVideoInfo(void)
 {
-    pciConfigPtr pcrp, *pcrpp;
     int i = 0, j, k;
     int num = 0;
-    pciVideoPtr info;
-    int DoIsolateDeviceCheck = 0;
+    struct pci_device * info;
+    struct pci_slot_match   m;
+    struct pci_device_iterator * iter;
 
-    if (xf86IsolateDevice.bus || xf86IsolateDevice.device || xf86IsolateDevice.func)
-        DoIsolateDeviceCheck = 1;
-    pcrpp = xf86PciInfo = xf86scanpci(0);
 
+    xf86PciInfo = xf86scanpci(0);
     
-    if (pcrpp == NULL) {
+    if (xf86PciInfo == NULL) {
 	xf86PciVideoInfo = NULL;
 	return;
     }
+
     xf86PciBus = xf86GetPciBridgeInfo();
 
-    while ((pcrp = pcrpp[i])) {
-	const int baseclass = pcrp->pci_base_class;
-	const int subclass = pcrp->pci_sub_class;
+    if ( (xf86IsolateDevice.bus != 0)
+	 || (xf86IsolateDevice.device != 0) 
+	 || (xf86IsolateDevice.func != 0) ) {
+	m.domain = PCI_DOM_FROM_BUS( xf86IsolateDevice.bus );
+	m.bus = PCI_BUS_NO_DOMAIN( xf86IsolateDevice.bus );
+	m.dev = xf86IsolateDevice.device;
+	m.func = xf86IsolateDevice.func;
+    }
+    else {
+	m.domain = PCI_MATCH_ANY;
+	m.bus = PCI_MATCH_ANY;
+	m.dev = PCI_MATCH_ANY;
+	m.func = PCI_MATCH_ANY;
+    }
+
+    iter = pci_slot_match_iterator_create( & m );
 	
-	if ( PCIINFOCLASSES(baseclass, subclass) &&
-	     (!DoIsolateDeviceCheck ||
-	      (xf86IsolateDevice.bus == pcrp->busnum &&
-	       xf86IsolateDevice.device == pcrp->devnum &&
-	       xf86IsolateDevice.func == pcrp->funcnum)) ) {
+    while ( (info = pci_device_next( iter )) != NULL ) {
+	if ( PCIINFOCLASSES( info->device_class ) ) {
 	    num++;
 	    xf86PciVideoInfo = xnfrealloc(xf86PciVideoInfo,
-					  sizeof(pciVideoPtr) * (num + 1));
+					   (sizeof( struct pci_device * ) 
+					    * (num + 1)) );
 	    xf86PciVideoInfo[num] = NULL;
-	    info = xf86PciVideoInfo[num - 1] = xnfalloc(sizeof(pciVideoRec));
-	    info->validSize = FALSE;
-	    info->vendor = pcrp->pci_vendor;
-	    info->chipType = pcrp->pci_device;
-	    info->chipRev = pcrp->pci_rev_id;
-	    info->subsysVendor = pcrp->pci_subsys_vendor;
-	    info->subsysCard = pcrp->pci_subsys_card;
-	    info->bus = pcrp->busnum;
-	    info->device = pcrp->devnum;
-	    info->func = pcrp->funcnum;
-	    info->class = baseclass;
-	    info->subclass = pcrp->pci_sub_class;
-	    info->interface = pcrp->pci_prog_if;
-	    info->biosBase = PCIGETROM(pcrp->pci_baserom);
-	    info->biosSize = pciGetBaseSize(pcrp->tag, 6, TRUE, NULL);
-	    info->thisCard = pcrp;
-	    info->validate = FALSE;
-#ifdef INCLUDE_XF86_NO_DOMAIN
-	    if ((PCISHAREDIOCLASSES(baseclass, subclass))
-		&& (pcrp->pci_command & PCI_CMD_IO_ENABLE) &&
-		(pcrp->pci_prog_if == 0)) {
+	    xf86PciVideoInfo[num - 1] = info;
+
+	    pci_device_probe(info);
+	    info->user_data = 0;
 
+#if 0 && defined(INCLUDE_XF86_NO_DOMAIN)
+	    if ((PCISHAREDIOCLASSES( info->device_class ))
+		&& (pcrp->pci_command & PCI_CMD_IO_ENABLE) 
+		&& (pcrp->pci_prog_if == 0)) {
 		/*
 		 * Attempt to ensure that VGA is actually routed to this
 		 * adapter on entry.  This needs to be fixed when we finally
 		 * grok host bridges (and multiple bus trees).
 		 */
-		j = info->bus;
+		j = pcrp->busnum;
 		while (TRUE) {
 		    PciBusPtr pBus = xf86PciBus;
 		    while (pBus && j != pBus->secondary)
@@ -269,102 +210,25 @@ FindPCIVideoInfo(void)
 		}
 	    }
 #endif
-	    
-	    for (j = 0; j < 6; j++) {
-		info->memBase[j] = 0;
-		info->ioBase[j] = 0;
-		if (PCINONSYSTEMCLASSES(baseclass, subclass)) {
-		    info->size[j] =
-			pciGetBaseSize(pcrp->tag, j, TRUE, &info->validSize);
-		    pcrp->minBasesize = info->validSize;
-		} else {
-		    info->size[j] = pcrp->basesize[j];
-		    info->validSize = pcrp->minBasesize;
-		}
-		info->type[j] = 0;
-	    }
-
-	    if (PCINONSYSTEMCLASSES(baseclass, subclass)) {
-		/*
-		 * Check of a PCI base is unassigned. If so
-		 * attempt to fix it. Validation will determine
-		 * if the value was correct later on.
-		 */
-		CARD32 *base = &pcrp->pci_base0;
-
-		for (j = 0; j < 6; j++) {
-		    if (!PCI_MAP_IS64BITMEM(base[j])) {
-			if (info->size[j] && IsBaseUnassigned(base[j])) 
-			    base[j] = pciCheckForBrokenBase(pcrp->tag, j);
-		    } else {
-			if (j == 5) /* bail out */
-			    break;
-			if (info->size[j]
-			    && IsBaseUnassigned64(base[j],base[j+1])) {
-			    base[j] = pciCheckForBrokenBase(pcrp->tag, j);
-			    j++;
-			    base[j] = pciCheckForBrokenBase(pcrp->tag, j);
-			}
-		    }
 		}
 	    }
 	    
-	    /*
-	     * 64-bit base addresses are checked for and avoided on 32-bit
-	     * platforms.
-	     */
-	    for (j = 0; j < 6; ++j) {
-		CARD32  bar = (&pcrp->pci_base0)[j];
-
-		if (bar != 0) {
-		    if (bar & PCI_MAP_IO) {
-			info->ioBase[j] = (memType)PCIGETIO(bar);
-			info->type[j] = bar & PCI_MAP_IO_ATTR_MASK;
-		    } else {
-			info->type[j] = bar & PCI_MAP_MEMORY_ATTR_MASK;
-			info->memBase[j] = (memType)PCIGETMEMORY(bar);
-			if (PCI_MAP_IS64BITMEM(bar)) {
-			    if (j == 5) {
-				xf86MsgVerb(X_WARNING, 0,
-				    "****BAR5 specified as 64-bit wide, "
-				    "which is not possible. "
-				    "Ignoring BAR5.****\n");
-				info->memBase[j] = 0;
-			    } else {
-				CARD32  bar_hi = PCIGETMEMORY64HIGH((&pcrp->pci_base0)[j]);
-#if defined(LONG64) || defined(WORD64)
-				    /* 64 bit architecture */
-				    info->memBase[j] |=
-					(memType)bar_hi << 32;
-#else
-				    if (bar_hi != 0)
-					info->memBase[j] = 0;
-#endif
-				    ++j;    /* Step over the next BAR */
-			    }
-			}
-		    }
-		}
-	    }
-	}
-	i++;
-    }
 
     /* If we haven't found a primary device try a different heuristic */
     if (primaryBus.type == BUS_NONE && num) {
 	for (i = 0;  i < num;  i++) {
+	    uint16_t  command;
+
 	    info = xf86PciVideoInfo[i];
-	    pcrp = info->thisCard;
+	    pci_device_cfg_read_u16( info, & command, 4 );
 	    
-	    if ((pcrp->pci_command & PCI_CMD_MEM_ENABLE) &&
-		(num == 1 ||
-		 ((info->class == PCI_CLASS_DISPLAY) &&
-		  (info->subclass == PCI_SUBCLASS_DISPLAY_VGA)))) {
+	    if ( (command & PCI_CMD_MEM_ENABLE) 
+		 && ((num == 1) || IS_VGA( info->device_class )) ) {
 		if (primaryBus.type == BUS_NONE) {
 		    primaryBus.type = BUS_PCI;
-		    primaryBus.id.pci.bus = pcrp->busnum;
-		    primaryBus.id.pci.device = pcrp->devnum;
-		    primaryBus.id.pci.func = pcrp->funcnum;
+		    primaryBus.id.pci.bus = PCI_MAKE_BUS( info->domain, info->bus );
+		    primaryBus.id.pci.device = info->dev;
+		    primaryBus.id.pci.func = info->func;
 		} else {
 		    xf86Msg(X_NOTICE,
 			    "More than one possible primary device found\n");
@@ -378,141 +242,71 @@ FindPCIVideoInfo(void)
     for (k = 0; k < num; k++) {
 	const char *vendorname = NULL, *chipname = NULL;
 	const char *prim = " ";
-	char busnum[8];
 	Bool memdone = FALSE, iodone = FALSE;
 
-	i = 0; 
+
 	info = xf86PciVideoInfo[k];
-	xf86FormatPciBusNumber(info->bus, busnum);
-	xf86FindPciNamesByDevice(info->vendor, info->chipType,
-				 NOVENDOR, NOSUBSYS,
-				 &vendorname, &chipname, NULL, NULL);
+
+	vendorname = pci_device_get_vendor_name( info );
+	chipname = pci_device_get_device_name( info );
+
 	if ((!vendorname || !chipname) &&
-	    !PCIALWAYSPRINTCLASSES(info->class, info->subclass))
+	    !PCIALWAYSPRINTCLASSES( info->device_class ))
 	    continue;
+
 	if (xf86IsPrimaryPci(info))
 	    prim = "*";
 
-	xf86Msg(X_PROBED, "PCI:%s(%s:%d:%d) ", prim, busnum, info->device,
-		info->func);
+	xf86Msg( X_PROBED, "PCI:%s(%u@%u:%u:%u) ", prim, info->domain,
+		 info->bus, info->dev, info->func );
+
 	if (vendorname)
 	    xf86ErrorF("%s ", vendorname);
 	else
-	    xf86ErrorF("unknown vendor (0x%04x) ", info->vendor);
+	    xf86ErrorF("unknown vendor (0x%04x) ", info->vendor_id);
+
 	if (chipname)
 	    xf86ErrorF("%s ", chipname);
 	else
-	    xf86ErrorF("unknown chipset (0x%04x) ", info->chipType);
-	xf86ErrorF("rev %d", info->chipRev);
+	    xf86ErrorF("unknown chipset (0x%04x) ", info->device_id);
+
+	xf86ErrorF("rev %d", info->revision);
+
 	for (i = 0; i < 6; i++) {
-	    if (info->memBase[i] &&
-		(info->memBase[i] < (memType)(-1 << info->size[i]))) {
+	    struct pci_mem_region * r = & info->regions[i];
+
+	    if ( r->size && ! r->is_IO ) {
 		if (!memdone) {
 		    xf86ErrorF(", Mem @ ");
 		    memdone = TRUE;
 		} else
 		    xf86ErrorF(", ");
-		xf86ErrorF("0x%08lx/%d", info->memBase[i], info->size[i]);
+		xf86ErrorF("0x%08lx/%ld", r->base_addr, r->size);
 	    }
 	}
+
 	for (i = 0; i < 6; i++) {
-	    if (info->ioBase[i] &&
-		(info->ioBase[i] < (memType)(-1 << info->size[i]))) {
+	    struct pci_mem_region * r = & info->regions[i];
+
+	    if ( r->size && r->is_IO ) {
 		if (!iodone) {
 		    xf86ErrorF(", I/O @ ");
 		    iodone = TRUE;
 		} else
 		    xf86ErrorF(", ");
-		xf86ErrorF("0x%04lx/%d", info->ioBase[i], info->size[i]);
-	    }
-	}
-	if (info->biosBase &&
-	    (info->biosBase < (memType)(-1 << info->biosSize)))
-	    xf86ErrorF(", BIOS @ 0x%08lx/%d", info->biosBase, info->biosSize);
-	xf86ErrorF("\n");
+		xf86ErrorF("0x%08lx/%ld", r->base_addr, r->size);
     }
 }
 
-/*
- * fixPciSizeInfo() -- fix pci size info by testing it destructively
- * (if not already done), fix pciVideoInfo and entry in the resource
- * list.
- */
-/*
- * Note: once we have OS support to read the sizes GetBaseSize() will
- * have to be wrapped by the OS layer. fixPciSizeInfo() should also
- * be wrapped by the OS layer to do nothing if the size is always
- * returned correctly by GetBaseSize(). It should however set validate
- * in pciVideoRec if validation is required. ValidatePci() also needs
- * to be wrapped by the OS layer. This may do nothing if the OS has
- * already taken care of validation. fixPciResource() may be moved to
- * OS layer with minimal changes. Once the wrapping layer is in place
- * the common level and drivers should not reference these functions
- * directly but thru the OS layer.
- */
-
-static void
-fixPciSizeInfo(int entityIndex)
-{
-    pciVideoPtr pvp;
-    resPtr pAcc;
-    PCITAG tag;
-    int j;
-    
-    if (! (pvp = xf86GetPciInfoForEntity(entityIndex))) return;
-    if (pvp->validSize) return;
-
-    tag = pciTag(pvp->bus,pvp->device,pvp->func);
-    
-    for (j = 0; j < 6; j++) {
-	pAcc = Acc;
-	if (pvp->memBase[j]) 
-	    while (pAcc) {
-		if (((pAcc->res_type & (ResPhysMask | ResBlock))
-		     == (ResMem | ResBlock))
-		    && (pAcc->block_begin == B2M(TAG(pvp),pvp->memBase[j])) 
-		    && (pAcc->block_end == B2M(TAG(pvp),pvp->memBase[j]
-		    + SIZE(pvp->size[j])))) break;
-		pAcc = pAcc->next;
-	    }
-	else if (pvp->ioBase[j])
-	    while (pAcc) {
-		if (((pAcc->res_type & (ResPhysMask | ResBlock)) ==
-		     (ResIo | ResBlock))
-		    && (pAcc->block_begin == B2I(TAG(pvp),pvp->ioBase[j]))
-		    && (pAcc->block_end == B2I(TAG(pvp),pvp->ioBase[j]
-		    + SIZE(pvp->size[j])))) break;
-		pAcc = pAcc->next;
-	    }
-	else continue;
-	pvp->size[j]  = pciGetBaseSize(tag, j, TRUE, &pvp->validSize);
-	if (pAcc) {
-	    pAcc->block_end = pvp->memBase[j] ?
-		B2M(TAG(pvp),pvp->memBase[j] + SIZE(pvp->size[j]))
-		: B2I(TAG(pvp),pvp->ioBase[j] + SIZE(pvp->size[j]));
-	    pAcc->res_type &= ~ResEstimated;
-	    pAcc->res_type |= ResBios;
-	}
-    }
-    if (pvp->biosBase) {
-	pAcc = Acc;
-	while (pAcc) {
-	    if (((pAcc->res_type & (ResPhysMask | ResBlock)) ==
-		 (ResMem | ResBlock))
-		&& (pAcc->block_begin == B2M(TAG(pvp),pvp->biosBase))
-		    && (pAcc->block_end == B2M(TAG(pvp),pvp->biosBase
-		    + SIZE(pvp->biosSize)))) break;
-	    pAcc = pAcc->next;
-	}
-	pvp->biosSize = pciGetBaseSize(tag, 6, TRUE, &pvp->validSize);
-	if (pAcc) {
-	    pAcc->block_end = B2M(TAG(pvp),pvp->biosBase+SIZE(pvp->biosSize));
-	    pAcc->res_type &= ~ResEstimated;
-	    pAcc->res_type |= ResBios;
+	if ( info->rom_size ) {
+	    xf86ErrorF(", BIOS @ 0x\?\?\?\?\?\?\?\?/%ld", info->rom_size);
 	}
+
+	xf86ErrorF("\n");
     }
 }
 
+
 /*
  * IO enable/disable related routines for PCI
  */
@@ -525,7 +319,7 @@ pciIoAccessEnable(void* arg)
     ErrorF("pciIoAccessEnable: 0x%05lx\n", *(PCITAG *)arg);
 #endif
     pArg->ctrl |= SETBITS | PCI_CMD_MASTER_ENABLE;
-    pciWriteLong(pArg->tag, PCI_CMD_STAT_REG, pArg->ctrl);
+    pci_device_cfg_write_u32( pArg->dev, & pArg->ctrl, PCI_CMD_STAT_REG );
 }
 
 static void
@@ -535,7 +329,7 @@ pciIoAccessDisable(void* arg)
     ErrorF("pciIoAccessDisable: 0x%05lx\n", *(PCITAG *)arg);
 #endif
     pArg->ctrl &= ~SETBITS;
-    pciWriteLong(pArg->tag, PCI_CMD_STAT_REG, pArg->ctrl);
+    pci_device_cfg_write_u32( pArg->dev, & pArg->ctrl, PCI_CMD_STAT_REG );
 }
 
 #undef SETBITS
@@ -547,7 +341,7 @@ pciIo_MemAccessEnable(void* arg)
     ErrorF("pciIo_MemAccessEnable: 0x%05lx\n", *(PCITAG *)arg);
 #endif
     pArg->ctrl |= SETBITS | PCI_CMD_MASTER_ENABLE;
-    pciWriteLong(pArg->tag, PCI_CMD_STAT_REG, pArg->ctrl);
+    pci_device_cfg_write_u32( pArg->dev, & pArg->ctrl, PCI_CMD_STAT_REG );
 }
 
 static void
@@ -557,7 +351,7 @@ pciIo_MemAccessDisable(void* arg)
     ErrorF("pciIo_MemAccessDisable: 0x%05lx\n", *(PCITAG *)arg);
 #endif
     pArg->ctrl &= ~SETBITS;
-    pciWriteLong(pArg->tag, PCI_CMD_STAT_REG, pArg->ctrl);
+    pci_device_cfg_write_u32( pArg->dev, & pArg->ctrl, PCI_CMD_STAT_REG );
 }
 
 #undef SETBITS
@@ -569,7 +363,7 @@ pciMemAccessEnable(void* arg)
     ErrorF("pciMemAccessEnable: 0x%05lx\n", *(PCITAG *)arg);
 #endif
     pArg->ctrl |= SETBITS | PCI_CMD_MASTER_ENABLE;
-    pciWriteLong(pArg->tag, PCI_CMD_STAT_REG, pArg->ctrl);
+    pci_device_cfg_write_u32( pArg->dev, & pArg->ctrl, PCI_CMD_STAT_REG );
 }
 
 static void
@@ -579,7 +373,7 @@ pciMemAccessDisable(void* arg)
     ErrorF("pciMemAccessDisable: 0x%05lx\n", *(PCITAG *)arg);
 #endif
     pArg->ctrl &= ~SETBITS;
-    pciWriteLong(pArg->tag, PCI_CMD_STAT_REG, pArg->ctrl);
+    pci_device_cfg_write_u32( pArg->dev, & pArg->ctrl, PCI_CMD_STAT_REG );
 }
 #undef SETBITS
 #undef pArg
@@ -590,17 +384,17 @@ pciMemAccessDisable(void* arg)
 static void
 pciBusAccessEnable(BusAccPtr ptr)
 {
-    PCITAG tag = ptr->busdep.pci.acc;
-    CARD16 ctrl;
+    struct pci_device * const dev = ptr->busdep.pci.dev;
+    uint16_t ctrl;
 
 #ifdef DEBUG
     ErrorF("pciBusAccessEnable: bus=%d\n", ptr->busdep.pci.bus);
 #endif
-    ctrl = pciReadWord(tag, PCI_PCI_BRIDGE_CONTROL_REG);
+    pci_device_cfg_read_u16( dev, & ctrl, PCI_PCI_BRIDGE_CONTROL_REG );
     if ((ctrl & MASKBITS) != PCI_PCI_BRIDGE_VGA_EN) {
 	ctrl = (ctrl | PCI_PCI_BRIDGE_VGA_EN) &
 	    ~(PCI_PCI_BRIDGE_MASTER_ABORT_EN | PCI_PCI_BRIDGE_SECONDARY_RESET);
-	pciWriteWord(tag, PCI_PCI_BRIDGE_CONTROL_REG, ctrl);
+	pci_device_cfg_write_u16( dev, & ctrl, PCI_PCI_BRIDGE_CONTROL_REG );
     }
 }
 
@@ -608,16 +402,16 @@ pciBusAccessEnable(BusAccPtr ptr)
 static void
 pciBusAccessDisable(BusAccPtr ptr)
 {
-    PCITAG tag = ptr->busdep.pci.acc;
-    CARD16 ctrl;
+    struct pci_device * const dev = ptr->busdep.pci.dev;
+    uint16_t ctrl;
 
 #ifdef DEBUG
     ErrorF("pciBusAccessDisable: bus=%d\n", ptr->busdep.pci.bus);
 #endif
-    ctrl = pciReadWord(tag, PCI_PCI_BRIDGE_CONTROL_REG);
+    pci_device_cfg_read_u16( dev, & ctrl, PCI_PCI_BRIDGE_CONTROL_REG );
     if (ctrl & MASKBITS) {
 	ctrl &= ~(MASKBITS | PCI_PCI_BRIDGE_SECONDARY_RESET);
-	pciWriteWord(tag, PCI_PCI_BRIDGE_CONTROL_REG, ctrl);
+	pci_device_cfg_write_u16( dev, & ctrl, PCI_PCI_BRIDGE_CONTROL_REG );
     }
 }
 #undef MASKBITS
@@ -679,44 +473,55 @@ pciSetBusAccess(BusAccPtr ptr)
 
 /* move to OS layer */
 static void
-savePciState(PCITAG tag, pciSavePtr ptr)
+savePciState( struct pci_device * dev, pciSavePtr ptr )
 {
     int i;
      
-    ptr->command = pciReadLong(tag, PCI_CMD_STAT_REG);
-    for (i=0; i < 6; i++) 
-        ptr->base[i] = pciReadLong(tag, PCI_CMD_BASE_REG + i*4);
-    ptr->biosBase = pciReadLong(tag, PCI_CMD_BIOS_REG);
+    pci_device_cfg_read_u32( dev, & ptr->command, PCI_CMD_STAT_REG );
+
+    for ( i = 0; i < 6; i++ ) {
+	pci_device_cfg_read_u32( dev, & ptr->base[i], 
+				 PCI_CMD_BASE_REG + (i * 4) );
+    }
+
+    pci_device_cfg_read_u32( dev, & ptr->biosBase, PCI_CMD_BIOS_REG );
 }
 
 /* move to OS layer */
 static void
-restorePciState(PCITAG tag, pciSavePtr ptr)
+restorePciState( struct pci_device * dev, pciSavePtr ptr)
 {
     int i;
     
     /* disable card before setting anything */
-    pciSetBitsLong(tag, PCI_CMD_STAT_REG,
-		   PCI_CMD_MEM_ENABLE | PCI_CMD_IO_ENABLE , 0);
-    pciWriteLong(tag,PCI_CMD_BIOS_REG, ptr->biosBase);
-    for (i=0; i<6; i++)
-        pciWriteLong(tag, PCI_CMD_BASE_REG + i*4, ptr->base[i]);        
-    pciWriteLong(tag, PCI_CMD_STAT_REG, ptr->command);
+    pci_device_cfg_write_bits( dev, PCI_CMD_MEM_ENABLE | PCI_CMD_IO_ENABLE, 0,
+			       PCI_CMD_STAT_REG );
+
+    pci_device_cfg_write_u32( dev, & ptr->biosBase, PCI_CMD_BIOS_REG );
+
+    for ( i = 0; i < 6; i++ ) {
+	pci_device_cfg_write_u32( dev, & ptr->base[i], 
+				 PCI_CMD_BASE_REG + (i * 4) );
+    }
+
+    pci_device_cfg_write_u32( dev, & ptr->command, PCI_CMD_STAT_REG );
 }
 
 /* move to OS layer */
 static void
 savePciBusState(BusAccPtr ptr)
 {
-    PCITAG tag = ptr->busdep.pci.acc;
+    struct pci_device * const dev = ptr->busdep.pci.dev;
+    uint16_t temp;
+
+    pci_device_cfg_read_u16( dev, & temp, PCI_PCI_BRIDGE_CONTROL_REG );
+    ptr->busdep.pci.save.control = temp & ~PCI_PCI_BRIDGE_SECONDARY_RESET;
 
-    ptr->busdep.pci.save.control =
-	pciReadWord(tag, PCI_PCI_BRIDGE_CONTROL_REG) &
-	~PCI_PCI_BRIDGE_SECONDARY_RESET;
     /* Allow master aborts to complete normally on non-root buses */
-    if (ptr->busdep.pci.save.control & PCI_PCI_BRIDGE_MASTER_ABORT_EN)
-	pciWriteWord(tag, PCI_PCI_BRIDGE_CONTROL_REG,
-	    ptr->busdep.pci.save.control & ~PCI_PCI_BRIDGE_MASTER_ABORT_EN);
+    if ( ptr->busdep.pci.save.control & PCI_PCI_BRIDGE_MASTER_ABORT_EN ) {
+	temp = ptr->busdep.pci.save.control & ~PCI_PCI_BRIDGE_MASTER_ABORT_EN;
+	pci_device_cfg_read_u16( dev, & temp, PCI_PCI_BRIDGE_CONTROL_REG );
+    }
 }
 
 /* move to OS layer */
@@ -724,15 +529,16 @@ savePciBusState(BusAccPtr ptr)
 static void
 restorePciBusState(BusAccPtr ptr)
 {
-    PCITAG tag = ptr->busdep.pci.acc;
-    CARD16 ctrl;
+    struct pci_device * const dev = ptr->busdep.pci.dev;
+    uint16_t ctrl;
 
     /* Only restore the bits we've changed (and don't cause resets) */
-    ctrl = pciReadWord(tag, PCI_PCI_BRIDGE_CONTROL_REG);
+    pci_device_cfg_read_u16( dev, & ctrl, PCI_PCI_BRIDGE_CONTROL_REG );
+
     if ((ctrl ^ ptr->busdep.pci.save.control) & MASKBITS) {
 	ctrl &= ~(MASKBITS | PCI_PCI_BRIDGE_SECONDARY_RESET);
 	ctrl |= ptr->busdep.pci.save.control & MASKBITS;
-	pciWriteWord(tag, PCI_PCI_BRIDGE_CONTROL_REG, ctrl);
+	pci_device_cfg_write_u16( dev, & ctrl, PCI_PCI_BRIDGE_CONTROL_REG );
     }
 }
 #undef MASKBITS
@@ -763,922 +569,12 @@ restorePciDrvBusState(BusAccPtr ptr)
 
 
 static void
-disablePciBios(PCITAG tag)
-{
-    pciSetBitsLong(tag, PCI_CMD_BIOS_REG, PCI_CMD_BIOS_ENABLE, 0);
-}
-
-/* ????? */
-static void
-correctPciSize(memType base, memType oldsize, memType newsize,
-	       unsigned long type)
+disablePciBios(struct pci_device * dev)
 {
-    pciConfigPtr pcrp, *pcrpp;
-    pciVideoPtr pvp, *pvpp;
-    CARD32 *basep;
-    int i;
-    int old_bits = 0, new_bits = 0;
-
-    if (oldsize + 1) while (oldsize & 1) {
-	old_bits ++;
-	oldsize >>= 1;
-    }
-    if (newsize + 1) while (newsize & 1) {
-	new_bits ++;
-	newsize >>= 1;
-    }
-    
-    for (pcrpp = xf86PciInfo, pcrp = *pcrpp; pcrp; pcrp = *++(pcrpp)) {
-	
-	/* Only process devices with type 0 headers */
-	if ((pcrp->pci_header_type & 0x7f) != 0)
-	    continue;
-
-	basep = &pcrp->pci_base0;
-	for (i = 0; i < 6; i++) {
-	    if (basep[i] && (pcrp->basesize[i] == old_bits)) {
-		if ((((type & ResPhysMask) == ResIo) &&
-		     PCI_MAP_IS_IO(basep[i]) &&
-		     B2I(pcrp->tag,PCIGETIO(basep[i]) == base)) ||
-		    (((type & ResPhysMask) == ResMem) &&
-		     PCI_MAP_IS_MEM(basep[i]) &&
-		     (((!PCI_MAP_IS64BITMEM(basep[i])) &&
-		       (B2M(pcrp->tag,PCIGETMEMORY(basep[i])) == base))
-#if defined(LONG64) || defined(WORD64)
-		      ||
-		      (B2M(pcrp->tag,PCIGETMEMORY64(basep[i])) == base)
-#else
-		      ||
-		      (!basep[i+1]
-		       && (B2M(pcrp->tag,PCIGETMEMORY(basep[i])) == base))
-#endif 
-		     ))) {
-		    pcrp->basesize[i] = new_bits;
-		    break;	/* to next device */
-		}
-	    }
-	    if (PCI_MAP_IS64BITMEM(basep[i])) i++;
-	}
+    pci_device_cfg_write_bits(dev, PCI_CMD_BIOS_ENABLE, 0,
+			       PCI_CMD_BIOS_REG);
     }
 
-    if (xf86PciVideoInfo) {
-	for (pvpp = xf86PciVideoInfo, pvp = *pvpp; pvp; pvp = *(++pvpp)) {
-
-	    for (i = 0; i < 6; i++) {
-		if (pvp->size[i] == old_bits) {
-		    if ((((type & ResPhysMask) == ResIo) && pvp->ioBase[i]
-			 && (B2I(TAG(pvp),pvp->ioBase[i]) == base)) || 
-			(((type & ResPhysMask) == ResMem) && pvp->memBase[i] 
-			  && (B2M(TAG(pvp),pvp->memBase[i]) == base))) {
-			pvp->size[i] = new_bits;
-			break;	/* to next device */
-		    }
-		}
-	    }
-	}
-    }
-}
-
-/* ????? */
-static void
-removeOverlapsWithBridges(int busIndex, resPtr target)
-{
-    PciBusPtr pbp;
-    resPtr tmp,bridgeRes = NULL;
-    resRange range;
-
-    if (!target)
-	return;
-    
-    if (!ResCanOverlap(&target->val))
-	return;
-
-    range = target->val;
-    
-    for (pbp=xf86PciBus; pbp; pbp = pbp->next) {
-	if (pbp->primary == busIndex) {
-	    tmp = xf86DupResList(pbp->preferred_io);
-	    bridgeRes = xf86JoinResLists(tmp,bridgeRes);
-	    tmp = xf86DupResList(pbp->preferred_mem);
-	    bridgeRes = xf86JoinResLists(tmp,bridgeRes);
-	    tmp = xf86DupResList(pbp->preferred_pmem);
-	    bridgeRes = xf86JoinResLists(tmp,bridgeRes);
-	}
-    }
-    
-    RemoveOverlaps(target, bridgeRes, TRUE, TRUE);
-    if (range.rEnd > target->block_end) {
-	correctPciSize(range.rBegin, range.rEnd - range.rBegin,
-		       target->block_end - target->block_begin,
-		       target->res_type);
-	xf86MsgVerb(X_INFO, 3,
-	    "PCI %s resource overlap reduced 0x%08lx from 0x%08lx to 0x%08lx\n",
-	    ((target->res_type & ResPhysMask) == ResMem) ?  "Memory" : "I/O",
-	    range.rBegin, range.rEnd, target->block_end);
-    }
-    xf86FreeResList(bridgeRes);
-}
-    
-/* ????? */
-static void
-xf86GetPciRes(resPtr *activeRes, resPtr *inactiveRes)
-{
-    pciConfigPtr pcrp, *pcrpp;
-    pciVideoPtr pvp, *pvpp;
-    CARD32 *basep;
-    int i;
-    resPtr pRes, tmp;
-    resRange range;
-    long resMisc;
-
-    if (activeRes)
-	*activeRes = NULL;
-    if (inactiveRes)
-	*inactiveRes = NULL;
-
-    if (!activeRes || !inactiveRes || !xf86PciInfo)
-	return;
-
-    if (xf86PciVideoInfo)
-	for (pvpp = xf86PciVideoInfo, pvp = *pvpp; pvp; pvp = *(++pvpp)) {
-	    resPtr *res;
-
-	    if (PCINONSYSTEMCLASSES(pvp->class, pvp->subclass)) 
-		resMisc = ResBios;
-	    else 
-		resMisc = 0;
-	    
-	    if (((pciConfigPtr)pvp->thisCard)->pci_command
-		& (PCI_CMD_IO_ENABLE | PCI_CMD_MEM_ENABLE))
-		res = activeRes;
-	    else
-		res = inactiveRes;
-	    
-	    if (!pvp->validSize)
-		resMisc |= ResEstimated;
-	    
-	    for (i = 0; i < 6; i++) {
-		if (pvp->ioBase[i] &&
-		    (pvp->ioBase[i] < (memType)(-1 << pvp->size[i]))) {
-		    PV_I_RANGE(range,pvp,i,ResExcIoBlock | resMisc);
-		    tmp = xf86AddResToList(NULL, &range, -1);
-		    removeOverlapsWithBridges(pvp->bus,tmp);
-		    *res = xf86JoinResLists(tmp,*res);
-		} else if (pvp->memBase[i] &&
-		    (pvp->memBase[i] < (memType)(-1 << pvp->size[i]))) {
-		    PV_M_RANGE(range, pvp,i, ResExcMemBlock | resMisc);
-		    tmp = xf86AddResToList(NULL, &range, -1);
-		    removeOverlapsWithBridges(pvp->bus,tmp);
-		    *res = xf86JoinResLists(tmp,*res);
-		}
-	    }
-	    /* FIXME!!!: Don't use BIOS resources for overlap
-	     * checking but reserve them!
-	     */
-	    if (pvp->biosBase &&
-		(pvp->biosBase < (memType)(-1 << pvp->biosSize))) {
-		PV_B_RANGE(range, pvp, ResExcMemBlock | resMisc);
-		tmp = xf86AddResToList(NULL, &range, -1);
-		removeOverlapsWithBridges(pvp->bus,tmp);
-		*res = xf86JoinResLists(tmp,*res);
-	    }
-	}
-
-    for (pcrpp = xf86PciInfo, pcrp = *pcrpp; pcrp; pcrp = *++(pcrpp)) {
-	resPtr *res;
-	const CARD8 baseclass = pcrp->pci_base_class;
-	const CARD8 subclass = pcrp->pci_sub_class;
-
-	
-	if (PCIINFOCLASSES(baseclass, subclass))
-	    continue;
-	
-	/* Only process devices with type 0 headers */
-	if ((pcrp->pci_header_type & 0x7f) != 0)
-	    continue;
-
-	if (!pcrp->minBasesize)
-	    resMisc = ResEstimated;
-	else
-	    resMisc = 0;
-
-	/*
-	 * Allow resources allocated to host bridges to overlap.  Perhaps, this
-	 * needs to be specific to AGP-capable chipsets.  AGP "memory"
-	 * sometimes gets allocated within the range routed to the AGP bus.
-	 */
-	if ((baseclass == PCI_CLASS_BRIDGE) &&
-	    (subclass == PCI_SUBCLASS_BRIDGE_HOST))
-	    resMisc |= ResOverlap;
-	
-	basep = &pcrp->pci_base0;
-	for (i = 0; i < 6; i++) {
-	    if (basep[i]) {
-	        if (PCI_MAP_IS_IO(basep[i])) {
-		    if (pcrp->pci_command & PCI_CMD_IO_ENABLE)
-			res = activeRes;
-		    else
-			res = inactiveRes;
-		    P_I_RANGE(range, pcrp->tag, PCIGETIO(basep[i]),
-			      pcrp->basesize[i], ResExcIoBlock | resMisc)
-		} else if (!PCI_MAP_IS64BITMEM(basep[i])) {
-		    if (pcrp->pci_command & PCI_CMD_MEM_ENABLE)
-			res = activeRes;
-		    else
-			res = inactiveRes;
-		    P_M_RANGE(range, pcrp->tag, PCIGETMEMORY(basep[i]),
-			      pcrp->basesize[i], ResExcMemBlock | resMisc)
-		} else {
-		    i++;
-#if defined(LONG64) || defined(WORD64)
-		    P_M_RANGE(range,pcrp->tag,PCIGETMEMORY64(basep[i - 1]),
-			      pcrp->basesize[i - 1], ResExcMemBlock | resMisc)
-#else
-		    if (basep[i])
-		      continue;
-		    P_M_RANGE(range, pcrp->tag, PCIGETMEMORY(basep[i - 1]),
-			      pcrp->basesize[i - 1], ResExcMemBlock | resMisc)
-#endif
-		    if (pcrp->pci_command & PCI_CMD_MEM_ENABLE)
-			res = activeRes;
-		    else
-			res = inactiveRes;
-		}
-		if (range.rBegin) { /* catch cases where PCI base is unset */
-		    tmp = xf86AddResToList(NULL, &range, -1);
-		    removeOverlapsWithBridges(pcrp->busnum,tmp);
-		    *res = xf86JoinResLists(tmp,*res);
-		}
-	    }
-	}
-
-        /* Ignore disabled non-video ROMs */
-	if ((pcrp->pci_command & PCI_CMD_MEM_ENABLE) &&
-	    (pcrp->pci_baserom & PCI_MAP_ROM_DECODE_ENABLE)) {
-	    P_M_RANGE(range,pcrp->tag,PCIGETROM(pcrp->pci_baserom),
-		  pcrp->basesize[6], ResExcMemBlock | resMisc);
-	    if (range.rBegin) {
-		tmp = xf86AddResToList(NULL, &range, -1);
-		removeOverlapsWithBridges(pcrp->busnum, tmp);
-		*activeRes = xf86JoinResLists(tmp, *activeRes);
-	    }
-	}
-    }
-
-    if (*activeRes) {
-	xf86MsgVerb(X_INFO, 3, "Active PCI resource ranges:\n");
-	xf86PrintResList(3, *activeRes);
-    }
-    if (*inactiveRes) {
-	xf86MsgVerb(X_INFO, 3, "Inactive PCI resource ranges:\n");
-	xf86PrintResList(3, *inactiveRes);
-    }
-
-    /*
-     * Adjust ranges based on the assumption that there are no real
-     * overlaps in the PCI base allocations.  This assumption should be
-     * reasonable in most cases.  It may be possible to refine the
-     * approximated PCI base sizes by considering bus mapping information
-     * from PCI-PCI bridges.
-     */
-
-    if (*activeRes) {
-	/* Check for overlaps */
-	for (pRes = *activeRes; pRes; pRes = pRes->next) {
-	    if (ResCanOverlap(&pRes->val)) {
-		range = pRes->val;
-
-		RemoveOverlaps(pRes, *activeRes, TRUE, TRUE);
-		RemoveOverlaps(pRes, *inactiveRes, TRUE, 
-		    (xf86Info.estimateSizesAggressively > 0));
-		
-		if (range.rEnd > pRes->block_end) {
-		    correctPciSize(range.rBegin, range.rEnd - range.rBegin,
-				   pRes->block_end - pRes->block_begin,
-				   pRes->res_type);
-		    xf86MsgVerb(X_INFO, 3,
-				"PCI %s resource overlap reduced 0x%08lx"
-				" from 0x%08lx to 0x%08lx\n",
-				((pRes->res_type & ResPhysMask) == ResMem) ?
-				 "Memory" : "I/O",
-				range.rBegin, range.rEnd, pRes->block_end);
-		}
-	    }
-	}
-	xf86MsgVerb(X_INFO, 3,
-	    "Active PCI resource ranges after removing overlaps:\n");
-	xf86PrintResList(3, *activeRes);
-    }
-
-    if (*inactiveRes) {
-	/* Check for overlaps */
-	for (pRes = *inactiveRes; pRes; pRes = pRes->next) {
-	    if (ResCanOverlap(&pRes->val)) {
-		range = pRes->val;
-
-		RemoveOverlaps(pRes, *activeRes, TRUE,
-		    (xf86Info.estimateSizesAggressively > 1));
-		RemoveOverlaps(pRes, *inactiveRes, TRUE,
-		    (xf86Info.estimateSizesAggressively > 1));
-		
-		if (range.rEnd > pRes->block_end) {
-		    correctPciSize(range.rBegin, range.rEnd - range.rBegin,
-				   pRes->block_end - pRes->block_begin,
-				   pRes->res_type);
-		    xf86MsgVerb(X_INFO, 3,
-				"PCI %s resource overlap reduced 0x%08lx"
-				" from 0x%08lx to 0x%08lx\n",
-				((pRes->res_type & ResPhysMask) == ResMem) ?
-				 "Memory" : "I/O",
-				range.rBegin, range.rEnd, pRes->block_end);
-		}
-		
-	    }
-	}
-	xf86MsgVerb(X_INFO, 3,
-	    "Inactive PCI resource ranges after removing overlaps:\n");
-	xf86PrintResList(3, *inactiveRes);
-    }
-}
-
-resPtr
-ResourceBrokerInitPci(resPtr *osRes)
-{
-    resPtr activeRes, inactiveRes;
-    resPtr tmp;
-    
-    /* Get bus-specific system resources (PCI) */
-    xf86GetPciRes(&activeRes, &inactiveRes);
-
-    /*
-     * Adjust OS-reported resource ranges based on the assumption that there
-     * are no overlaps with the PCI base allocations.  This should be a good
-     * assumption because writes to PCI address space won't be routed directly
-     * to host memory.
-     */
-
-    for (tmp = *osRes; tmp; tmp = tmp->next) 
-	RemoveOverlaps(tmp, activeRes, FALSE, TRUE);
-
-    xf86MsgVerb(X_INFO, 3, "OS-reported resource ranges after removing"
-		" overlaps with PCI:\n");
-    xf86PrintResList(3, *osRes);
-
-    pciAvoidRes = xf86AddRangesToList(pciAvoidRes,PciAvoid,-1);
-    for (tmp = pciAvoidRes; tmp; tmp = tmp->next) 
-	RemoveOverlaps(tmp, activeRes, FALSE, TRUE);
-    tmp = xf86DupResList(*osRes);
-    pciAvoidRes = xf86JoinResLists(pciAvoidRes,tmp);
-    
-    return (xf86JoinResLists(activeRes,inactiveRes));
-}
-
-
-/*
- * PCI Resource modification
- */
-static Bool
-fixPciResource(int prt, memType alignment, pciVideoPtr pvp, unsigned long type)
-{
-    int  res_n;
-    memType *p_base;
-    int *p_size;
-    unsigned char p_type;
-    resPtr AccTmp = NULL;
-    resPtr orgAcc = NULL;
-    resPtr *pAcc = &AccTmp;
-    resPtr avoid = NULL;
-    resRange range;
-    resPtr resSize = NULL;
-    resPtr w_tmp, w = NULL, w_2nd = NULL;
-    PCITAG tag;
-    PciBusPtr pbp = xf86PciBus;
-    pciConfigPtr pcp;
-    resPtr tmp;
-    
-    if (!pvp) return FALSE;
-    tag = pciTag(pvp->bus,pvp->device,pvp->func);
-    pcp = pvp->thisCard;
-
-    type &= ResAccMask;
-    if (!type) type = ResShared;
-    if (prt < 6) {
-	if (pvp->memBase[prt]) {
-	    type |= ResMem;
-	    res_n = prt;
-	    p_base = &(pvp->memBase[res_n]);
-	    p_size = &(pvp->size[res_n]);
-	    p_type = pvp->type[res_n];
-	    if (!PCI_MAP_IS64BITMEM(pvp->type[res_n])) {
-	      PCI_M_RANGE(range,tag,0,0xffffffff,ResExcMemBlock);
-	      resSize = xf86AddResToList(resSize,&range,-1);
-	    }
-	} else if (pvp->ioBase[prt]){
-	    type |= ResIo;
-	    res_n = prt;
-	    p_base = &(pvp->ioBase[res_n]);
-	    p_size = &(pvp->size[res_n]);
-	    p_type = pvp->type[res_n];
-	    PCI_I_RANGE(range, tag, 0, 0xffffffff, ResExcIoBlock);
-	    resSize = xf86AddResToList(resSize, &range, -1);
-	} else return FALSE;
-    } else if (prt == 6) {
-	type |= ResMem;
-	res_n = 0xff;	/* special flag for bios rom */
-	p_base = &(pvp->biosBase);
-	p_size = &(pvp->biosSize);
-	/* XXX This should also include the PCI_MAP_MEMORY_TYPE_MASK part */
-	p_type = 0;
-	PCI_M_RANGE(range,tag,0,0xffffffff,ResExcMemBlock);
-	resSize = xf86AddResToList(resSize,&range,-1);
-    } else return FALSE;
-
-    if (! *p_base) return FALSE;
-    
-    type |= (range.type & ResDomain) | ResBlock;
-    
-    /* setup avoid: PciAvoid is bus range: convert later */
-    avoid = xf86DupResList(pciAvoidRes);
-
-    while (pbp) {
-	if (pbp->secondary == pvp->bus) {
-	    if ((type & ResPhysMask) == ResMem) {
-		if (((p_type & PCI_MAP_MEMORY_CACHABLE)
-#if 0 /*EE*/
-		     || (res_n == 0xff)/* bios should also be prefetchable */
-#endif
-		     )) {
-		    if (pbp->preferred_pmem)
-			w = xf86FindIntersectOfLists(pbp->preferred_pmem,
-						     ResRange);
-		    else if (pbp->pmem)
-			w = xf86FindIntersectOfLists(pbp->pmem,ResRange);
-		    
-		    if (pbp->preferred_mem) 
-			w_2nd = xf86FindIntersectOfLists(pbp->preferred_mem,
-							 ResRange);
-		    else if (pbp->mem) 
-			w_2nd = xf86FindIntersectOfLists(pbp->mem,
-							 ResRange);
-		} else {
-		    if (pbp->preferred_mem)
-			w = xf86FindIntersectOfLists(pbp->preferred_mem,
-						     ResRange);
-		    else if (pbp->mem)
-			w = xf86FindIntersectOfLists(pbp->mem,ResRange);
-		}
-	    } else {
-		if (pbp->preferred_io) 
-		    w = xf86FindIntersectOfLists(pbp->preferred_io,ResRange);
-		if (pbp->io) 
-		    w = xf86FindIntersectOfLists(pbp->io,ResRange);
-	    }
-	} else if (pbp->primary == pvp->bus) {
-	    if ((type & ResPhysMask) == ResMem) {
-		tmp = xf86DupResList(pbp->preferred_pmem);
-		avoid = xf86JoinResLists(avoid, tmp);
-		tmp = xf86DupResList(pbp->preferred_mem);
-		avoid = xf86JoinResLists(avoid, tmp);
-	    } else {
-		tmp = xf86DupResList(pbp->preferred_io);
-		avoid = xf86JoinResLists(avoid, tmp);
-	    }
-	}	
-	pbp = pbp->next;
-    }
-    
-    /* convert bus based entries in avoid list to host base */
-    pciConvertListToHost(pvp->bus,pvp->device,pvp->func, avoid);
-    
-    if (!w)
-	w = xf86DupResList(ResRange);
-    xf86MsgVerb(X_INFO, 3, "window:\n");
-    xf86PrintResList(3, w);
-    xf86MsgVerb(X_INFO, 3, "resSize:\n");
-    xf86PrintResList(3, resSize);
-    
-    if (resSize) {
-	w_tmp = w;
-	w = xf86FindIntersectOfLists(w,resSize);
-	xf86FreeResList(w_tmp);
-	if (w_2nd) {
-	    w_tmp = w_2nd;
-	    w_2nd = xf86FindIntersectOfLists(w_2nd,resSize);
-	    xf86FreeResList(w_tmp);
-	}
-	xf86FreeResList(resSize);
-    }
-    xf86MsgVerb(X_INFO, 3, "window fixed:\n");
-    xf86PrintResList(3, w);
-
-    if (!alignment)
-	alignment = (1 << (*p_size)) - 1;
-    
-    /* Access list holds bios resources -- remove this one */
-#ifdef NOTYET
-    AccTmp = xf86DupResList(Acc);
-    while ((*pAcc)) {
-	if ((((*pAcc)->res_type & (type & ~ResAccMask))
-	     == (type & ~ResAccMask))
-	    && ((*pAcc)->block_begin == (B2H(tag,(*p_base),type)))
-	    && ((*pAcc)->block_end == (B2H(tag,
-					   (*p_base)+SIZE(*p_size),type)))) {
-	    resPtr acc_tmp = (*pAcc)->next;
-	    xfree((*pAcc));
-	    (*pAcc) = acc_tmp;
-	    break;
-	} else
-	    pAcc = &((*pAcc)->next);
-    }
-    /* check if we really need to fix anything */
-    P_X_RANGE(range,tag,(*p_base),(*p_base) + SIZE((*p_size)),type);
-    if (!ChkConflict(&range,avoid,SETUP)
-	&& !ChkConflict(&range,AccTmp,SETUP)
-	&& ((B2H(tag,(*p_base),type) & PCI_SIZE(type,tag,alignment)
-	     == range->block_begin)
-	&& ((xf86IsSubsetOf(range,w)
-	    || (w_2nd && xf86IsSubsetOf(range,w_2n))))) {
-#ifdef DEBUG
-	    ErrorF("nothing to fix\n");
-#endif
-	xf86FreeResList(AccTmp);
-	xf86FreeResList(w);
-	xf86FreeResList(w_2nd);
-	xf86FreeResList(avoid);
-	return TRUE;
-    }
-#ifdef DEBUG
-	ErrorF("removing old resource\n");
-#endif
-    orgAcc = Acc;
-    Acc = AccTmp;
-#else
-    orgAcc = xf86DupResList(Acc);
-    pAcc = &Acc;
-    while (*pAcc) {
-	if ((((*pAcc)->res_type & (ResTypeMask|ResExtMask)) ==
-	     (type & ~ResAccMask))
-	    && ((*pAcc)->block_begin == B2H(tag,(*p_base),type))
-	    && ((*pAcc)->block_end == B2H(tag,(*p_base) + SIZE(*p_size),
-					  type))) {
-#ifdef DEBUG
-	    ErrorF("removing old resource\n");
-#endif
-	    tmp = *pAcc;
-	    *pAcc = (*pAcc)->next;
-	    tmp->next = NULL;
-	    xf86FreeResList(tmp);
-	    break;
-	} else
-	    pAcc = &((*pAcc)->next);
-    }
-#endif
-    
-#ifdef DEBUG
-    ErrorF("base: 0x%lx alignment: 0x%lx host alignment: 0x%lx size[bit]: 0x%x\n",
-	   (*p_base),alignment,PCI_SIZE(type,tag,alignment),(*p_size));
-    xf86MsgVerb(X_INFO, 3, "window:\n");
-    xf86PrintResList(3, w);
-    if (w_2nd)
-	xf86MsgVerb(X_INFO, 3, "2nd window:\n");
-    xf86PrintResList(3, w_2nd);
-    xf86ErrorFVerb(3,"avoid:\n");
-    xf86PrintResList(3,avoid);
-#endif
-    w_tmp = w;
-    while (w) {
-	if ((type & ResTypeMask) == (w->res_type & ResTypeMask)) {
-#ifdef DEBUG
-	    ErrorF("block_begin: 0x%lx block_end: 0x%lx\n",w->block_begin,
-		   w->block_end);
-#endif
-	    range = xf86GetBlock(type,PCI_SIZE(type,tag,alignment + 1),
-				 w->block_begin, w->block_end,
-				 PCI_SIZE(type,tag,alignment),avoid);
-	    if (range.type != ResEnd)
-		break;
-	}
-	w = w->next;
-    }
-    xf86FreeResList(w_tmp);
-    /* if unsuccessful and memory prefetchable try non-prefetchable */
-    if (range.type == ResEnd && w_2nd) {
-	w_tmp = w_2nd;
-	while (w_2nd) {
-	    if ((type & ResTypeMask) == (w_2nd->res_type & ResTypeMask)) {
-#ifdef DEBUG
-	    ErrorF("block_begin: 0x%lx block_end: 0x%lx\n",w_2nd->block_begin,
-		   w_2nd->block_end);
-#endif
-	    range = xf86GetBlock(type,PCI_SIZE(type,tag,alignment + 1),
-				 w_2nd->block_begin, w_2nd->block_end,
-				 PCI_SIZE(type,tag,alignment),avoid);
-		if (range.type != ResEnd)
-		    break;
-	    }
-	w_2nd = w_2nd->next;
-	}
-	xf86FreeResList(w_tmp);
-    }
-    xf86FreeResList(avoid);
-
-    if (range.type == ResEnd) {
-	xf86MsgVerb(X_ERROR,3,"Cannot find a replacement memory range\n");
-	xf86FreeResList(Acc);
-	Acc = orgAcc;
-	return FALSE;
-    }
-    xf86FreeResList(orgAcc);
-#ifdef DEBUG
-    ErrorF("begin: 0x%lx, end: 0x%lx\n",range.a,range.b);
-#endif
-    
-    (*p_size) = 0;
-    while (alignment >> (*p_size))
-	(*p_size)++;
-    (*p_base) = H2B(tag,range.rBegin,type);
-#ifdef DEBUG
-    ErrorF("New PCI res %i base: 0x%lx, size: 0x%lx, type %s\n",
-	   res_n,(*p_base),(1 << (*p_size)),
-	   ((type & ResPhysMask) == ResMem) ? "Mem" : "Io");
-#endif
-    if (res_n != 0xff) {
-	if ((type & ResPhysMask) == ResMem)
-	    pvp->memBase[prt] = range.rBegin;
-	else
-	    pvp->ioBase[prt] = range.rBegin;
-	((CARD32 *)(&(pcp->pci_base0)))[res_n] =
-	    (CARD32)(*p_base) | (CARD32)(p_type);
-	pciWriteLong(tag, PCI_CMD_BASE_REG + res_n * sizeof(CARD32),
-		     ((CARD32 *)(&(pcp->pci_base0)))[res_n]);
-	if (PCI_MAP_IS64BITMEM(p_type)) {
-#if defined(LONG64) || defined(WORD64)
-	    ((CARD32 *)(&(pcp->pci_base0)))[res_n + 1] =
-		(CARD32)(*p_base >> 32);
-	    pciWriteLong(tag, PCI_CMD_BASE_REG + (res_n + 1) * sizeof(CARD32),
-	    		 ((CARD32 *)(&(pcp->pci_base0)))[res_n + 1]);
-#else
-	    ((CARD32 *)(&(pcp->pci_base0)))[res_n + 1] = 0;
-	    pciWriteLong(tag, PCI_CMD_BASE_REG + (res_n + 1) * sizeof(CARD32),
-			 0);
-#endif
-	}
-    } else {
-	pvp->biosBase = range.rBegin;
-	pcp->pci_baserom = (pciReadLong(tag,PCI_CMD_BIOS_REG) & 0x01) |
-	    (CARD32)(*p_base);
-	pciWriteLong(tag, PCI_CMD_BIOS_REG, pcp->pci_baserom);
-    }
-    /* @@@ fake BIOS allocated resource */
-    range.type |= ResBios;
-    Acc = xf86AddResToList(Acc, &range,-1);
-    
-    return TRUE;
-    
-}
-
-_X_EXPORT Bool
-xf86FixPciResource(int entityIndex, int prt, memType alignment,
-		   unsigned long type)
-{
-    pciVideoPtr pvp = xf86GetPciInfoForEntity(entityIndex);
-    return fixPciResource(prt, alignment, pvp, type);
-}
-
-_X_EXPORT resPtr
-xf86ReallocatePciResources(int entityIndex, resPtr pRes)
-{
-    pciVideoPtr pvp = xf86GetPciInfoForEntity(entityIndex);
-    resPtr pBad = NULL,pResTmp;
-    unsigned int prt = 0;
-    int i;
-    
-    if (!pvp) return pRes;
-
-    while (pRes) {
-	switch (pRes->res_type & ResPhysMask) {
-	case ResMem:
-	    if (pRes->block_begin == B2M(TAG(pvp),pvp->biosBase) &&
-		pRes->block_end == B2M(TAG(pvp),pvp->biosBase
-				       + SIZE(pvp->biosSize)))
-		prt = 6;
-	    else for (i = 0 ; i < 6; i++) 
-		if ((pRes->block_begin == B2M(TAG(pvp),pvp->memBase[i]))
-		    && (pRes->block_end == B2M(TAG(pvp),pvp->memBase[i]
-					      + SIZE(pvp->size[i])))) {
-		    prt = i;
-		    break;
-		}
-	    break;
-	case ResIo:
-	    for (i = 0 ; i < 6; i++) 
-		if (pRes->block_begin == B2I(TAG(pvp),pvp->ioBase[i])
-		    && pRes->block_end == B2I(TAG(pvp),pvp->ioBase[i]
-		    + SIZE(pvp->size[i]))) {
-		    prt = i;
-		    break;
-		}
-	    break;
-	}
-
-	if (!prt) return pRes;
-
-	pResTmp = pRes->next;
-	if (! fixPciResource(prt, 0, pvp, pRes->res_type)) {
-	    pRes->next = pBad;
-	    pBad = pRes;
-	} else
-	    xfree(pRes);
-	
-	pRes = pResTmp;
-    }
-    return pBad;
-}
-
-/*
- * BIOS releated
- */
-static resPtr
-getOwnResources(pciVideoPtr pvp, resPtr mem)
-{
-    resRange range;
-    int i;
-    /* Make sure we don't conflict with our own mem resources */
-    for (i = 0; i < 6; i++) {
-	if (!pvp->memBase[i])
-	    continue;
-	P_M_RANGE(range,TAG(pvp),pvp->memBase[i],pvp->size[i],
-		  ResExcMemBlock);
-	mem = xf86AddResToList(mem,&range,-1);
-    }
-    return mem;
-}
-
-static void
-getPciRangesForMapping(pciVideoPtr pvp,  resPtr *map, resPtr *avoid)
-{
-    PciBusPtr pbp;
-    resPtr tmp;
-    
-    *avoid = xf86DupResList(pciAvoidRes);
-
-    pbp = xf86PciBus;
-    while (pbp) {
-	if (pbp->secondary == pvp->bus) {
-	    if (pbp->preferred_pmem)
-		tmp = xf86DupResList(pbp->preferred_pmem);
-	    else
-		tmp = xf86DupResList(pbp->pmem);
-	    *map = xf86JoinResLists(*map,tmp);
-	    if (pbp->preferred_mem)
-		tmp = xf86DupResList(pbp->preferred_mem);
-	    else
-		tmp = xf86DupResList(pbp->mem);
-	    *map = xf86JoinResLists(*map,tmp);
-	    tmp = *map;
-	    while (tmp) {
-		tmp->block_end = min(tmp->block_end,PCI_MEM32_LENGTH_MAX);
-		tmp = tmp->next;
-	    }
-	} else if ((pbp->primary == pvp->bus) &&
-		   (pbp->secondary >= 0) &&
-		   (pbp->primary != pbp->secondary)) {
-	    tmp = xf86DupResList(pbp->preferred_pmem);
-	    *avoid = xf86JoinResLists(*avoid, tmp);
-	    tmp = xf86DupResList(pbp->pmem);
-	    *avoid = xf86JoinResLists(*avoid, tmp);
-	    tmp = xf86DupResList(pbp->preferred_mem);
-	    *avoid = xf86JoinResLists(*avoid, tmp);
-	    tmp = xf86DupResList(pbp->mem);
-	    *avoid = xf86JoinResLists(*avoid, tmp);
-	}
-	pbp = pbp->next;
-    }	
-    pciConvertListToHost(pvp->bus,pvp->device,pvp->func, *avoid);
-    pciConvertListToHost(pvp->bus,pvp->device,pvp->func, *map);
-}
-
-static memType
-findPciRange(PCITAG tag, resPtr m, resPtr avoid, CARD32 size)
-{
-    resRange range;
-    CARD32 alignment = (1 << size) - 1;
-    
-    while (m) {
-	range = xf86GetBlock(RANGE_TYPE(ResExcMemBlock, xf86GetPciDomain(tag)),
-			     PCI_SIZE(ResMem, tag, 1 << size),
-			     m->block_begin, m->block_end,
-			     PCI_SIZE(ResMem, tag, alignment), 
-			     avoid);
-	if (range.type != ResEnd) {
-	    return  M2B(tag, range.rBase);
-	}
-	m = m->next;
-    }
-    return 0;
-}
-
-pciVideoPtr
-getPciVideoPtr(tag)
-{
-    int n = 0;
-
-    pciVideoPtr pvp = NULL;
-    if (!xf86PciVideoInfo) return 0;
-    
-    while ((pvp = xf86PciVideoInfo[n++])) {
-	if (pciTag(pvp->bus,pvp->device,pvp->func) == tag)
-	    return pvp;
-    }
-    return NULL;
-}
-
-memType
-getValidBIOSBase(PCITAG tag, int num)
-{
-    pciVideoPtr pvp = NULL;
-    memType ret;
-    CARD32 biosSize;
-    resPtr mem = NULL;
-    resPtr avoid = NULL, m = NULL;
-    resRange range;
-    
-    pvp = getPciVideoPtr(tag);
-    
-    if (!pvp) return 0;
-
-    biosSize = pvp->biosSize;
-
-    if (biosSize > 24)
-	biosSize = 24;
-
-    switch ((romBaseSource)num) {
-    case ROM_BASE_PRESET:
-	return 0; /* This should not happen */
-    case ROM_BASE_BIOS:
-	/* In some cases the BIOS base register contains the size mask */
-	if ((memType)(-1 << biosSize) == PCIGETROM(pvp->biosBase))
-	    return 0;
-	mem = getOwnResources(pvp,mem);
-	P_M_RANGE(range, tag, pvp->biosBase,biosSize,ResExcMemBlock);
-	ret = pvp->biosBase;
-	break;
-    case ROM_BASE_MEM0:
-    case ROM_BASE_MEM1:
-    case ROM_BASE_MEM2:
-    case ROM_BASE_MEM3:
-    case ROM_BASE_MEM4:
-    case ROM_BASE_MEM5:
-	if (!pvp->memBase[num] || (pvp->size[num] < biosSize))
-	    return 0;
-	P_M_RANGE(range, tag ,pvp->memBase[num],biosSize,
-		  ResExcMemBlock);
-	ret = pvp->memBase[num];
-	break;
-    case ROM_BASE_FIND:
-	ret = 0;
-	break;
-    default:
-	return 0; /* This should not happen */
-    }
-
-    /* Now find the ranges for validation */
-    getPciRangesForMapping(pvp,&m,&avoid);
-    
-    if (!ret) {
-	/* Return a possible window */
-	ret = findPciRange(tag,m,avoid,biosSize);
-    } else {
-#if !defined(__ia64__) /* on ia64, trust the kernel, don't look for overlaps */
-	if (mem)
-	    pciConvertListToHost(pvp->bus,pvp->device,pvp->func, mem);
-	if (!xf86IsSubsetOf(range, m) || 
-	    ChkConflict(&range, avoid, SETUP) 
-	    || (mem && ChkConflict(&range, mem, SETUP))) 
-	    ret = 0;
-#endif 
-    }
-
-    xf86FreeResList(avoid);
-    xf86FreeResList(m);
-    return ret;
-}
-
-memType
-getEmptyPciRange(PCITAG tag, int base_reg)
-{
-    resPtr avoid = NULL, m = NULL;
-    memType ret;
-
-    pciVideoPtr pvp = getPciVideoPtr(tag);
-    if (!pvp) return 0;
-    getPciRangesForMapping(pvp,&m,&avoid);
-    ret = findPciRange(tag,m,avoid,pvp->size[base_reg]);
-    xf86FreeResList(avoid);
-    xf86FreeResList(m);
-
-    return ret;
-}
 
 /*
  * xf86Bus.c interface
@@ -1687,26 +583,6 @@ getEmptyPciRange(PCITAG tag, int base_reg)
 void
 xf86PciProbe(void)
 {
-    /*
-     * Initialise the pcidata entry points.
-     */
-#ifdef XFree86LOADER
-    xf86SetupPciIds = (ScanPciSetupProcPtr)LoaderSymbol("ScanPciSetupPciIds");
-    xf86ClosePciIds = (ScanPciCloseProcPtr)LoaderSymbol("ScanPciClosePciIds");
-    xf86FindPciNamesByDevice =
-	(ScanPciFindByDeviceProcPtr)LoaderSymbol("ScanPciFindPciNamesByDevice");
-    xf86FindPciNamesBySubsys =
-	(ScanPciFindBySubsysProcPtr)LoaderSymbol("ScanPciFindPciNamesBySubsys");
-#else
-    xf86SetupPciIds = ScanPciSetupPciIds;
-    xf86ClosePciIds = ScanPciClosePciIds;
-    xf86FindPciNamesByDevice = ScanPciFindPciNamesByDevice;
-    xf86FindPciNamesBySubsys = ScanPciFindPciNamesBySubsys;
-#endif
-
-    if (!xf86SetupPciIds())
-	FatalError("xf86SetupPciIds() failed\n");
-
     FindPCIVideoInfo();
 }
 
@@ -1766,8 +642,14 @@ xf86GetPciBridgeInfo(void)
 
     /* Add each bridge */
     for (pcrpp = xf86PciInfo, pcrp = *pcrpp; pcrp; pcrp = *(++pcrpp)) {
+	struct pci_device * const dev = 
+	  pci_device_find_by_slot( PCI_DOM_FROM_BUS( pcrp->busnum ),
+				   PCI_BUS_NO_DOMAIN( pcrp->busnum ),
+				   pcrp->devnum, pcrp->funcnum );
+
 	if (pcrp->busnum > MaxBus)
 	    MaxBus = pcrp->busnum;
+
 	if ( pcrp->pci_base_class == PCI_CLASS_BRIDGE ) {
 	    const int sub_class = pcrp->pci_sub_class;
 
@@ -1818,6 +700,7 @@ xf86GetPciBridgeInfo(void)
 		*pnPciBus = PciBus = xnfcalloc(1, sizeof(PciBusRec));
 		pnPciBus = &PciBus->next;
 
+		PciBus->dev = dev;
 		PciBus->primary = primary;
 		PciBus->secondary = secondary;
 		PciBus->subordinate = subordinate;
@@ -1831,7 +714,7 @@ xf86GetPciBridgeInfo(void)
 		/* The Intel bridges don't report as transparent
 		   but guess what they are - from Linux kernel - airlied */
 		if ((pcrp->pci_vendor == PCI_VENDOR_INTEL) && 
-		   ((pcrp->pci_device & 0xff00) == 0x2400)) {
+		   ((pcrp->_pci_device & 0xff00) == 0x2400)) {
 			xf86MsgVerb(X_INFO, 3, "Intel Bridge workaround enabled\n");
 			PciBus->interface = PCI_IF_BRIDGE_PCI_SUBTRACTIVE;
 		} else {
@@ -1967,6 +850,7 @@ xf86GetPciBridgeInfo(void)
 		*pnPciBus = PciBus = xnfcalloc(1, sizeof(PciBusRec));
 		pnPciBus = &PciBus->next;
 
+		PciBus->dev = dev;
 		PciBus->primary = primary;
 		PciBus->secondary = secondary;
 		PciBus->subordinate = subordinate;
@@ -2096,6 +980,7 @@ xf86GetPciBridgeInfo(void)
 	    case PCI_SUBCLASS_BRIDGE_MC:
 		*pnPciBus = PciBus = xnfcalloc(1, sizeof(PciBusRec));
 		pnPciBus = &PciBus->next;
+		PciBus->dev = dev;
 		PciBus->primary = pcrp->busnum;
 		PciBus->secondary = PciBus->subordinate = -1;
 		PciBus->brbus = pcrp->busnum;
@@ -2130,7 +1015,7 @@ xf86GetPciBridgeInfo(void)
 		*pnPciBus = PciBus = xnfcalloc(1, sizeof(PciBusRec));
 		pnPciBus = &PciBus->next;
 
-
+		PciBus->dev = dev;
 		PciBus->primary = PciBus->secondary = secondary;
 		PciBus->subordinate = pciNumBuses - 1;
 
@@ -2188,16 +1073,20 @@ xf86GetPciBridgeInfo(void)
 	     * Find the 'smallest' free HOST-PCI bridge, where 'small' is in
 	     * the order of pciTag().
 	     */
-	    PCITAG minTag = 0xFFFFFFFF, tag;
+	    PCITAG minTag = 0xFFFFFFFF;
 	    PciBusPtr PciBusFound = NULL;
-	    for (PciBus = PciBusBase; PciBus; PciBus = PciBus->next)
+
+	    for (PciBus = PciBusBase; PciBus; PciBus = PciBus->next) {
+		const PCITAG tag = pciTag( PciBus->brbus, PciBus->brdev,
+					   PciBus->brfunc );
 		if ((PciBus->subclass == PCI_SUBCLASS_BRIDGE_HOST) &&
 		    (PciBus->secondary == -1) &&
-		    ((tag = pciTag(PciBus->brbus,PciBus->brdev,PciBus->brfunc))
-		     < minTag) )  {
+		    (tag < minTag) )  {
 		    minTag = tag;
 		    PciBusFound = PciBus;
 		}
+	    }
+
 	    if (PciBusFound)
 		PciBusFound->secondary = i;
 	    else {  /* if nothing found it may not be visible: create new */
@@ -2211,6 +1100,11 @@ xf86GetPciBridgeInfo(void)
 		}
 		*pnPciBus = PciBus = xnfcalloc(1, sizeof(PciBusRec));
 		pnPciBus = &PciBus->next;
+
+		PciBus->dev = pci_device_find_by_slot( PCI_DOM_FROM_BUS( pcrp->busnum ),
+						       PCI_BUS_NO_DOMAIN( pcrp->busnum ),
+						       pcrp->devnum,
+						       pcrp->funcnum );
 		PciBus->primary = PciBus->secondary = i;
 		PciBus->subclass = PCI_SUBCLASS_BRIDGE_HOST;
 		PciBus->brcontrol = PCI_PCI_BRIDGE_VGA_EN;
@@ -2314,337 +1208,26 @@ alignBridgeRanges(PciBusPtr PciBusBase, PciBusPtr primary)
 }
 
 void
-ValidatePci(void)
-{
-    pciVideoPtr pvp, pvp1;
-    PciBusPtr pbp;
-    pciConfigPtr pcrp, *pcrpp;
-    CARD32 *basep;
-    resPtr Sys;
-    resRange range;
-    int n = 0, m, i;
-
-    if (!xf86PciVideoInfo) return;
-
-    /*
-     * Mark all pciInfoRecs that need to be validated. These are
-     * the ones which have been assigned to a screen.
-     */
-    Sys = xf86DupResList(osRes);
-    /* Only validate graphics devices in use */
-    for (i=0; i<xf86NumScreens; i++) {
-	for (m = 0; m < xf86Screens[i]->numEntities; m++)
-	    if ((pvp = xf86GetPciInfoForEntity(xf86Screens[i]->entityList[m])))
-		pvp->validate = TRUE;
-    }
-    
-    /*
-     * Collect all background PCI resources we need to validate against.
-     * These are all resources which don't belong to PCINONSYSTEMCLASSES
-     * and which have not been assigned to an entity.
-     */
-    /* First get the PCIINFOCLASSES */
-    m = 0;
-    while ((pvp = xf86PciVideoInfo[m++])) {
-	/* is it a PCINONSYSTEMCLASS? */
-	if (PCINONSYSTEMCLASSES(pvp->class, pvp->subclass))
-	    continue;
-	/* has it an Entity assigned to it? */
-	for (i=0; i<xf86NumEntities; i++) {
-	    EntityPtr p = xf86Entities[i];
-	    if (p->busType != BUS_PCI)
-		continue;
-	    if (p->pciBusId.bus == pvp->bus
-		&& p->pciBusId.device == pvp->device
-		&& p->pciBusId.func == pvp->func)
-		break;
-	}
-	if (i != xf86NumEntities) /* found an Entity for this one */
-	    continue;
-	
-	for (i = 0; i<6; i++) {
-	    if (pvp->ioBase[i]) {
-		PV_I_RANGE(range,pvp,i,ResExcIoBlock);
-		Sys = xf86AddResToList(Sys,&range,-1);
-	    } else if (pvp->memBase[i]) {
-		PV_M_RANGE(range,pvp,i,ResExcMemBlock);
-		Sys = xf86AddResToList(Sys,&range,-1);
-	    }
-	}
-    }
-    for (pcrpp = xf86PciInfo, pcrp = *pcrpp; pcrp; pcrp = *++(pcrpp)) {
-
-	/* These were handled above */
-	if (PCIINFOCLASSES(pcrp->pci_base_class, pcrp->pci_sub_class))
-	    continue;
-	
-	if ((pcrp->pci_header_type & 0x7f) ||
-	    !(pcrp->pci_command & (PCI_CMD_IO_ENABLE | PCI_CMD_MEM_ENABLE)))
-	    continue;
-
-	basep = &pcrp->pci_base0;
-	for (i = 0; i < 6; i++) {
-	    if (basep[i]) {
-		if (PCI_MAP_IS_IO(basep[i]))  {
-		    if (!(pcrp->pci_command & PCI_CMD_IO_ENABLE))
-			continue;
-		    P_I_RANGE(range, pcrp->tag, PCIGETIO(basep[i]),
-			      pcrp->basesize[i], ResExcIoBlock)
-		} else if (!PCI_MAP_IS64BITMEM(basep[i])) {
-		    if (!(pcrp->pci_command & PCI_CMD_MEM_ENABLE))
-			continue;
-		    P_M_RANGE(range, pcrp->tag, PCIGETMEMORY(basep[i]),
-			      pcrp->basesize[i], ResExcMemBlock)
-		} else {
-		    i++;
-		    if (!(pcrp->pci_command & PCI_CMD_MEM_ENABLE))
-			continue;
-#if defined(LONG64) || defined(WORD64)
-		    P_M_RANGE(range, pcrp->tag, PCIGETMEMORY64(basep[i-1]),
-			      pcrp->basesize[i-1], ResExcMemBlock)
-#else
-		    if (basep[i])
-		        continue;
-		    P_M_RANGE(range, pcrp->tag, PCIGETMEMORY(basep[i-1]),
-			      pcrp->basesize[i-1], ResExcMemBlock)
-#endif
-		} 
-		Sys = xf86AddResToList(Sys, &range, -1);
-	    }
-	}
-	if ((pcrp->pci_baserom) &&
-	    (pcrp->pci_command & PCI_CMD_MEM_ENABLE) &&
-	    (pcrp->pci_baserom & PCI_MAP_ROM_DECODE_ENABLE)) {
-	    P_M_RANGE(range,pcrp->tag,PCIGETROM(pcrp->pci_baserom),
-		      pcrp->basesize[6],ResExcMemBlock);
-	    Sys = xf86AddResToList(Sys, &range, -1);
-	}
-    }
-#ifdef DEBUG
-    xf86MsgVerb(X_INFO, 3,"Sys:\n");
-    xf86PrintResList(3,Sys);
-#endif
-
-    /*
-     * The order the video devices are listed in is
-     * just right: the lower buses come first.
-     * This way we attempt to fix a conflict of
-     * a lower bus device with a higher bus device
-     * where we have more room to find different
-     * resources.
-     */
-    while ((pvp = xf86PciVideoInfo[n++])) {
-	resPtr res_mp = NULL, res_m_io = NULL;
-	resPtr NonSys;
-	resPtr tmp, avoid = NULL;
-
-	if (!pvp->validate) continue;
-	NonSys = xf86DupResList(Sys);
-	m = n;
-	while ((pvp1 = xf86PciVideoInfo[m++])) {
-	    if (!pvp1->validate) continue;
-	    for (i = 0; i<6; i++) {
-		if (pvp1->ioBase[i]) {
-		    PV_I_RANGE(range,pvp1,i,ResExcIoBlock);
-		    NonSys = xf86AddResToList(NonSys,&range,-1);
-		} else if (pvp1->memBase[i]) {
-		    PV_M_RANGE(range,pvp1,i,ResExcMemBlock);
-		    NonSys = xf86AddResToList(NonSys,&range,-1);
-		}
-	    }
-	}
-#ifdef DEBUG
-	xf86MsgVerb(X_INFO, 3,"NonSys:\n");
-	xf86PrintResList(3,NonSys);
-#endif
-	pbp = xf86PciBus;
-	while (pbp) {
-	    if (pbp->secondary == pvp->bus) {
-		if (pbp->preferred_pmem) {
-		    /* keep prefetchable separate */
-		    res_mp =
-			xf86FindIntersectOfLists(pbp->preferred_pmem, ResRange);
-		}
-		if (pbp->pmem) {
-		    res_mp = xf86FindIntersectOfLists(pbp->pmem, ResRange);
-		}
-		if (pbp->preferred_mem) {
-		    res_m_io =
-			xf86FindIntersectOfLists(pbp->preferred_mem, ResRange);
-		}
-		if (pbp->mem) {
-		    res_m_io = xf86FindIntersectOfLists(pbp->mem, ResRange);
-		}
-		if (pbp->preferred_io) {
-		    res_m_io = xf86JoinResLists(res_m_io,
-			xf86FindIntersectOfLists(pbp->preferred_io, ResRange));
-		}
-		if (pbp->io) {
-		    res_m_io = xf86JoinResLists(res_m_io,
-			xf86FindIntersectOfLists(pbp->preferred_io, ResRange));
-		}
-	    } else if ((pbp->primary == pvp->bus) &&
-		       (pbp->secondary >= 0) &&
-		       (pbp->primary != pbp->secondary)) {
-		tmp = xf86DupResList(pbp->preferred_pmem);
-		avoid = xf86JoinResLists(avoid, tmp);
-		tmp = xf86DupResList(pbp->preferred_mem);
-		avoid = xf86JoinResLists(avoid, tmp);
-		tmp = xf86DupResList(pbp->preferred_io);
-		avoid = xf86JoinResLists(avoid, tmp);
-	    }
-	    pbp = pbp->next;
-	}
-	if (res_m_io == NULL)
-	   res_m_io = xf86DupResList(ResRange);
-
-	pciConvertListToHost(pvp->bus,pvp->device,pvp->func, avoid);
-
-#ifdef DEBUG
-	xf86MsgVerb(X_INFO, 3,"avoid:\n");
-	xf86PrintResList(3,avoid);
-	xf86MsgVerb(X_INFO, 3,"prefetchable Memory:\n");
-	xf86PrintResList(3,res_mp);
-	xf86MsgVerb(X_INFO, 3,"MEM/IO:\n");
-	xf86PrintResList(3,res_m_io);
-#endif
-	for (i = 0; i < 6; i++) {
-	    int j;
-	    resPtr own = NULL;
-	    for (j = i+1; j < 6; j++) {
-		if (pvp->ioBase[j]) {
-		    PV_I_RANGE(range,pvp,j,ResExcIoBlock);
-		    own = xf86AddResToList(own,&range,-1);
-		} else if (pvp->memBase[j]) {
-		    PV_M_RANGE(range,pvp,j,ResExcMemBlock);
-		    own = xf86AddResToList(own,&range,-1);
-		}
-	    }
-#ifdef DEBUG
-	    xf86MsgVerb(X_INFO, 3, "own:\n");
-	    xf86PrintResList(3, own);
-#endif
-	    if (pvp->ioBase[i]) {
-		PV_I_RANGE(range,pvp,i,ResExcIoBlock);
-		if (xf86IsSubsetOf(range,res_m_io)
-		    && ! ChkConflict(&range,own,SETUP)
-		    && ! ChkConflict(&range,avoid,SETUP)
-		    && ! ChkConflict(&range,NonSys,SETUP)) {
-		    xf86FreeResList(own);
-		    continue;
-		}
-		xf86MsgVerb(X_WARNING, 0,
-			"****INVALID IO ALLOCATION**** b: 0x%lx e: 0x%lx "
-			"correcting\a\n", range.rBegin,range.rEnd);
-#ifdef DEBUG
-		sleep(2);
-#endif
-		fixPciResource(i, 0, pvp, range.type);
-	    } else if (pvp->memBase[i]) {
-		PV_M_RANGE(range,pvp,i,ResExcMemBlock);
-		if (pvp->type[i] & PCI_MAP_MEMORY_CACHABLE) {
-		    if (xf86IsSubsetOf(range,res_mp)
-			&& ! ChkConflict(&range,own,SETUP)
-			&& ! ChkConflict(&range,avoid,SETUP)
-			&& ! ChkConflict(&range,NonSys,SETUP)) {
-		        xf86FreeResList(own);
-			continue;
-		    }
-		}
-		if (xf86IsSubsetOf(range,res_m_io)
-		    && ! ChkConflict(&range,own,SETUP)
-		    && ! ChkConflict(&range,avoid,SETUP)
-		    && ! ChkConflict(&range,NonSys,SETUP)) {
-		    xf86FreeResList(own);
-		    continue;
-		}
-		xf86MsgVerb(X_WARNING, 0,
-			"****INVALID MEM ALLOCATION**** b: 0x%lx e: 0x%lx "
-			"correcting\a\n", range.rBegin,range.rEnd);
-		if (ChkConflict(&range,own,SETUP)) {
-		    xf86MsgVerb(X_INFO,3,"own\n");
-		    xf86PrintResList(3,own);
-		}
-		if (ChkConflict(&range,avoid,SETUP)) {
-		    xf86MsgVerb(X_INFO,3,"avoid\n");
-		    xf86PrintResList(3,avoid);
-		}
-		if (ChkConflict(&range,NonSys,SETUP)) {
-		    xf86MsgVerb(X_INFO,3,"NonSys\n");
-		    xf86PrintResList(3,NonSys);
-		}
-
-#ifdef DEBUG
-		sleep(2);
-#endif
-		fixPciResource(i, 0, pvp, range.type);
-	    }
-	    xf86FreeResList(own);
-	}
-	xf86FreeResList(avoid);
-	xf86FreeResList(NonSys);
-	xf86FreeResList(res_mp);
-	xf86FreeResList(res_m_io);
-    }
-    xf86FreeResList(Sys);
-}
-    
-resList
-GetImplicitPciResources(int entityIndex)
-{
-    pciVideoPtr pvp;
-    int i;
-    resList list = NULL;
-    int num = 0;
-    
-    if (! (pvp = xf86GetPciInfoForEntity(entityIndex))) return NULL;
-
-    for (i = 0; i < 6; i++) {
-	if (pvp->ioBase[i]) {
-	    list = xnfrealloc(list,sizeof(resRange) * (++num));
-	    PV_I_RANGE(list[num - 1],pvp,i,ResShrIoBlock | ResBios); 
-	} else if (pvp->memBase[i]) {
-	    list = xnfrealloc(list,sizeof(resRange) * (++num));
-	    PV_M_RANGE(list[num - 1],pvp,i,ResShrMemBlock | ResBios);
-	}
-    }
-#if 0
-    if (pvp->biosBase) {
-	list = xnfrealloc(list,sizeof(resRange) * (++num));
-	PV_B_RANGE(list[num - 1],pvp,ResShrMemBlock | ResBios);
-    }
-#endif
-    list = xnfrealloc(list,sizeof(resRange) * (++num));
-    list[num - 1].type = ResEnd;
-    
-    return list;
-}
-
-void
 initPciState(void)
 {
-    int i = 0;
-    int j = 0;
-    pciVideoPtr pvp; 
+    unsigned i;
     pciAccPtr pcaccp;
 
-    if (xf86PciAccInfo != NULL)
+    if (xf86PciVideoInfo == NULL) {
 	return;
+    }
   
-    if (xf86PciVideoInfo == NULL)
-	return;
+    for (i = 0 ; xf86PciVideoInfo[i] != NULL ; i++) {
+	struct pci_device * const pvp = xf86PciVideoInfo[i];
+
+	if (pvp->user_data == 0) {
+	    pcaccp = xnfalloc( sizeof( pciAccRec ) );
+	    pvp->user_data = (intptr_t) pcaccp;
 
-    while ((pvp = xf86PciVideoInfo[i]) != NULL) {
-  	i++;
-  	    j++;
-  	    xf86PciAccInfo = xnfrealloc(xf86PciAccInfo,
-  					sizeof(pciAccPtr) * (j + 1));
-  	    xf86PciAccInfo[j] = NULL;
-  	    pcaccp = xf86PciAccInfo[j - 1] = xnfalloc(sizeof(pciAccRec));
-	    pcaccp->busnum = pvp->bus; 
- 	    pcaccp->devnum = pvp->device; 
+	    pcaccp->busnum = PCI_MAKE_BUS(pvp->domain, pvp->bus);
+	    pcaccp->devnum = pvp->dev; 
  	    pcaccp->funcnum = pvp->func;
- 	    pcaccp->arg.tag = pciTag(pvp->bus, pvp->device, pvp->func);
+	    pcaccp->arg.dev = pvp;
   	    pcaccp->ioAccess.AccessDisable = pciIoAccessDisable;
   	    pcaccp->ioAccess.AccessEnable = pciIoAccessEnable;
   	    pcaccp->ioAccess.arg = &pcaccp->arg;
@@ -2654,14 +1237,14 @@ initPciState(void)
 	    pcaccp->memAccess.AccessDisable = pciMemAccessDisable;
 	    pcaccp->memAccess.AccessEnable = pciMemAccessEnable;
 	    pcaccp->memAccess.arg = &pcaccp->arg;
- 	    if (PCISHAREDIOCLASSES(pvp->class, pvp->subclass))
- 		pcaccp->ctrl = TRUE;
- 	    else
- 		pcaccp->ctrl = FALSE;
- 	    savePciState(pcaccp->arg.tag, &pcaccp->save);
+
+	    pcaccp->ctrl = PCISHAREDIOCLASSES(pvp->device_class);
+
+	    savePciState(pvp, &pcaccp->save);
 	    pcaccp->arg.ctrl = pcaccp->save.command;
     }
 }
+}
 
 /*
  * initPciBusState() - fill out the BusAccRec for a PCI bus.
@@ -2695,7 +1278,7 @@ initPciBusState(void)
 	pbap->busdep.pci.bus = pbp->secondary;
 	pbap->busdep.pci.primary_bus = pbp->primary;
 	pbap->busdep_type = BUS_PCI;
-	pbap->busdep.pci.acc = PCITAG_SPECIAL;
+	pbap->busdep.pci.dev = NULL;
 
 	if ((pbp->secondary >= 0) && (pbp->secondary < pciNumBuses) &&
 	    (pBusInfo = pciBusInfo[pbp->secondary]) &&
@@ -2720,7 +1303,10 @@ initPciBusState(void)
 	    pbap->set_f = pciSetBusAccess;
 	    pbap->enable_f = pciBusAccessEnable;
 	    pbap->disable_f = pciBusAccessDisable;
-	    pbap->busdep.pci.acc = pciTag(pbp->brbus,pbp->brdev,pbp->brfunc);
+	    pbap->busdep.pci.dev = pci_device_find_by_slot(PCI_DOM_FROM_BUS(pbp->brbus),
+							   PCI_BUS_NO_DOMAIN(pbp->brbus),
+							   pbp->brdev,
+							   pbp->brfunc);
 	    savePciBusState(pbap);
 	    break;
 	case PCI_SUBCLASS_BRIDGE_ISA:
@@ -2761,21 +1347,21 @@ initPciBusState(void)
 void 
 PciStateEnter(void)
 {
-    pciAccPtr paccp;
-    int i = 0;
+    unsigned i;
     
-    if (xf86PciAccInfo == NULL) 
+    if (xf86PciVideoInfo == NULL)
 	return;
 
-    while ((paccp = xf86PciAccInfo[i]) != NULL) {
-	i++;
- 	if (!paccp->ctrl)
- 	    continue;
-	savePciState(paccp->arg.tag, &paccp->save);
-	restorePciState(paccp->arg.tag, &paccp->restore);
+    for ( i = 0 ; xf86PciVideoInfo[i] != NULL ; i++ ) {
+	pciAccPtr paccp = (pciAccPtr) xf86PciVideoInfo[i]->user_data;
+
+ 	if ( (paccp != NULL) && paccp->ctrl ) {
+	    savePciState(paccp->arg.dev, &paccp->save);
+	    restorePciState(paccp->arg.dev, &paccp->restore);
 	paccp->arg.ctrl = paccp->restore.command;
     }
 }
+}
 
 void
 PciBusStateEnter(void)
@@ -2792,18 +1378,18 @@ PciBusStateEnter(void)
 void 
 PciStateLeave(void)
 {
-    pciAccPtr paccp;
-    int i = 0;
+    unsigned i;
 
-    if (xf86PciAccInfo == NULL) 
+    if (xf86PciVideoInfo == NULL)
 	return;
 
-    while ((paccp = xf86PciAccInfo[i]) != NULL) {
-	i++;
-	if (!paccp->ctrl)
-	    continue;
-	savePciState(paccp->arg.tag, &paccp->restore);
-	restorePciState(paccp->arg.tag, &paccp->save);
+    for ( i = 0 ; xf86PciVideoInfo[i] != NULL ; i++ ) {
+	pciAccPtr paccp = (pciAccPtr) xf86PciVideoInfo[i]->user_data;
+
+ 	if ( (paccp != NULL) && paccp->ctrl ) {
+	    savePciState(paccp->arg.dev, &paccp->restore);
+	    restorePciState(paccp->arg.dev, &paccp->save);
+	}
     }
 }
 
@@ -2822,18 +1408,19 @@ PciBusStateLeave(void)
 void 
 DisablePciAccess(void)
 {
-    int i = 0;
-    pciAccPtr paccp;
-    if (xf86PciAccInfo == NULL)
+    unsigned i;
+
+    if (xf86PciVideoInfo == NULL)
 	return;
 
-    while ((paccp = xf86PciAccInfo[i]) != NULL) {
-	i++;
-	if (!paccp->ctrl) /* disable devices that are under control initially*/
-	    continue;
+    for ( i = 0 ; xf86PciVideoInfo[i] != NULL ; i++ ) {
+	pciAccPtr paccp = (pciAccPtr) xf86PciVideoInfo[i]->user_data;
+
+ 	if ( (paccp != NULL) && paccp->ctrl ) {
 	pciIo_MemAccessDisable(paccp->io_memAccess.arg);
     }
 }
+}
 
 void
 DisablePciBusAccess(void)
@@ -2850,67 +1437,42 @@ DisablePciBusAccess(void)
 }
 
 /*
- * Public functions
- */
-
-_X_EXPORT Bool
-xf86IsPciDevPresent(int bus, int dev, int func)
-{
-    int i = 0;
-    pciConfigPtr pcp;
-    
-    while ((pcp = xf86PciInfo[i]) != NULL) {
-	if ((pcp->busnum == bus)
-	    && (pcp->devnum == dev)
-	    && (pcp->funcnum == func))
-	    return TRUE;
-	i++;
-    }
-    return FALSE;
-}
-
-/*
  * If the slot requested is already in use, return -1.
  * Otherwise, claim the slot for the screen requesting it.
  */
 
 _X_EXPORT int
-xf86ClaimPciSlot(int bus, int device, int func, DriverPtr drvp,
+xf86ClaimPciSlot(struct pci_device * d, DriverPtr drvp,
 		 int chipset, GDevPtr dev, Bool active)
 {
     EntityPtr p = NULL;
-    pciAccPtr *ppaccp = xf86PciAccInfo;
+    pciAccPtr paccp = (pciAccPtr) d->user_data;
     BusAccPtr pbap = xf86BusAccInfo;
+    const unsigned bus = PCI_MAKE_BUS(d->domain, d->bus);
     
     int num;
     
-    if (xf86CheckPciSlot(bus, device, func)) {
+    if (xf86CheckPciSlot(d)) {
 	num = xf86AllocateEntity();
 	p = xf86Entities[num];
 	p->driver = drvp;
 	p->chipset = chipset;
 	p->busType = BUS_PCI;
 	p->pciBusId.bus = bus;
-	p->pciBusId.device = device;
-	p->pciBusId.func = func;
+	p->pciBusId.device = d->dev;
+	p->pciBusId.func = d->func;
 	p->active = active;
 	p->inUse = FALSE;
 	if (dev)
             xf86AddDevToEntity(num, dev);
 	/* Here we initialize the access structure */
 	p->access = xnfcalloc(1,sizeof(EntityAccessRec));
-	while (ppaccp && *ppaccp) {
-	    if ((*ppaccp)->busnum == bus
-		&& (*ppaccp)->devnum == device
-		&& (*ppaccp)->funcnum == func) {
-		p->access->fallback = &(*ppaccp)->io_memAccess;
-		p->access->pAccess = &(*ppaccp)->io_memAccess;
- 		(*ppaccp)->ctrl = TRUE; /* mark control if not already */
-		break;
-	    }
-	    ppaccp++;
+	if (paccp != NULL) {
+	    p->access->fallback = & paccp->io_memAccess;
+	    p->access->pAccess = & paccp->io_memAccess;
+	    paccp->ctrl = TRUE; /* mark control if not already */
 	}
-	if (!ppaccp || !*ppaccp) {
+	else {
 	    p->access->fallback = &AccessNULL;
 	    p->access->pAccess = &AccessNULL;
 	}
@@ -2921,16 +1483,16 @@ xf86ClaimPciSlot(int bus, int device, int func, DriverPtr drvp,
 		p->busAcc = pbap;
 	    pbap = pbap->next;
 	}
-	fixPciSizeInfo(num);
 
 	/* in case bios is enabled disable it */
-	disablePciBios(pciTag(bus,device,func));
+	disablePciBios( d );
 	pciSlotClaimed = TRUE;
 
 	if (active) {
 	    /* Map in this domain's I/O space */
 	   p->domainIO = xf86MapDomainIO(-1, VIDMEM_MMIO,
-					 pciTag(bus, device, func), 0, 1);
+					 pciTag(bus, d->dev, d->func),
+					 0, 1);
 	}
 	
  	return num;
@@ -2939,138 +1501,6 @@ xf86ClaimPciSlot(int bus, int device, int func, DriverPtr drvp,
 }
 
 /*
- * Get xf86PciVideoInfo for a driver.
- */
-_X_EXPORT pciVideoPtr *
-xf86GetPciVideoInfo(void)
-{
-    return xf86PciVideoInfo;
-}
-
-/* --- Used by ATI driver, but also more generally useful */
-
-/*
- * Get the full xf86scanpci data.
- */
-_X_EXPORT pciConfigPtr *
-xf86GetPciConfigInfo(void)
-{
-    return xf86PciInfo;
-}
-
-/*
- * Enable a device and route VGA to it.  This is intended for a driver's
- * Probe(), before creating EntityRec's.  Only one device can be thus enabled
- * at any one time, and should be disabled when the driver is done with it.
- *
- * The following special calls are also available:
- *
- * pvp == NULL && rt == NONE    disable previously enabled device
- * pvp != NULL && rt == NONE    ensure device is disabled
- * pvp == NULL && rt != NONE    disable >all< subsequent calls to this function
- *                              (done from xf86PostProbe())
- * The last combination has been removed! To do this cleanly we have
- * to implement stages and need to test at each stage dependent function
- * if it is allowed to execute.
- *
- * The device represented by pvp may not have been previously claimed.
- */
-_X_EXPORT void
-xf86SetPciVideo(pciVideoPtr pvp, resType rt)
-{
-    static BusAccPtr pbap = NULL;
-    static xf86AccessPtr pAcc = NULL;
-    static Bool DoneProbes = FALSE;
-    pciAccPtr pcaccp;
-    int i;
-
-    if (DoneProbes)
-	return;
-
-    /* Disable previous access */
-    if (pAcc) {
-	if (pAcc->AccessDisable)
-	    (*pAcc->AccessDisable)(pAcc->arg);
-	pAcc = NULL;
-    }
-    if (pbap) {
-	while (pbap->primary) {
-	    if (pbap->disable_f)
-		(*pbap->disable_f)(pbap);
-	    pbap->primary->current = NULL;
-	    pbap = pbap->primary;
-	}
-	pbap = NULL;
-    }
-
-    /* Check for xf86PostProbe's magic combo */
-    if (!pvp) {
-	if (rt != NONE)
-	    DoneProbes = TRUE;
-	return;
-    }
-
-    /* Validate device */
-    if (!xf86PciVideoInfo || !xf86PciAccInfo || !xf86BusAccInfo)
-	return;
-
-    for (i = 0; pvp != xf86PciVideoInfo[i]; i++)
-	if (!xf86PciVideoInfo[i])
-	    return;
-
-    /* Ignore request for claimed adapters */
-    if (!xf86CheckPciSlot(pvp->bus, pvp->device, pvp->func))
-	return;
-
-    /* Find pciAccRec structure */
-    for (i = 0; ; i++) {
-	if (!(pcaccp = xf86PciAccInfo[i]))
-	    return;
-	if ((pvp->bus == pcaccp->busnum) &&
-	    (pvp->device == pcaccp->devnum) &&
-	    (pvp->func == pcaccp->funcnum))
-	    break;
-    }
-
-    if (rt == NONE) {
-	/* This is a call to ensure the adapter is disabled */
-	if (pcaccp->io_memAccess.AccessDisable)
-	    (*pcaccp->io_memAccess.AccessDisable)(pcaccp->io_memAccess.arg);
-	return;
-    }
-
-    /* Find BusAccRec structure */
-    for (pbap = xf86BusAccInfo; ; pbap = pbap->next) {
-	if (!pbap)
-	    return;
-	if (pvp->bus == pbap->busdep.pci.bus)
-	    break;
-    }
-
-    /* Route VGA */
-    if (pbap->set_f)
-	(*pbap->set_f)(pbap);
-
-    /* Enable device */
-    switch (rt) {
-    case IO:
-	pAcc = &pcaccp->ioAccess;
-	break;
-    case MEM_IO:
-	pAcc = &pcaccp->io_memAccess;
-	break;
-    case MEM:
-	pAcc = &pcaccp->memAccess;
-	break;
-    default:	/* no compiler noise */
-	break;
-    }
-
-    if (pAcc && pAcc->AccessEnable)
-	(*pAcc->AccessEnable)(pAcc->arg);
-}
-
-/*
  * Parse a BUS ID string, and return the PCI bus parameters if it was
  * in the correct format for a PCI bus id.
  */
@@ -3167,36 +1597,42 @@ xf86ComparePciBusString(const char *busID, int bus, int device, int func)
  */
  
 _X_EXPORT Bool
-xf86IsPrimaryPci(pciVideoPtr pPci)
+xf86IsPrimaryPci( struct pci_device * pPci )
 {
-    if (primaryBus.type != BUS_PCI) return FALSE;
-    return (pPci->bus == primaryBus.id.pci.bus &&
-	    pPci->device == primaryBus.id.pci.device &&
-	    pPci->func == primaryBus.id.pci.func);
+    const unsigned busnum = PCI_MAKE_BUS( pPci->domain, pPci->bus );
+
+    return ((primaryBus.type == BUS_PCI)
+	    && (busnum == primaryBus.id.pci.bus)
+	    && (pPci->dev == primaryBus.id.pci.device)
+	    && (pPci->func == primaryBus.id.pci.func));
 }
 
 /*
  * xf86GetPciInfoForEntity() -- Get the pciVideoRec of entity.
  */
-_X_EXPORT pciVideoPtr
+_X_EXPORT struct pci_device *
 xf86GetPciInfoForEntity(int entityIndex)
 {
-    pciVideoPtr *ppPci;
     EntityPtr p;
     
     if (entityIndex >= xf86NumEntities)
 	return NULL;
 
     p = xf86Entities[entityIndex];
-    if (p->busType != BUS_PCI)
-	return NULL;
+    if (p->busType == BUS_PCI) {
+	const unsigned domain = PCI_DOM_FROM_BUS(p->pciBusId.bus);
+	const unsigned bus = PCI_BUS_NO_DOMAIN(p->pciBusId.bus);
+	struct pci_device ** ppPci;
     
     for (ppPci = xf86PciVideoInfo; *ppPci != NULL; ppPci++) {
-	if (p->pciBusId.bus == (*ppPci)->bus &&
-	    p->pciBusId.device == (*ppPci)->device &&
+	    if (domain == (*ppPci)->domain &&
+		bus == (*ppPci)->bus &&
+		p->pciBusId.device == (*ppPci)->dev &&
 	    p->pciBusId.func == (*ppPci)->func) 
 	    return (*ppPci);
     }
+    }
+
     return NULL;
 }
 
@@ -3222,12 +1658,12 @@ xf86GetPciEntity(int bus, int dev, int func)
  * PCI base address register values for the given PCI device.
  */
 _X_EXPORT Bool
-xf86CheckPciMemBase(pciVideoPtr pPci, memType base)
+xf86CheckPciMemBase( struct pci_device * pPci, memType base )
 {
     int i;
 
     for (i = 0; i < 6; i++)
-	if (base == pPci->memBase[i])
+	if (base == pPci->regions[i].base_addr)
 	    return TRUE;
     return FALSE;
 }
@@ -3237,16 +1673,17 @@ xf86CheckPciMemBase(pciVideoPtr pPci, memType base)
  */
 
 _X_EXPORT Bool
-xf86CheckPciSlot(int bus, int device, int func)
+xf86CheckPciSlot( const struct pci_device * d )
 {
     int i;
     EntityPtr p;
+    const unsigned busnum = PCI_MAKE_BUS(d->domain, d->bus);
 
     for (i = 0; i < xf86NumEntities; i++) {
 	p = xf86Entities[i];
 	/* Check if this PCI slot is taken */
-	if (p->busType == BUS_PCI && p->pciBusId.bus == bus &&
-	    p->pciBusId.device == device && p->pciBusId.func == func)
+	if (p->busType == BUS_PCI && p->pciBusId.bus == busnum &&
+	    p->pciBusId.device == d->dev && p->pciBusId.func == d->func)
 	    return FALSE;
     }
     
@@ -3261,125 +1698,43 @@ xf86CheckPciSlot(int bus, int device, int func)
  * so by setting pvp_exclude one pci device can be explicitely
  * _excluded if required.
  */
-_X_EXPORT pciVideoPtr
+_X_EXPORT struct pci_device *
 xf86FindPciDeviceVendor(CARD16 vendorID, CARD16 deviceID,
-			char n, pciVideoPtr pvp_exclude)
+			 char n, const struct pci_device * exclude )
 {
-    pciVideoPtr pvp, *ppvp;
+    struct pci_device * pvp;
+    struct pci_device ** ppvp;
+
     n++;
 
     for (ppvp = xf86PciVideoInfo, pvp =*ppvp; pvp ; pvp = *(++ppvp)) {
-	if (pvp == pvp_exclude) continue;
-	if ((pvp->vendor == vendorID) && (pvp->chipType == deviceID)) {
+	if ( (pvp != exclude) && (pvp->vendor_id == vendorID)
+	     && (pvp->device_id == deviceID) ) {
 	    if (!(--n)) break;
 	}
     }
+
     return pvp;
 }
 
-_X_EXPORT pciVideoPtr
-xf86FindPciClass(CARD8 intf, CARD8 subClass, CARD16 class,
-		 char n, pciVideoPtr pvp_exclude)
+_X_EXPORT struct pci_device *
+xf86FindPciClass(CARD8 intf, CARD8 subClass, CARD16 _class,
+		 char n, const struct pci_device * exclude)
 {
-    pciVideoPtr pvp, *ppvp;
+    struct pci_device * pvp;
+    struct pci_device ** ppvp;
+    const uint32_t device_class = ( ((uint32_t)_class) << 16) 
+      | ( ((uint32_t)subClass) << 8) | intf;
+
     n++;
     
     for (ppvp = xf86PciVideoInfo, pvp =*ppvp; pvp ; pvp = *(++ppvp)) {
-	if (pvp == pvp_exclude) continue;
-	if ((pvp->interface == intf) && (pvp->subclass == subClass)
-	    && (pvp->class == class)) {
+	if ( (pvp != exclude) && (pvp->device_class == device_class) ) {
 	    if (!(--n)) break;
 	}
     }
-    return pvp;
-}
-
-/*
- * This attempts to detect a multi-device card and sets up a list
- * of pci tags of the devices of this card. On some of these
- * cards the BIOS is not visible from all chipsets. We therefore
- * need to use the BIOS from a chipset where it is visible.
- * We do the following heuristics:
- * If we detect only identical pci devices on a bus we assume it's
- * a multi-device card. This assumption isn't true always, however.
- * One might just use identical cards on a bus. We therefore don't
- * detect this situation when we set up the PCI video info. Instead
- * we wait until an attempt to read the BIOS fails.
- */
-int
-pciTestMultiDeviceCard(int bus, int dev, int func, PCITAG** pTag)
-{
-  pciConfigPtr *ppcrp = xf86PciInfo;
-  pciConfigPtr pcrp = NULL;
-  int i,j;
-  Bool multicard = FALSE;
-  Bool multifunc = FALSE;
-  char str[256];
-  char *str1;
-  
-  str1 = str;
-  if (!pTag) 
-    return 0;
-
-  *pTag = NULL;
- 
-  for (i=0; i < 8; i++) {
-    j = 0;
-
-    while (ppcrp[j]) {
-      if (ppcrp[j]->busnum == bus && ppcrp[j]->funcnum == i) {
-	pcrp = ppcrp[j];
-	break;
-      }
-      j++;
-    }
-
-    if (!pcrp) return 0;
-
-    /* 
-     * we check all functions here: since multifunc devices need
-     * to implement func 0 we catch all devices on the bus when
-     * i = 0
-     */
-    if (pcrp->pci_header_type &0x80) 
-	multifunc = TRUE;
-    
-    j = 0;
-    
-    while (ppcrp[j]) {
-      if (ppcrp[j]->busnum == bus && ppcrp[j]->funcnum == i
-	  && ppcrp[j]->devnum != pcrp->devnum) {
-	/* don't test subsys ID here. It might be set by POST 
-	   - however some cards might not have been POSTed */
-	if (ppcrp[j]->pci_device_vendor != pcrp->pci_device_vendor 
-	    || ppcrp[j]->pci_header_type != pcrp->pci_header_type ) 
-	  return 0;
-	else
-	  multicard = TRUE;
-      }
-      j++;
-    }
-    if (!multifunc)
-      break;
-  }
 
-  if (!multicard) 
-    return 0;
-
-  j = 0;
-  i = 0;
-  while (ppcrp[i]) {
-    if (ppcrp[i]->busnum == bus && ppcrp[i]->funcnum == func) {
-      str1 += sprintf(str1,"[%x:%x:%x]",ppcrp[i]->busnum,
-		      ppcrp[i]->devnum,ppcrp[i]->funcnum);
-      *pTag = xnfrealloc(*pTag,sizeof(PCITAG) * (j + 1));
-      (*pTag)[j++] = pciTag(ppcrp[i]->busnum,
-			      ppcrp[i]->devnum,ppcrp[i]->funcnum);
-    }
-    i++;
-  }
-  xf86MsgVerb(X_INFO,3,"Multi Device Card detected: %s\n",str);
-  return j;
+    return pvp;
 }
 
 static void
@@ -3424,60 +1779,14 @@ pciTagConvertRange2Host(PCITAG tag, resRange *pRange)
     pRange->type |= xf86GetPciDomain(tag) << 24;
 }
 
-static void
-pciConvertListToHost(int bus, int dev, int func, resPtr list)
-{
-    PCITAG tag = pciTag(bus,dev,func);
-    while (list) {
-	pciTagConvertRange2Host(tag, &list->val);
-	list = list->next;
-    }
-}
-
-static void
-updateAccessInfoStatusControlInfo(PCITAG tag, CARD32 ctrl)
-{
-    int i;
-
-    if (!xf86PciAccInfo)
-	return;
-    
-    for (i = 0; xf86PciAccInfo[i] != NULL; i++) {
-	if (xf86PciAccInfo[i]->arg.tag == tag)
-	    xf86PciAccInfo[i]->arg.ctrl = ctrl;
-    }
-}
-
 void
 pciConvertRange2Host(int entityIndex, resRange *pRange)
 {
-    PCITAG tag;
-    pciVideoPtr pvp;
+    const struct pci_device * const pvp = xf86GetPciInfoForEntity(entityIndex);
 
-    pvp = xf86GetPciInfoForEntity(entityIndex);
-    if (!pvp) return;
-    tag = TAG(pvp);
+    if ( pvp != NULL ) {
+	const PCITAG tag = PCI_MAKE_TAG( PCI_MAKE_BUS( pvp->domain, pvp->bus ),
+					 pvp->dev, pvp->func );
     pciTagConvertRange2Host(tag, pRange);
 }
-
-
-#ifdef INCLUDE_DEPRECATED
-_X_EXPORT void
-xf86EnablePciBusMaster(pciVideoPtr pPci, Bool enable)
-{
-    CARD32 temp;
-    PCITAG tag;
-
-    if (!pPci) return;
-
-    tag = pciTag(pPci->bus, pPci->device, pPci->func);
-    temp = pciReadLong(tag, PCI_CMD_STAT_REG);
-    if (enable) {
-	updateAccessInfoStatusControlInfo(tag, temp | PCI_CMD_MASTER_ENABLE);
-	pciWriteLong(tag, PCI_CMD_STAT_REG, temp | PCI_CMD_MASTER_ENABLE);
-    } else {
-	updateAccessInfoStatusControlInfo(tag, temp & ~PCI_CMD_MASTER_ENABLE);
-	pciWriteLong(tag, PCI_CMD_STAT_REG, temp & ~PCI_CMD_MASTER_ENABLE);
-    }
 }
-#endif /* INCLUDE_DEPRECATED */
