diff --git a/hw/xgl/glxext/xglglxext.c b/hw/xgl/glxext/xglglxext.c
index 3a9c4cc..c260d8e 100644
--- a/hw/xgl/glxext/xglglxext.c
+++ b/hw/xgl/glxext/xglglxext.c
@@ -24,6 +24,7 @@
  */
 
 #include "xgl.h"
+#include "xglglx.h"
 #include "xglglxext.h"
 
 #include <GL/gl.h>
@@ -36,10 +37,12 @@
 #include "glxutil.h"
 #include "unpack.h"
 #include "g_disptab.h"
+#include "glapitable.h"
 #include "glxext.h"
 #include "micmap.h"
 
 #define XGL_MAX_TEXTURE_UNITS 8
+#define XGL_MAX_ATTRIB_STACK_DEPTH 16
 
 #define XGL_TEXTURE_1D_BIT	  (1 << 0)
 #define XGL_TEXTURE_2D_BIT	  (1 << 1)
@@ -64,9 +67,11 @@ typedef struct _xglGLXScreenInfo {
     GLXCreateBufferProc  createBuffer;
 } xglGLXScreenInfoRec, *xglGLXScreenInfoPtr;
 
+extern __GLXscreenInfo *__xglScreenInfoPtr;
+
 static xglGLXScreenInfoRec screenInfoPriv;
 
-extern __GLXscreenInfo __glDDXScreenInfo;
+//extern __GLXscreenInfo __glDDXScreenInfo;
 
 typedef GLboolean (*GLResizeBuffersProc) (__GLdrawableBuffer   *buffer,
 					  GLint		       x,
@@ -85,11 +90,14 @@ typedef struct _xglGLBuffer {
     GLFreeBuffersProc     freeBuffers;
     ScreenPtr		  pScreen;
     DrawablePtr		  pDrawable;
+    xglVisualPtr	  pVisual;
+    glitz_drawable_t	  *drawable;
     glitz_surface_t	  *backSurface;
     PixmapPtr		  pPixmap;
     GCPtr		  pGC;
     RegionRec		  damage;
     void	          *private;
+    int			  screenX, screenY;
     int			  xOff, yOff;
     int			  yFlip;
 } xglGLBufferRec, *xglGLBufferPtr;
@@ -262,14 +270,15 @@ typedef struct _xglGLContext {
     int			      refcnt;
     struct _xglGLContext      *shared;
     glitz_context_t	      *context;
-    __glProcTableEXT	      glRenderTableEXT;
+    struct _glapi_table	      glRenderTable;
     PFNGLACTIVETEXTUREARBPROC ActiveTextureARB;
     PFNGLWINDOWPOS3FMESAPROC  WindowPos3fMESA;
     Bool		      needInit;
     xglGLBufferPtr	      pDrawBuffer;
     xglGLBufferPtr	      pReadBuffer;
-    GLuint		      fbo;
     int			      drawXoff, drawYoff;
+    __GLdrawablePrivate	      *readPriv;
+    __GLdrawablePrivate	      *drawPriv;
     char		      *versionString;
     GLenum		      errorValue;
     GLboolean		      doubleBuffer;
@@ -279,23 +288,42 @@ typedef struct _xglGLContext {
     xglHashTablePtr	      displayLists;
     GLuint		      list;
     GLenum		      listMode;
+    GLuint		      beginCnt;
     xglDisplayListPtr	      pList;
     GLuint		      groupList;
     xglGLAttributesRec	      attrib;
-    xglGLAttributesPtr	      pAttribStack;
+    xglGLAttributesRec	      attribStack[XGL_MAX_ATTRIB_STACK_DEPTH];
     int			      nAttribStack;
     int			      activeTexUnit;
     GLint		      maxTexUnits;
     GLint		      maxListNesting;
+    GLint		      maxAttribStackDepth;
 } xglGLContextRec, *xglGLContextPtr;
 
 static xglGLContextPtr cctx = NULL;
 
-//static void
-//xglSetCurrentContext (xglGLContextPtr pContext, glitz_drawable_t *drawable);
 static void
 xglSetCurrentContext (xglGLContextPtr pContext);
 
+#define XGL_GLX_DRAW_PROLOGUE_WITHOUT_TEXTURES(pBox, nBox, pScissorBox)	  \
+    (pBox) = REGION_RECTS (cctx->pDrawBuffer->pGC->pCompositeClip);	  \
+    (nBox) = REGION_NUM_RECTS (cctx->pDrawBuffer->pGC->pCompositeClip);	  \
+    (pScissorBox)->x1 = cctx->attrib.scissor.x + cctx->pDrawBuffer->xOff; \
+    (pScissorBox)->x2 = (pScissorBox)->x1 + cctx->attrib.scissor.width;	  \
+    (pScissorBox)->y2 = cctx->attrib.scissor.y + cctx->pDrawBuffer->yOff; \
+    (pScissorBox)->y2 = cctx->pDrawBuffer->yFlip - (pScissorBox)->y2;	  \
+    (pScissorBox)->y1 = (pScissorBox)->y2 - cctx->attrib.scissor.height
+
+#define XGL_GLX_DRAW_PROLOGUE(pBox, nBox, pScissorBox)		      \
+    XGL_GLX_DRAW_PROLOGUE_WITHOUT_TEXTURES (pBox, nBox, pScissorBox); \
+    xglSetupTextures ()
+
+#define XGL_GLX_DRAW_BOX(pBox1, pBox2)			    \
+    (pBox1)->x1 = cctx->pDrawBuffer->screenX + (pBox2)->x1; \
+    (pBox1)->y1 = cctx->pDrawBuffer->screenY + (pBox2)->y1; \
+    (pBox1)->x2 = cctx->pDrawBuffer->screenX + (pBox2)->x2; \
+    (pBox1)->y2 = cctx->pDrawBuffer->screenY + (pBox2)->y2
+
 #define XGL_GLX_INTERSECT_BOX(pBox1, pBox2) \
     {					    \
 	if ((pBox1)->x1 < (pBox2)->x1)      \
@@ -314,27 +342,19 @@ xglSetCurrentContext (xglGLContextPtr pContext);
 	       (pBox)->x2 - (pBox)->x1,		      \
 	       (pBox)->y2 - (pBox)->y1)
 
-#define XGL_GLX_DRAW_PROLOGUE(pBox, nBox, pScissorBox)			  \
-    (pBox) = REGION_RECTS (cctx->pDrawBuffer->pGC->pCompositeClip);	  \
-    (nBox) = REGION_NUM_RECTS (cctx->pDrawBuffer->pGC->pCompositeClip);   \
-    (pScissorBox)->x1 = cctx->attrib.scissor.x + cctx->pDrawBuffer->xOff; \
-    (pScissorBox)->x2 = (pScissorBox)->x1 + cctx->attrib.scissor.width;	  \
-    (pScissorBox)->y2 = cctx->attrib.scissor.y + cctx->pDrawBuffer->yOff; \
-    (pScissorBox)->y2 = cctx->pDrawBuffer->yFlip - (pScissorBox)->y2;     \
-    (pScissorBox)->y1 = (pScissorBox)->y2 - cctx->attrib.scissor.height;  \
-    xglSetupTextures ()
-
 #define XGL_GLX_DRAW_DAMAGE(pBox, pRegion)				 \
-    if (cctx->attrib.drawBuffer != GL_BACK &&				 \
-	cctx->pDrawBuffer->pDrawable &&					 \
-	cctx->pDrawBuffer->pDrawable->type != DRAWABLE_PIXMAP)		 \
+    if (cctx->attrib.drawBuffer != GL_BACK)				 \
     {									 \
-	REGION_INIT (cctx->pDrawBuffer->pGC->pScreen, pRegion, pBox, 1); \
+	(pRegion)->extents.x1 = (pBox)->x1 - cctx->pDrawBuffer->screenX; \
+	(pRegion)->extents.y1 = (pBox)->y1 - cctx->pDrawBuffer->screenY; \
+	(pRegion)->extents.x2 = (pBox)->x2 - cctx->pDrawBuffer->screenX; \
+	(pRegion)->extents.y2 = (pBox)->y2 - cctx->pDrawBuffer->screenY; \
+	(pRegion)->data = (RegDataPtr) NULL;				 \
 	REGION_UNION (cctx->pDrawBuffer->pGC->pScreen,			 \
 		      &cctx->pDrawBuffer->damage,			 \
 		      &cctx->pDrawBuffer->damage,			 \
 		      pRegion);						 \
-	REGION_UNINIT (cctx->pDrawBuffer->pGC->pScreen, pRegion);	 \
+	xglAddBitDamage (cctx->pDrawBuffer->pDrawable, pRegion);	 \
     }
 
 static void
@@ -529,9 +549,22 @@ xglScissor (GLint   x,
 static void
 xglDrawBufferProc (xglGLOpPtr pOp)
 {
+    glitz_drawable_buffer_t buffers[2];
+
     switch (pOp->u.enumeration) {
     case GL_FRONT:
+	buffers[0] = GLITZ_DRAWABLE_BUFFER_FRONT_COLOR;
+	glitz_context_draw_buffers (cctx->context, buffers, 1);
+	break;
     case GL_FRONT_AND_BACK:
+	buffers[0] = GLITZ_DRAWABLE_BUFFER_FRONT_COLOR;
+	if (cctx->doubleBuffer)
+	{
+	    buffers[1] = GLITZ_DRAWABLE_BUFFER_BACK_COLOR;
+	    glitz_context_draw_buffers (cctx->context, buffers, 2);
+	}
+	else
+	    glitz_context_draw_buffers (cctx->context, buffers, 1);
 	break;
     case GL_BACK:
 	if (!cctx->doubleBuffer)
@@ -539,6 +572,8 @@ xglDrawBufferProc (xglGLOpPtr pOp)
 	    xglRecordError (GL_INVALID_OPERATION);
 	    return;
 	}
+	buffers[0] = GLITZ_DRAWABLE_BUFFER_BACK_COLOR;
+	glitz_context_draw_buffers (cctx->context, buffers, 1);
 	break;
     default:
 	xglRecordError (GL_INVALID_ENUM);
@@ -546,8 +581,6 @@ xglDrawBufferProc (xglGLOpPtr pOp)
     }
     
     cctx->attrib.drawBuffer = pOp->u.enumeration;
-    
-    glDrawBuffer (pOp->u.enumeration);
 }
 
 static void
@@ -567,6 +600,8 @@ xglReadBufferProc (xglGLOpPtr pOp)
 {
     switch (pOp->u.enumeration) {
     case GL_FRONT:
+	glitz_context_read_buffer (cctx->context,
+				   GLITZ_DRAWABLE_BUFFER_FRONT_COLOR);
 	break;
     case GL_BACK:
 	if (!cctx->doubleBuffer)
@@ -574,6 +609,8 @@ xglReadBufferProc (xglGLOpPtr pOp)
 	    xglRecordError (GL_INVALID_OPERATION);
 	    return;
 	}
+	glitz_context_read_buffer (cctx->context,
+				   GLITZ_DRAWABLE_BUFFER_BACK_COLOR);
 	break;
     default:
 	xglRecordError (GL_INVALID_ENUM);
@@ -581,8 +618,6 @@ xglReadBufferProc (xglGLOpPtr pOp)
     }
     
     cctx->attrib.readBuffer = pOp->u.enumeration;
-	
-    glReadBuffer (pOp->u.enumeration);
 }
 
 static void
@@ -740,30 +775,17 @@ static void
 xglPushAttribProc (xglGLOpPtr pOp)
 {
     xglGLAttributesPtr pAttrib;
-    GLint	       depth;
-    
-    glGetIntegerv (GL_MAX_ATTRIB_STACK_DEPTH, &depth);
     
-    if (cctx->nAttribStack == depth)
+    if (cctx->nAttribStack == cctx->maxAttribStackDepth)
     {
 	xglRecordError (GL_STACK_OVERFLOW);
 	return;
     }
     
-    cctx->pAttribStack =
-	realloc (cctx->pAttribStack,
-		 sizeof (xglGLAttributesRec) * (cctx->nAttribStack + 1));
-    
-    if (!cctx->pAttribStack)
-    {
-	xglRecordError (GL_OUT_OF_MEMORY);
-	return;
-    }
-
-    pAttrib = &cctx->pAttribStack[cctx->nAttribStack];
-    pAttrib->mask = pOp->u.bitfield;
+    pAttrib = &cctx->attribStack[cctx->nAttribStack];
     
     *pAttrib = cctx->attrib;
+    pAttrib->mask = pOp->u.bitfield;
     
     if (pOp->u.bitfield & GL_TEXTURE_BIT)
     {
@@ -810,7 +832,7 @@ xglPopAttribProc (xglGLOpPtr pOp)
 
     cctx->nAttribStack--;
     
-    pAttrib = &cctx->pAttribStack[cctx->nAttribStack];
+    pAttrib = &cctx->attribStack[cctx->nAttribStack];
     mask = pAttrib->mask;
 
     if (mask & GL_COLOR_BUFFER_BIT)
@@ -868,10 +890,6 @@ xglPopAttribProc (xglGLOpPtr pOp)
 	   cctx->attrib.texUnits[i].enabled = pAttrib->texUnits[i].enabled;
     }
     
-    cctx->pAttribStack =
-	realloc (cctx->pAttribStack,
-		 sizeof (xglGLAttributesRec) * cctx->nAttribStack);
-    
     glPopAttrib ();
 }
 
@@ -969,7 +987,8 @@ xglGetBooleanv (GLenum	  pname,
     case GL_TEXTURE_BINDING_1D:
     case GL_TEXTURE_BINDING_2D:
     case GL_TEXTURE_BINDING_3D:
-    case GL_TEXTURE_RECTANGLE_NV:
+    case GL_TEXTURE_BINDING_RECTANGLE_NV:
+    case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
 	/* should be safe to fall-through here */
     default:
 	glGetBooleanv (pname, params);
@@ -1024,12 +1043,16 @@ xglGetDoublev (GLenum	pname,
     case GL_TEXTURE_BINDING_1D:
     case GL_TEXTURE_BINDING_2D:
     case GL_TEXTURE_BINDING_3D:
-    case GL_TEXTURE_RECTANGLE_NV:
+    case GL_TEXTURE_BINDING_RECTANGLE_NV:
+    case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
 	params[0] = xglActiveTextureBinding (pname);
 	break;
     case GL_MAX_TEXTURE_UNITS_ARB:
 	params[0] = cctx->maxTexUnits;
 	break;
+    case GL_MAX_ATTRIB_STACK_DEPTH:
+	params[0] = cctx->maxAttribStackDepth;
+	break;
     default:
 	glGetDoublev (pname, params);
     }
@@ -1083,12 +1106,16 @@ xglGetFloatv (GLenum  pname,
     case GL_TEXTURE_BINDING_1D:
     case GL_TEXTURE_BINDING_2D:
     case GL_TEXTURE_BINDING_3D:
-    case GL_TEXTURE_RECTANGLE_NV:
+    case GL_TEXTURE_BINDING_RECTANGLE_NV:
+    case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
 	params[0] = xglActiveTextureBinding (pname);
 	break;
     case GL_MAX_TEXTURE_UNITS_ARB:
 	params[0] = cctx->maxTexUnits;
 	break;
+    case GL_MAX_ATTRIB_STACK_DEPTH:
+	params[0] = cctx->maxAttribStackDepth;
+	break;
     default:
 	glGetFloatv (pname, params);
     }
@@ -1141,12 +1168,16 @@ xglGetIntegerv (GLenum pname,
     case GL_TEXTURE_BINDING_1D:
     case GL_TEXTURE_BINDING_2D:
     case GL_TEXTURE_BINDING_3D:
-    case GL_TEXTURE_RECTANGLE_NV:
+    case GL_TEXTURE_BINDING_RECTANGLE_NV:
+    case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
 	params[0] = xglActiveTextureBinding (pname);
 	break;
     case GL_MAX_TEXTURE_UNITS_ARB:
 	params[0] = cctx->maxTexUnits;
 	break;
+    case GL_MAX_ATTRIB_STACK_DEPTH:
+	params[0] = cctx->maxAttribStackDepth;
+	break;
     default:
 	glGetIntegerv (pname, params);
     }
@@ -1259,9 +1290,12 @@ xglBindTextureProc (xglGLOpPtr pOp)
     
     if (pOp->u.bind_texture.texture)
     {
+	if (!*ppTexObj || pOp->u.bind_texture.texture != (*ppTexObj)->key)
+	{
 	xglTexObjPtr pTexObj;
 
-	pTexObj = (xglTexObjPtr) xglHashLookup (cctx->shared->texObjects,
+	    pTexObj = (xglTexObjPtr)
+		xglHashLookup (cctx->shared->texObjects,
 						pOp->u.bind_texture.texture);
 	if (!pTexObj)
 	{
@@ -1290,6 +1324,7 @@ xglBindTextureProc (xglGLOpPtr pOp)
 
 	glBindTexture (pOp->u.bind_texture.target, pTexObj->name);
     }
+    }
     else
     {
 	xglUnrefTexObj (*ppTexObj);
@@ -1392,7 +1427,7 @@ xglAreTexturesResident (GLsizei	     n,
 	xglTexObjPtr pTexObj;
 	GLboolean    resident;
 	
-	if (textures[i] == 0)
+	if (!textures[i])
 	{
 	    xglRecordError (GL_INVALID_VALUE);
 	    return GL_FALSE;
@@ -1436,6 +1471,9 @@ xglDeleteTextures (GLsizei	n,
     
     while (n--)
     {
+	if (!*textures)
+	    continue;
+
 	pTexObj = (xglTexObjPtr) xglHashLookup (cctx->shared->texObjects,
 						*textures);
 	if (pTexObj)
@@ -1482,7 +1520,7 @@ xglPrioritizeTextures (GLsizei	      n,
 
     for (i = 0; i < n; i++)
     {
-	if (textures[i] <= 0)
+	if (!textures[i])
 	    continue;
 	
 	pTexObj = (xglTexObjPtr) xglHashLookup (cctx->shared->texObjects,
@@ -1807,7 +1845,9 @@ xglDrawList (GLuint list)
 
     while (nBox--)
     {
-	box = *pBox++;
+	XGL_GLX_DRAW_BOX (&box, pBox);
+
+	pBox++;
 
 	if (cctx->attrib.scissorTest)
 	    XGL_GLX_INTERSECT_BOX (&box, &scissor);
@@ -1964,13 +2004,16 @@ xglDeleteLists (GLuint  list,
 	return;
     }
     
-    for (i = 0; i < range; i++)
+    for (i = list; i < list + range; i++)
     {
+	if (!i)
+	    continue;
+
 	pDisplayList = (xglDisplayListPtr)
-	    xglHashLookup (cctx->shared->displayLists, list + i);
+	    xglHashLookup (cctx->shared->displayLists, i);
 	if (pDisplayList)
 	{
-	    xglHashRemove (cctx->shared->displayLists, list + i);
+	    xglHashRemove (cctx->shared->displayLists, i);
 	    xglDestroyList (pDisplayList);
 	}
     }
@@ -1997,15 +2040,18 @@ xglFlush (void)
 {
     glFlush ();
 
-    if (cctx->pDrawBuffer->pDrawable)
+    if (cctx && cctx->pDrawBuffer->pDrawable)
     {
 	xglGLBufferPtr pBuffer = cctx->pDrawBuffer;
     
 	if (REGION_NOTEMPTY (pBuffer->pDrawable->pScreen, &pBuffer->damage))
 	{
-	    xglAddBitDamage (pBuffer->pDrawable, &pBuffer->damage);
+	    XGL_DRAWABLE_PIXMAP_PRIV (pBuffer->pDrawable);
+
 	    DamageDamageRegion (pBuffer->pDrawable, &pBuffer->damage);
 	    REGION_EMPTY (pBuffer->pDrawable->pScreen, &pBuffer->damage);
+
+	    pPixmapPriv->damageBox = miEmptyBox;
 	}
     }
 }
@@ -2015,15 +2061,18 @@ xglFinish (void)
 {
     glFinish ();
 
-    if (cctx->pDrawBuffer->pDrawable)
+    if (cctx && cctx->pDrawBuffer->pDrawable)
     {
 	xglGLBufferPtr pBuffer = cctx->pDrawBuffer;
     
 	if (REGION_NOTEMPTY (pBuffer->pDrawable->pScreen, &pBuffer->damage))
 	{
-	    xglAddBitDamage (pBuffer->pDrawable, &pBuffer->damage);
+	    XGL_DRAWABLE_PIXMAP_PRIV (pBuffer->pDrawable);
+
 	    DamageDamageRegion (pBuffer->pDrawable, &pBuffer->damage);
 	    REGION_EMPTY (pBuffer->pDrawable->pScreen, &pBuffer->damage);
+
+	    pPixmapPriv->damageBox = miEmptyBox;
 	}
     }
 }
@@ -2052,11 +2101,13 @@ xglClear (GLbitfield mask)
 	BoxPtr    pBox;
 	int	  nBox;
     
-	XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
+	XGL_GLX_DRAW_PROLOGUE_WITHOUT_TEXTURES (pBox, nBox, &scissor);
 
 	while (nBox--)
 	{
-	    box = *pBox++;
+	    XGL_GLX_DRAW_BOX (&box, pBox);
+
+	    pBox++;
 	    
 	    if (cctx->attrib.scissorTest)
 		XGL_GLX_INTERSECT_BOX (&box, &scissor);
@@ -2104,11 +2155,13 @@ xglAccum (GLenum  op,
 	    BoxPtr    pBox;
 	    int	      nBox;
     
-	    XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
+	    XGL_GLX_DRAW_PROLOGUE_WITHOUT_TEXTURES (pBox, nBox, &scissor);
     
 	    while (nBox--)
 	    {
-		box = *pBox++;
+		XGL_GLX_DRAW_BOX (&box, pBox);
+
+		pBox++;
 		
 		if (cctx->attrib.scissorTest)
 		    XGL_GLX_INTERSECT_BOX (&box, &scissor);
@@ -2161,7 +2214,9 @@ xglDrawArrays (GLenum  mode,
     
 	while (nBox--)
 	{
-	    box = *pBox++;
+	    XGL_GLX_DRAW_BOX (&box, pBox);
+
+	    pBox++;
 	    
 	    if (cctx->attrib.scissorTest)
 		XGL_GLX_INTERSECT_BOX (&box, &scissor);
@@ -2212,7 +2267,9 @@ xglDrawElements (GLenum	      mode,
 
 	while (nBox--)
 	{
-	    box = *pBox++;
+	    XGL_GLX_DRAW_BOX (&box, pBox);
+
+	    pBox++;
 	    
 	    if (cctx->attrib.scissorTest)
 		XGL_GLX_INTERSECT_BOX (&box, &scissor);
@@ -2264,7 +2321,9 @@ xglDrawPixels (GLsizei	    width,
 
 	while (nBox--)
 	{
-	    box = *pBox++;
+	    XGL_GLX_DRAW_BOX (&box, pBox);
+
+	    pBox++;
 	    
 	    if (cctx->attrib.scissorTest)
 		XGL_GLX_INTERSECT_BOX (&box, &scissor);
@@ -2319,7 +2378,9 @@ xglBitmap (GLsizei	 width,
     
 	while (nBox--)
 	{
-	    box = *pBox++;
+	    XGL_GLX_DRAW_BOX (&box, pBox);
+
+	    pBox++;
 	    
 	    if (cctx->attrib.scissorTest)
 		XGL_GLX_INTERSECT_BOX (&box, &scissor);
@@ -2370,7 +2431,9 @@ xglRectdv (const GLdouble *v1,
     
 	while (nBox--)
 	{
-	    box = *pBox++;
+	    XGL_GLX_DRAW_BOX (&box, pBox);
+
+	    pBox++;
 	    
 	    if (cctx->attrib.scissorTest)
 		XGL_GLX_INTERSECT_BOX (&box, &scissor);
@@ -2438,6 +2501,20 @@ xglRectsv (const GLshort *v1,
 static void
 xglBegin (GLenum mode)
 {
+    if (mode > GL_POLYGON)
+    {
+	xglRecordError (GL_INVALID_ENUM);
+	return;
+    }
+
+    if (cctx->beginCnt)
+    {
+	xglRecordError (GL_INVALID_OPERATION);
+	return;
+    }
+
+    cctx->beginCnt++;
+
     if (cctx->list)
     {
 	glEndList ();
@@ -2445,15 +2522,15 @@ xglBegin (GLenum mode)
     }
     else
     {
-	BoxRec    scissor;
+	if (REGION_NUM_RECTS (cctx->pDrawBuffer->pGC->pCompositeClip) == 1)
+	{
+	    BoxRec scissor, box;
 	BoxPtr    pBox;
 	int	  nBox;
     
 	XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
 	    
-	if (nBox == 1)
-	{
-	    BoxRec box = *pBox;
+	    XGL_GLX_DRAW_BOX (&box, pBox);
 
 	    if (cctx->attrib.scissorTest)
 		XGL_GLX_INTERSECT_BOX (&box, &scissor);
@@ -2475,6 +2552,14 @@ xglBegin (GLenum mode)
 static void
 xglEnd (void)
 {
+    if (!cctx->beginCnt)
+    {
+	xglRecordError (GL_INVALID_OPERATION);
+	return;
+    }
+
+    cctx->beginCnt--;
+
     glEnd ();
     
     if (!cctx->list || cctx->listMode == GL_COMPILE_AND_EXECUTE)
@@ -2483,49 +2568,57 @@ xglEnd (void)
 	BoxRec    scissor, box;
 	BoxPtr    pBox;
 	int	  nBox;
-	GLuint	  list;
-    
-	XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
+	GLuint	  list = 0;
 	
 	if (cctx->list)
 	{
+	    XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
+
 	    list = cctx->pList->pOp[cctx->pList->nOp - 1].u.list;
 	}
 	else
 	{
-	    if (nBox == 1)
+	    if (REGION_NUM_RECTS (cctx->pDrawBuffer->pGC->pCompositeClip) == 1)
 	    {
-		box = *pBox++;
-	    
-		if (cctx->attrib.scissorTest)
-		    XGL_GLX_INTERSECT_BOX (&box, &scissor);
-		
-		XGL_GLX_DRAW_DAMAGE (&box, &region);
-		return;
+		XGL_GLX_DRAW_PROLOGUE_WITHOUT_TEXTURES (pBox, nBox, &scissor);
 	    }
+	    else
+	    {
+		XGL_GLX_DRAW_PROLOGUE (pBox, nBox, &scissor);
 	
 	    list = cctx->groupList;
 	}
+	}
 
+	if (list)
 	glEndList ();
 
 	while (nBox--)
 	{
-	    box = *pBox++;
+	    XGL_GLX_DRAW_BOX (&box, pBox);
+
+	    pBox++;
 	    
 	    if (cctx->attrib.scissorTest)
 		XGL_GLX_INTERSECT_BOX (&box, &scissor);
 	    
 	    if (box.x1 < box.x2 && box.y1 < box.y2)
 	    {
+		if (list)
+		{
 		XGL_GLX_SET_SCISSOR_BOX (&box);
 
 		glCallList (list);
+		}
 		
 		XGL_GLX_DRAW_DAMAGE (&box, &region);
 	    }
 	}
     }
+    else
+    {
+	glEndList ();
+    }
 	
     if (cctx->list)
 	xglStartList (XGL_LIST_OP_CALLS, cctx->listMode);
@@ -2543,7 +2636,9 @@ xglCopyPixelsProc (xglGLOpPtr pOp)
 
     while (nBox--)
     {
-	box = *pBox++;
+	XGL_GLX_DRAW_BOX (&box, pBox);
+
+	pBox++;
 	
 	if (cctx->attrib.scissorTest)
 	    XGL_GLX_INTERSECT_BOX (&box, &scissor);
@@ -2924,86 +3019,380 @@ xglCopyTexSubImage3D (GLenum  target,
     xglGLOp (&gl);
 }
 
-__glProcTable __glNativeRenderTable = {
-    xglNewList, /* glNewList */
-    xglEndList, /* glEndList */
-    xglCallList, /* glCallList */
-    xglCallLists, /* glCallLists */
-    xglDeleteLists, /* glDeleteLists */
-    xglGenLists, /* glGenLists */
+/* GL_ARB_multitexture */
+static void
+xglNoOpActiveTextureARB (GLenum texture) {}
+static void
+xglActiveTextureARBProc (xglGLOpPtr pOp)
+{
+    GLenum texUnit;
+
+    texUnit = pOp->u.enumeration - GL_TEXTURE0;
+    if (texUnit < 0 || texUnit >= cctx->maxTexUnits)
+    {
+	xglRecordError (GL_INVALID_ENUM);
+    }
+    else
+    {
+	cctx->activeTexUnit = texUnit;
+	(*cctx->ActiveTextureARB) (pOp->u.enumeration);
+    }
+}
+static void
+xglActiveTextureARB (GLenum texture)
+{
+    xglGLOpRec gl;
+
+    gl.glProc = xglActiveTextureARBProc;
+
+    gl.u.enumeration = texture;
+
+    xglGLOp (&gl);
+}
+static void
+xglNoOpClientActiveTextureARB (GLenum texture) {}
+static void
+xglNoOpMultiTexCoord1dvARB (GLenum target, const GLdouble *v) {}
+static void
+xglNoOpMultiTexCoord1fvARB (GLenum target, const GLfloat *v) {}
+static void
+xglNoOpMultiTexCoord1ivARB (GLenum target, const GLint *v) {}
+static void
+xglNoOpMultiTexCoord1svARB (GLenum target, const GLshort *v) {}
+static void
+xglNoOpMultiTexCoord2dvARB (GLenum target, const GLdouble *v) {}
+static void
+xglNoOpMultiTexCoord2fvARB (GLenum target, const GLfloat *v) {}
+static void
+xglNoOpMultiTexCoord2ivARB (GLenum target, const GLint *v) {}
+static void
+xglNoOpMultiTexCoord2svARB (GLenum target, const GLshort *v) {}
+static void
+xglNoOpMultiTexCoord3dvARB (GLenum target, const GLdouble *v) {}
+static void
+xglNoOpMultiTexCoord3fvARB (GLenum target, const GLfloat *v) {}
+static void
+xglNoOpMultiTexCoord3ivARB (GLenum target, const GLint *v) {}
+static void
+xglNoOpMultiTexCoord3svARB (GLenum target, const GLshort *v) {}
+static void
+xglNoOpMultiTexCoord4dvARB (GLenum target, const GLdouble *v) {}
+static void
+xglNoOpMultiTexCoord4fvARB (GLenum target, const GLfloat *v) {}
+static void
+xglNoOpMultiTexCoord4ivARB (GLenum target, const GLint *v) {}
+static void
+xglNoOpMultiTexCoord4svARB (GLenum target, const GLshort *v) {}
+
+/* GL_ARB_multisample */
+static void
+xglNoOpSampleCoverageARB (GLclampf value, GLboolean invert) {}
+
+/* GL_EXT_texture_object */
+static GLboolean
+xglNoOpAreTexturesResidentEXT (GLsizei n,
+			       const GLuint *textures,
+			       GLboolean *residences)
+{
+    return GL_FALSE;
+}
+static void
+xglNoOpGenTexturesEXT (GLsizei n, GLuint *textures) {}
+static GLboolean
+xglNoOpIsTextureEXT (GLuint texture)
+{
+    return GL_FALSE;
+}
+
+/* GL_SGIS_multisample */
+static void
+xglNoOpSampleMaskSGIS (GLclampf value, GLboolean invert) {}
+static void
+xglNoOpSamplePatternSGIS (GLenum pattern) {}
+
+/* GL_EXT_point_parameters */
+static void
+xglNoOpPointParameterfEXT (GLenum pname, GLfloat param) {}
+static void
+xglNoOpPointParameterfvEXT (GLenum pname, const GLfloat *params) {}
+
+/* GL_MESA_window_pos */
+static void
+xglNoOpWindowPos3fMESA (GLfloat x, GLfloat y, GLfloat z) {}
+static void
+xglWindowPos3fMESAProc (xglGLOpPtr pOp)
+{
+    (*cctx->WindowPos3fMESA) (pOp->u.window_pos_3f.x + cctx->pDrawBuffer->xOff,
+			      pOp->u.window_pos_3f.y + cctx->pDrawBuffer->yOff,
+			      pOp->u.window_pos_3f.z);
+}
+static void
+xglWindowPos3fMESA (GLfloat x, GLfloat y, GLfloat z)
+{
+    xglGLOpRec gl;
+
+    gl.glProc = xglWindowPos3fMESAProc;
+
+    gl.u.window_pos_3f.x = x;
+    gl.u.window_pos_3f.y = y;
+    gl.u.window_pos_3f.z = z;
+
+    xglGLOp (&gl);
+}
+
+/* GL_EXT_blend_func_separate */
+static void
+xglNoOpBlendFuncSeparateEXT (GLenum sfactorRGB, GLenum dfactorRGB,
+			     GLenum sfactorAlpha, GLenum dfactorAlpha) {}
+
+/* GL_EXT_fog_coord */
+static void
+xglNoOpFogCoordfvEXT (const GLfloat *coord) {}
+static void
+xglNoOpFogCoorddvEXT (const GLdouble *coord) {}
+static void
+xglNoOpFogCoordPointerEXT (GLenum type, GLsizei stride,
+			   const GLvoid *pointer) {}
+
+/* GL_EXT_secondary_color */
+static void
+xglNoOpSecondaryColor3bvEXT (const GLbyte *v) {}
+static void
+xglNoOpSecondaryColor3dvEXT (const GLdouble *v) {}
+static void
+xglNoOpSecondaryColor3fvEXT (const GLfloat *v) {}
+static void
+xglNoOpSecondaryColor3ivEXT (const GLint *v) {}
+static void
+xglNoOpSecondaryColor3svEXT (const GLshort *v) {}
+static void
+xglNoOpSecondaryColor3ubvEXT (const GLubyte *v) {}
+static void
+xglNoOpSecondaryColor3uivEXT (const GLuint *v) {}
+static void
+xglNoOpSecondaryColor3usvEXT (const GLushort *v) {}
+static void
+xglNoOpSecondaryColorPointerEXT (GLint size, GLenum type, GLsizei stride,
+				 const GLvoid *pointer) {}
+
+/* GL_NV_point_sprite */
+static void
+xglNoOpPointParameteriNV (GLenum pname, GLint params) {}
+static void
+xglNoOpPointParameterivNV (GLenum pname, const GLint *params) {}
+
+/* GL_EXT_stencil_two_side */
+static void
+xglNoOpActiveStencilFaceEXT (GLenum face) {}
+
+/* GL_EXT_framebuffer_object */
+static GLboolean
+xglNoOpIsRenderbufferEXT (GLuint renderbuffer)
+{
+    return FALSE;
+}
+static void
+xglNoOpBindRenderbufferEXT (GLenum target, GLuint renderbuffer) {}
+static void
+xglNoOpDeleteRenderbuffersEXT (GLsizei n, const GLuint *renderbuffers) {}
+static void
+xglNoOpGenRenderbuffersEXT (GLsizei n, GLuint *renderbuffers) {}
+static void
+xglNoOpRenderbufferStorageEXT (GLenum target, GLenum internalformat,
+			       GLsizei width, GLsizei height) {}
+static void
+xglNoOpGetRenderbufferParameterivEXT (GLenum target, GLenum pname,
+				      GLint *params) {}
+static GLboolean
+xglNoOpIsFramebufferEXT (GLuint framebuffer)
+{
+    return FALSE;
+}
+static void
+xglNoOpBindFramebufferEXT (GLenum target, GLuint framebuffer) {}
+static void
+xglNoOpDeleteFramebuffersEXT (GLsizei n, const GLuint *framebuffers) {}
+static void
+xglNoOpGenFramebuffersEXT (GLsizei n, GLuint *framebuffers) {}
+static GLenum
+xglNoOpCheckFramebufferStatusEXT (GLenum target)
+{
+    return GL_FRAMEBUFFER_UNSUPPORTED_EXT;
+}
+static void
+xglNoOpFramebufferTexture1DEXT (GLenum target, GLenum attachment,
+				GLenum textarget, GLuint texture,
+				GLint level) {}
+static void
+xglNoOpFramebufferTexture2DEXT (GLenum target, GLenum attachment,
+				GLenum textarget, GLuint texture,
+				GLint level) {}
+static void
+xglNoOpFramebufferTexture3DEXT (GLenum target, GLenum attachment,
+				GLenum textarget, GLuint texture,
+				GLint level, GLint zoffset) {}
+static void
+xglNoOpFramebufferRenderbufferEXT (GLenum target, GLenum attachment,
+				   GLenum renderbuffertarget,
+				   GLuint renderbuffer) {}
+static void
+xglNoOpGetFramebufferAttachmentParameterivEXT (GLenum target,
+					       GLenum attachment,
+					       GLenum pname,
+					       GLint *params) {}
+static void
+xglNoOpGenerateMipmapEXT (GLenum target) {}
+
+static struct _glapi_table __glNativeRenderTable = {
+    xglNewList,
+    xglEndList,
+    xglCallList,
+    xglCallLists,
+    xglDeleteLists,
+    xglGenLists,
     glListBase,
-    xglBegin, /* glBegin */
-    xglBitmap, /* glBitmap */
+    xglBegin,
+    xglBitmap,
+    0, /* glColor3b */
     glColor3bv,
+    0, /* glColor3d */
     glColor3dv,
+    0, /* glColor3f */
     glColor3fv,
+    0, /* glColor3i */
     glColor3iv,
+    0, /* glColor3s */
     glColor3sv,
+    0, /* glColor3ub */
     glColor3ubv,
+    0, /* glColor3ui */
     glColor3uiv,
+    0, /* glColor3us */
     glColor3usv,
+    0, /* glColor4b */
     glColor4bv,
+    0, /* glColor4d */
     glColor4dv,
+    0, /* glColor4f */
     glColor4fv,
+    0, /* glColor4i */
     glColor4iv,
+    0, /* glColor4s */
     glColor4sv,
+    0, /* glColor4ub */
     glColor4ubv,
+    0, /* glColor4ui */
     glColor4uiv,
+    0, /* glColor4us */
     glColor4usv,
+    0, /* glEdgeFlag */
     glEdgeFlagv,
-    xglEnd, /* glEnd */
+    xglEnd,
+    0, /* glIndexd */
     glIndexdv,
+    0, /* glIndexf */
     glIndexfv,
+    0, /* glIndexi */
     glIndexiv,
+    0, /* glIndexs */
     glIndexsv,
+    0, /* glNormal3b */
     glNormal3bv,
+    0, /* glNormal3d */
     glNormal3dv,
+    0, /* glNormal3f */
     glNormal3fv,
+    0, /* glNormal3i */
     glNormal3iv,
+    0, /* glNormal3s */
     glNormal3sv,
+    0, /* glRasterPos2d */
     glRasterPos2dv,
+    0, /* glRasterPos2f */
     glRasterPos2fv,
+    0, /* glRasterPos2i */
     glRasterPos2iv,
+    0, /* glRasterPos2s */
     glRasterPos2sv,
+    0, /* glRasterPos3d */
     glRasterPos3dv,
+    0, /* glRasterPos3f */
     glRasterPos3fv,
+    0, /* glRasterPos3i */
     glRasterPos3iv,
+    0, /* glRasterPos3s */
     glRasterPos3sv,
+    0, /* glRasterPos4d */
     glRasterPos4dv,
+    0, /* glRasterPos4f */
     glRasterPos4fv,
+    0, /* glRasterPos4i */
     glRasterPos4iv,
+    0, /* glRasterPos4s */
     glRasterPos4sv,
-    xglRectdv, /* glRectdv */
-    xglRectfv, /* glRectfv */
-    xglRectiv, /* glRectiv */
-    xglRectsv, /* glRectsv */
+    0, /* glRectd */
+    xglRectdv,
+    0, /* glRectf */
+    xglRectfv,
+    0, /* glRecti */
+    xglRectiv,
+    0, /* glRects */
+    xglRectsv,
+    0, /* glTexCoord1d */
     glTexCoord1dv,
+    0, /* glTexCoord1f */
     glTexCoord1fv,
+    0, /* glTexCoord1i */
     glTexCoord1iv,
+    0, /* glTexCoord1s */
     glTexCoord1sv,
+    0, /* glTexCoord2d */
     glTexCoord2dv,
+    0, /* glTexCoord2f */
     glTexCoord2fv,
+    0, /* glTexCoord2i */
     glTexCoord2iv,
+    0, /* glTexCoord2s */
     glTexCoord2sv,
+    0, /* glTexCoord3d */
     glTexCoord3dv,
+    0, /* glTexCoord3f */
     glTexCoord3fv,
+    0, /* glTexCoord3i */
     glTexCoord3iv,
+    0, /* glTexCoord3s */
     glTexCoord3sv,
+    0, /* glTexCoord4d */
     glTexCoord4dv,
+    0, /* glTexCoord4f */
     glTexCoord4fv,
+    0, /* glTexCoord4i */
     glTexCoord4iv,
+    0, /* glTexCoord4s */
     glTexCoord4sv,
+    0, /* glVertex2d */
     glVertex2dv,
+    0, /* glVertex2f */
     glVertex2fv,
+    0, /* glVertex2i */
     glVertex2iv,
+    0, /* glVertex2s */
     glVertex2sv,
+    0, /* glVertex3d */
     glVertex3dv,
+    0, /* glVertex3f */
     glVertex3fv,
+    0, /* glVertex3i */
     glVertex3iv,
+    0, /* glVertex3s */
     glVertex3sv,
+    0, /* glVertex4d */
     glVertex4dv,
+    0, /* glVertex4f */
     glVertex4fv,
+    0, /* glVertex4i */
     glVertex4iv,
+    0, /* glVertex4s */
     glVertex4sv,
     glClipPlane,
     glColorMaterial,
@@ -3031,12 +3420,12 @@ __glProcTable __glNativeRenderTable = {
     glPointSize,
     glPolygonMode,
     glPolygonStipple,
-    xglScissor, /* glScissor */
+    xglScissor,
     glShadeModel,
-    xglTexParameterf, /* glTexParameterf */
-    xglTexParameterfv, /* glTexParameterfv */
-    xglTexParameteri, /* glTexParameteri */
-    xglTexParameteriv, /* glTexParameteriv */
+    xglTexParameterf,
+    xglTexParameterfv,
+    xglTexParameteri,
+    xglTexParameteriv,
     glTexImage1D,
     glTexImage2D,
     glTexEnvf,
@@ -3057,8 +3446,8 @@ __glProcTable __glNativeRenderTable = {
     glPassThrough,
     glPopName,
     glPushName,
-    xglDrawBuffer, /* glDrawBuffer */
-    xglClear, /* glClear */
+    xglDrawBuffer,
+    xglClear,
     glClearAccum,
     glClearIndex,
     glClearColor,
@@ -3068,13 +3457,13 @@ __glProcTable __glNativeRenderTable = {
     glColorMask,
     glDepthMask,
     glIndexMask,
-    xglAccum, /* glAccum */
-    xglDisable, /* glDisable */
-    xglEnable, /* glEnable */
-    xglFinish, /* glFinish */
-    xglFlush, /* glFlush */
-    xglPopAttrib, /* glPopAttrib */
-    xglPushAttrib, /* glPushAttrib */
+    xglAccum,
+    xglDisable,
+    xglEnable,
+    xglFinish,
+    xglFlush,
+    xglPopAttrib,
+    xglPushAttrib,
     glMap1d,
     glMap1f,
     glMap2d,
@@ -3083,9 +3472,13 @@ __glProcTable __glNativeRenderTable = {
     glMapGrid1f,
     glMapGrid2d,
     glMapGrid2f,
+    0, /* glEvalCoord1d */
     glEvalCoord1dv,
+    0, /* glEvalCoord1f */
     glEvalCoord1fv,
+    0, /* glEvalCoord2d */
     glEvalCoord2dv,
+    0, /* glEvalCoord2f */
     glEvalCoord2fv,
     glEvalMesh1,
     glEvalPoint1,
@@ -3105,16 +3498,16 @@ __glProcTable __glNativeRenderTable = {
     glPixelMapfv,
     glPixelMapuiv,
     glPixelMapusv,
-    xglReadBuffer, /* glReadBuffer */
-    xglCopyPixels, /* glCopyPixels */
-    xglReadPixels, /* glReadPixels */
-    xglDrawPixels, /* glDrawPixels */
-    xglGetBooleanv, /* glGetBooleanv */
+    xglReadBuffer,
+    xglCopyPixels,
+    xglReadPixels,
+    xglDrawPixels,
+    xglGetBooleanv,
     glGetClipPlane,
-    xglGetDoublev, /* glGetDoublev */
-    xglGetError, /* glGetError */
-    xglGetFloatv, /* glGetFloatv */
-    xglGetIntegerv, /* glGetIntegerv */
+    xglGetDoublev,
+    xglGetError,
+    xglGetFloatv,
+    xglGetIntegerv,
     glGetLightfv,
     glGetLightiv,
     glGetMapdv,
@@ -3126,7 +3519,7 @@ __glProcTable __glNativeRenderTable = {
     glGetPixelMapuiv,
     glGetPixelMapusv,
     glGetPolygonStipple,
-    xglGetString, /* glGetString */
+    xglGetString,
     glGetTexEnvfv,
     glGetTexEnviv,
     glGetTexGendv,
@@ -3135,10 +3528,10 @@ __glProcTable __glNativeRenderTable = {
     glGetTexImage,
     glGetTexParameterfv,
     glGetTexParameteriv,
-    xglGetTexLevelParameterfv, /* glGetTexLevelParameterfv */
-    xglGetTexLevelParameteriv, /* glGetTexLevelParameteriv */
-    xglIsEnabled, /* glIsEnabled */
-    xglIsList, /* glIsList */
+    xglGetTexLevelParameterfv,
+    xglGetTexLevelParameteriv,
+    xglIsEnabled,
+    xglIsList,
     glDepthRange,
     glFrustum,
     glLoadIdentity,
@@ -3156,55 +3549,57 @@ __glProcTable __glNativeRenderTable = {
     glScalef,
     glTranslated,
     glTranslatef,
-    xglViewport, /* glViewport */
+    xglViewport,
     glArrayElement,
-    xglBindTexture, /* glBindTexture */
+    xglBindTexture,
     glColorPointer,
     glDisableClientState,
-    xglDrawArrays, /* glDrawArrays */
-    xglDrawElements, /* glDrawElements */
+    xglDrawArrays,
+    xglDrawElements,
     glEdgeFlagPointer,
     glEnableClientState,
     glIndexPointer,
+    0, /* glIndexub */
     glIndexubv,
     glInterleavedArrays,
     glNormalPointer,
     glPolygonOffset,
     glTexCoordPointer,
     glVertexPointer,
-    xglAreTexturesResident, /* glAreTexturesResident */
-    xglCopyTexImage1D, /* glCopyTexImage1D */
-    xglCopyTexImage2D, /* glCopyTexImage2D */
-    xglCopyTexSubImage1D, /* glCopyTexSubImage1D */
-    xglCopyTexSubImage2D, /* glCopyTexSubImage2D */
-    xglDeleteTextures, /* glDeleteTextures */
-    xglGenTextures, /* glGenTextures */
+    xglAreTexturesResident,
+    xglCopyTexImage1D,
+    xglCopyTexImage2D,
+    xglCopyTexSubImage1D,
+    xglCopyTexSubImage2D,
+    xglDeleteTextures,
+    xglGenTextures,
     glGetPointerv,
-    xglIsTexture, /* glIsTexture */
-    xglPrioritizeTextures, /* glPrioritizeTextures */
+    xglIsTexture,
+    xglPrioritizeTextures,
     glTexSubImage1D,
     glTexSubImage2D,
     glPopClientAttrib,
     glPushClientAttrib,
     glBlendColor,
     glBlendEquation,
+    0, /* glDrawRangeElements */
     glColorTable,
     glColorTableParameterfv,
     glColorTableParameteriv,
-    xglCopyColorTable, /* glCopyColorTable */
+    xglCopyColorTable,
     glGetColorTable,
     glGetColorTableParameterfv,
     glGetColorTableParameteriv,
     glColorSubTable,
-    xglCopyColorSubTable, /* glCopyColorSubTable */
+    xglCopyColorSubTable,
     glConvolutionFilter1D,
     glConvolutionFilter2D,
     glConvolutionParameterf,
     glConvolutionParameterfv,
     glConvolutionParameteri,
     glConvolutionParameteriv,
-    xglCopyConvolutionFilter1D, /* glCopyConvolutionFilter1D */
-    xglCopyConvolutionFilter2D, /* glCopyConvolutionFilter2D */
+    xglCopyConvolutionFilter1D,
+    xglCopyConvolutionFilter2D,
     glGetConvolutionFilter,
     glGetConvolutionParameterfv,
     glGetConvolutionParameteriv,
@@ -3222,278 +3617,429 @@ __glProcTable __glNativeRenderTable = {
     glResetMinmax,
     glTexImage3D,
     glTexSubImage3D,
-    xglCopyTexSubImage3D /* glCopyTexSubImage3D */
-};
-
-/* GL_ARB_multitexture */
-static void
-xglNoOpActiveTextureARB (GLenum texture) {}
-static void
-xglActiveTextureARBProc (xglGLOpPtr pOp)
-{
-    GLenum texUnit;
-
-    texUnit = pOp->u.enumeration - GL_TEXTURE0;
-    if (texUnit < 0 || texUnit >= cctx->maxTexUnits)
-    {
-	xglRecordError (GL_INVALID_ENUM);
-    }
-    else
-    {
-	cctx->activeTexUnit = texUnit;
-	(*cctx->ActiveTextureARB) (pOp->u.enumeration);
-    }
-}
-static void
-xglActiveTextureARB (GLenum texture)
-{
-    xglGLOpRec gl;
-    
-    gl.glProc = xglActiveTextureARBProc;
-
-    gl.u.enumeration = texture;
-
-    xglGLOp (&gl);
-}
-static void
-xglNoOpClientActiveTextureARB (GLenum texture) {}
-static void
-xglNoOpMultiTexCoord1dvARB (GLenum target, const GLdouble *v) {}
-static void
-xglNoOpMultiTexCoord1fvARB (GLenum target, const GLfloat *v) {}
-static void
-xglNoOpMultiTexCoord1ivARB (GLenum target, const GLint *v) {}
-static void
-xglNoOpMultiTexCoord1svARB (GLenum target, const GLshort *v) {}
-static void
-xglNoOpMultiTexCoord2dvARB (GLenum target, const GLdouble *v) {}
-static void
-xglNoOpMultiTexCoord2fvARB (GLenum target, const GLfloat *v) {}
-static void
-xglNoOpMultiTexCoord2ivARB (GLenum target, const GLint *v) {}
-static void
-xglNoOpMultiTexCoord2svARB (GLenum target, const GLshort *v) {}
-static void
-xglNoOpMultiTexCoord3dvARB (GLenum target, const GLdouble *v) {}
-static void
-xglNoOpMultiTexCoord3fvARB (GLenum target, const GLfloat *v) {}
-static void
-xglNoOpMultiTexCoord3ivARB (GLenum target, const GLint *v) {}
-static void
-xglNoOpMultiTexCoord3svARB (GLenum target, const GLshort *v) {}
-static void
-xglNoOpMultiTexCoord4dvARB (GLenum target, const GLdouble *v) {}
-static void
-xglNoOpMultiTexCoord4fvARB (GLenum target, const GLfloat *v) {}
-static void
-xglNoOpMultiTexCoord4ivARB (GLenum target, const GLint *v) {}
-static void
-xglNoOpMultiTexCoord4svARB (GLenum target, const GLshort *v) {}
-
-/* GL_ARB_multisample */
-static void
-xglNoOpSampleCoverageARB (GLclampf value, GLboolean invert) {}
-
-/* GL_EXT_texture_object */
-static GLboolean
-xglNoOpAreTexturesResidentEXT (GLsizei n,
-			       const GLuint *textures,
-			       GLboolean *residences)
-{
-    return GL_FALSE;
-}
-static void
-xglNoOpGenTexturesEXT (GLsizei n, GLuint *textures) {}
-static GLboolean
-xglNoOpIsTextureEXT (GLuint texture)
-{
-    return GL_FALSE;
-}
-
-/* GL_SGIS_multisample */
-static void
-xglNoOpSampleMaskSGIS (GLclampf value, GLboolean invert) {}
-static void
-xglNoOpSamplePatternSGIS (GLenum pattern) {}
-
-/* GL_EXT_point_parameters */
-static void
-xglNoOpPointParameterfEXT (GLenum pname, GLfloat param) {}
-static void
-xglNoOpPointParameterfvEXT (GLenum pname, const GLfloat *params) {}
-
-/* GL_MESA_window_pos */
-static void
-xglNoOpWindowPos3fMESA (GLfloat x, GLfloat y, GLfloat z) {}
-static void
-xglWindowPos3fMESAProc (xglGLOpPtr pOp)
-{
-    (*cctx->WindowPos3fMESA) (pOp->u.window_pos_3f.x + cctx->pDrawBuffer->xOff,
-			      pOp->u.window_pos_3f.y + cctx->pDrawBuffer->yOff,
-			      pOp->u.window_pos_3f.z);
-}
-static void
-xglWindowPos3fMESA (GLfloat x, GLfloat y, GLfloat z)
-{
-    xglGLOpRec gl;
-    
-    gl.glProc = xglWindowPos3fMESAProc;
-
-    gl.u.window_pos_3f.x = x;
-    gl.u.window_pos_3f.y = y;
-    gl.u.window_pos_3f.z = z;
-
-    xglGLOp (&gl);
-}
-
-/* GL_EXT_blend_func_separate */
-static void
-xglNoOpBlendFuncSeparateEXT (GLenum sfactorRGB, GLenum dfactorRGB,
-			     GLenum sfactorAlpha, GLenum dfactorAlpha) {}
-
-/* GL_EXT_fog_coord */ 
-static void
-xglNoOpFogCoordfvEXT (const GLfloat *coord) {}
-static void
-xglNoOpFogCoorddvEXT (const GLdouble *coord) {}
-static void
-xglNoOpFogCoordPointerEXT (GLenum type, GLsizei stride,
-			   const GLvoid *pointer) {}
-
-/* GL_EXT_secondary_color */
-static void
-xglNoOpSecondaryColor3bvEXT (const GLbyte *v) {}
-static void
-xglNoOpSecondaryColor3dvEXT (const GLdouble *v) {}
-static void
-xglNoOpSecondaryColor3fvEXT (const GLfloat *v) {}
-static void
-xglNoOpSecondaryColor3ivEXT (const GLint *v) {}
-static void
-xglNoOpSecondaryColor3svEXT (const GLshort *v) {}
-static void
-xglNoOpSecondaryColor3ubvEXT (const GLubyte *v) {}
-static void
-xglNoOpSecondaryColor3uivEXT (const GLuint *v) {}
-static void
-xglNoOpSecondaryColor3usvEXT (const GLushort *v) {}
-static void
-xglNoOpSecondaryColorPointerEXT (GLint size, GLenum type, GLsizei stride,
-				 const GLvoid *pointer) {}
-
-/* GL_NV_point_sprite */
-static void
-xglNoOpPointParameteriNV (GLenum pname, GLint params) {}
-static void
-xglNoOpPointParameterivNV (GLenum pname, const GLint *params) {}
-
-/* GL_EXT_stencil_two_side */
-static void
-xglNoOpActiveStencilFaceEXT (GLenum face) {}
-
-/* GL_EXT_framebuffer_object */
-static GLboolean
-xglNoOpIsRenderbufferEXT (GLuint renderbuffer)
-{
-    return FALSE;
-}
-static void
-xglNoOpBindRenderbufferEXT (GLenum target, GLuint renderbuffer) {}
-static void
-xglNoOpDeleteRenderbuffersEXT (GLsizei n, const GLuint *renderbuffers) {}
-static void
-xglNoOpGenRenderbuffersEXT (GLsizei n, GLuint *renderbuffers) {}
-static void
-xglNoOpRenderbufferStorageEXT (GLenum target, GLenum internalformat,
-			       GLsizei width, GLsizei height) {}
-static void
-xglNoOpGetRenderbufferParameterivEXT (GLenum target, GLenum pname,
-				      GLint *params) {}
-static GLboolean
-xglNoOpIsFramebufferEXT (GLuint framebuffer)
-{
-    return FALSE;
-}
-static void
-xglNoOpBindFramebufferEXT (GLenum target, GLuint framebuffer) {}
-static void
-xglNoOpDeleteFramebuffersEXT (GLsizei n, const GLuint *framebuffers) {}
-static void
-xglNoOpGenFramebuffersEXT (GLsizei n, GLuint *framebuffers) {}
-static GLenum
-xglNoOpCheckFramebufferStatusEXT (GLenum target)
-{
-    return GL_FRAMEBUFFER_UNSUPPORTED_EXT;
-}
-static void
-xglNoOpFramebufferTexture1DEXT (GLenum target, GLenum attachment,
-				GLenum textarget, GLuint texture,
-				GLint level) {}
-static void
-xglNoOpFramebufferTexture2DEXT (GLenum target, GLenum attachment,
-				GLenum textarget, GLuint texture,
-				GLint level) {}
-static void
-xglNoOpFramebufferTexture3DEXT (GLenum target, GLenum attachment,
-				GLenum textarget, GLuint texture,
-				GLint level, GLint zoffset) {}
-static void
-xglNoOpFramebufferRenderbufferEXT (GLenum target, GLenum attachment,
-				   GLenum renderbuffertarget,
-				   GLuint renderbuffer) {}
-static void
-xglNoOpGetFramebufferAttachmentParameterivEXT (GLenum target,
-					       GLenum attachment,
-					       GLenum pname,
-					       GLint *params) {}
-static void
-xglNoOpGenerateMipmapEXT (GLenum target) {}
-
-
-__glProcTableEXT __glNoOpRenderTableEXT = {
+    xglCopyTexSubImage3D,
     xglNoOpActiveTextureARB,
     xglNoOpClientActiveTextureARB,
+    0, /* glMultiTexCoord1dARB */
     xglNoOpMultiTexCoord1dvARB,
+    0, /* glMultiTexCoord1fARB */
     xglNoOpMultiTexCoord1fvARB,
+    0, /* glMultiTexCoord1iARB */
     xglNoOpMultiTexCoord1ivARB,
+    0, /* glMultiTexCoord1sARB */
     xglNoOpMultiTexCoord1svARB,
+    0, /* glMultiTexCoord2dARB */
     xglNoOpMultiTexCoord2dvARB,
+    0, /* glMultiTexCoord2fARB */
     xglNoOpMultiTexCoord2fvARB,
+    0, /* glMultiTexCoord2iARB */
     xglNoOpMultiTexCoord2ivARB,
+    0, /* glMultiTexCoord2sARB */
     xglNoOpMultiTexCoord2svARB,
+    0, /* glMultiTexCoord3dARB */
     xglNoOpMultiTexCoord3dvARB,
+    0, /* glMultiTexCoord3fARB */
     xglNoOpMultiTexCoord3fvARB,
+    0, /* glMultiTexCoord3iARB */
     xglNoOpMultiTexCoord3ivARB,
+    0, /* glMultiTexCoord3sARB */
     xglNoOpMultiTexCoord3svARB,
+    0, /* glMultiTexCoord4dARB */
     xglNoOpMultiTexCoord4dvARB,
+    0, /* glMultiTexCoord4fARB */
     xglNoOpMultiTexCoord4fvARB,
+    0, /* glMultiTexCoord4iARB */
     xglNoOpMultiTexCoord4ivARB,
+    0, /* glMultiTexCoord4sARB */
     xglNoOpMultiTexCoord4svARB,
+    0, /* glLoadTransposeMatrixfARB */
+    0, /* glLoadTransposeMatrixdARB */
+    0, /* glMultTransposeMatrixfARB */
+    0, /* glMultTransposeMatrixdARB */
     xglNoOpSampleCoverageARB,
+    0, /* glDrawBuffersARB */
+    0, /* glPolygonOffsetEXT */
+    0, /* glGetTexFilterFuncSGIS */
+    0, /* glTexFilterFuncSGIS */
+    0, /* glGetHistogramEXT */
+    0, /* glGetHistogramParameterfvEXT */
+    0, /* glGetHistogramParameterivEXT */
+    0, /* glGetMinmaxEXT */
+    0, /* glGetMinmaxParameterfvEXT */
+    0, /* glGetMinmaxParameterivEXT */
+    0, /* glGetConvolutionFilterEXT */
+    0, /* glGetConvolutionParameterfvEXT */
+    0, /* glGetConvolutionParameterivEXT */
+    0, /* glGetSeparableFilterEXT */
+    0, /* glGetColorTableSGI */
+    0, /* glGetColorTableParameterfvSGI */
+    0, /* glGetColorTableParameterivSGI */
+    0, /* glPixelTexGenSGIX */
+    0, /* glPixelTexGenParameteriSGIS */
+    0, /* glPixelTexGenParameterivSGIS */
+    0, /* glPixelTexGenParameterfSGIS */
+    0, /* glPixelTexGenParameterfvSGIS */
+    0, /* glGetPixelTexGenParameterivSGIS */
+    0, /* glGetPixelTexGenParameterfvSGIS */
+    0, /* glTexImage4DSGIS */
+    0, /* glTexSubImage4DSGIS */
     xglNoOpAreTexturesResidentEXT,
     xglNoOpGenTexturesEXT,
     xglNoOpIsTextureEXT,
+    0, /* glDetailTexFuncSGIS */
+    0, /* glGetDetailTexFuncSGIS */
+    0, /* glSharpenTexFuncSGIS */
+    0, /* glGetSharpenTexFuncSGIS */
     xglNoOpSampleMaskSGIS,
     xglNoOpSamplePatternSGIS,
+    0, /* glColorPointerEXT */
+    0, /* glEdgeFlagPointerEXT */
+    0, /* glIndexPointerEXT */
+    0, /* glNormalPointerEXT */
+    0, /* glTexCoordPointerEXT */
+    0, /* glVertexPointerEXT */
+    0, /* glSpriteParameterfSGIX */
+    0, /* glSpriteParameterfvSGIX */
+    0, /* glSpriteParameteriSGIX */
+    0, /* glSpriteParameterivSGIX */
     xglNoOpPointParameterfEXT,
     xglNoOpPointParameterfvEXT,
+    0, /* glGetInstrumentsSGIX */
+    0, /* glInstrumentsBufferSGIX */
+    0, /* glPollInstrumentsSGIX */
+    0, /* glReadInstrumentsSGIX */
+    0, /* glStartInstrumentsSGIX */
+    0, /* glStopInstrumentsSGIX */
+    0, /* glFrameZoomSGIX */
+    0, /* glTagSampleBufferSGIX */
+    0, /* glReferencePlaneSGIX */
+    0, /* glFlushRasterSGIX */
+    0, /* glGetListParameterfvSGIX */
+    0, /* glGetListParameterivSGIX */
+    0, /* glListParameterfSGIX */
+    0, /* glListParameterfvSGIX */
+    0, /* glListParameteriSGIX */
+    0, /* glListParameterivSGIX */
+    0, /* glFragmentColorMaterialSGIX */
+    0, /* glFragmentLightfSGIX */
+    0, /* glFragmentLightfvSGIX */
+    0, /* glFragmentLightiSGIX */
+    0, /* glFragmentLightivSGIX */
+    0, /* glFragmentLightModelfSGIX */
+    0, /* glFragmentLightModelfvSGIX */
+    0, /* glFragmentLightModeliSGIX */
+    0, /* glFragmentLightModelivSGIX */
+    0, /* glFragmentMaterialfSGIX */
+    0, /* glFragmentMaterialfvSGIX */
+    0, /* glFragmentMaterialiSGIX */
+    0, /* glFragmentMaterialivSGIX */
+    0, /* glGetFragmentLightfvSGIX */
+    0, /* glGetFragmentLightivSGIX */
+    0, /* glGetFragmentMaterialfvSGIX */
+    0, /* glGetFragmentMaterialivSGIX */
+    0, /* glLightEnviSGIX */
+    0, /* glVertexWeightfEXT */
+    0, /* glVertexWeightfvEXT */
+    0, /* glVertexWeightPointerEXT */
+    0, /* glFlushVertexArrayRangeNV */
+    0, /* glVertexArrayRangeNV */
+    0, /* glCombinerParameterfvNV */
+    0, /* glCombinerParameterfNV */
+    0, /* glCombinerParameterivNV */
+    0, /* glCombinerParameteriNV */
+    0, /* glCombinerInputNV */
+    0, /* glCombinerOutputNV */
+    0, /* glFinalCombinerInputNV */
+    0, /* glGetCombinerInputParameterfvNV */
+    0, /* glGetCombinerInputParameterivNV */
+    0, /* glGetCombinerOutputParameterfvNV */
+    0, /* glGetCombinerOutputParameterivNV */
+    0, /* glGetFinalCombinerInputParameterfvNV */
+    0, /* glGetFinalCombinerInputParameterivNV */
+    0, /* glResizeBuffersMESA */
+    0, /* glWindowPos2dMESA */
+    0, /* glWindowPos2dvMESA */
+    0, /* glWindowPos2fMESA */
+    0, /* glWindowPos2fvMESA */
+    0, /* glWindowPos2iMESA */
+    0, /* glWindowPos2ivMESA */
+    0, /* glWindowPos2sMESA */
+    0, /* glWindowPos2svMESA */
+    0, /* glWindowPos3dMESA */
+    0, /* glWindowPos3dvMESA */
     xglNoOpWindowPos3fMESA,
+    0, /* glWindowPos3fvMESA */
+    0, /* glWindowPos3iMESA */
+    0, /* glWindowPos3ivMESA */
+    0, /* glWindowPos3sMESA */
+    0, /* glWindowPos3svMESA */
+    0, /* glWindowPos4dMESA */
+    0, /* glWindowPos4dvMESA */
+    0, /* glWindowPos4fMESA */
+    0, /* glWindowPos4fvMESA */
+    0, /* glWindowPos4iMESA */
+    0, /* glWindowPos4ivMESA */
+    0, /* glWindowPos4sMESA */
+    0, /* glWindowPos4svMESA */
     xglNoOpBlendFuncSeparateEXT,
+    0, /* glIndexMaterialEXT */
+    0, /* glIndexFuncEXT */
+    0, /* glLockArraysEXT */
+    0, /* glUnlockArraysEXT */
+    0, /* glCullParameterdvEXT */
+    0, /* glCullParameterfvEXT */
+    0, /* glHintPGI */
+    0, /* glFogCoordfEXT */
     xglNoOpFogCoordfvEXT,
+    0, /* glFogCoorddEXT */
     xglNoOpFogCoorddvEXT,
     xglNoOpFogCoordPointerEXT,
+    0, /* glGetColorTableEXT */
+    0, /* glGetColorTableParameterivEXT */
+    0, /* glGetColorTableParameterfvEXT */
+    0, /* glTbufferMask3DFX */
+    0, /* glCompressedTexImage3DARB */
+    0, /* glCompressedTexImage2DARB */
+    0, /* glCompressedTexImage1DARB */
+    0, /* glCompressedTexSubImage3DARB */
+    0, /* glCompressedTexSubImage2DARB */
+    0, /* glCompressedTexSubImage1DARB */
+    0, /* glGetCompressedTexImageARB */
+    0, /* glSecondaryColor3bEXT */
     xglNoOpSecondaryColor3bvEXT,
+    0, /* glSecondaryColor3dEXT */
     xglNoOpSecondaryColor3dvEXT,
+    0, /* glSecondaryColor3fEXT */
     xglNoOpSecondaryColor3fvEXT,
+    0, /* glSecondaryColor3iEXT */
     xglNoOpSecondaryColor3ivEXT,
+    0, /* glSecondaryColor3sEXT */
     xglNoOpSecondaryColor3svEXT,
+    0, /* glSecondaryColor3ubEXT */
     xglNoOpSecondaryColor3ubvEXT,
+    0, /* glSecondaryColor3uiEXT */
     xglNoOpSecondaryColor3uivEXT,
+    0, /* glSecondaryColor3usEXT */
     xglNoOpSecondaryColor3usvEXT,
     xglNoOpSecondaryColorPointerEXT,
+    0, /* glAreProgramsResidentNV */
+    0, /* glBindProgramNV */
+    0, /* glDeleteProgramsNV */
+    0, /* glExecuteProgramNV */
+    0, /* glGenProgramsNV */
+    0, /* glGetProgramParameterdvNV */
+    0, /* glGetProgramParameterfvNV */
+    0, /* glGetProgramivNV */
+    0, /* glGetProgramStringNV */
+    0, /* glGetTrackMatrixivNV */
+    0, /* glGetVertexAttribdvARB */
+    0, /* glGetVertexAttribfvARB */
+    0, /* glGetVertexAttribivARB */
+    0, /* glGetVertexAttribPointervNV */
+    0, /* glIsProgramNV */
+    0, /* glLoadProgramNV */
+    0, /* glProgramParameter4dNV */
+    0, /* glProgramParameter4dvNV */
+    0, /* glProgramParameter4fNV */
+    0, /* glProgramParameter4fvNV */
+    0, /* glProgramParameters4dvNV */
+    0, /* glProgramParameters4fvNV */
+    0, /* glRequestResidentProgramsNV */
+    0, /* glTrackMatrixNV */
+    0, /* glVertexAttribPointerNV */
+    0, /* glVertexAttrib1dARB */
+    0, /* glVertexAttrib1dvARB */
+    0, /* glVertexAttrib1fARB */
+    0, /* glVertexAttrib1fvARB */
+    0, /* glVertexAttrib1sARB */
+    0, /* glVertexAttrib1svARB */
+    0, /* glVertexAttrib2dARB */
+    0, /* glVertexAttrib2dvARB */
+    0, /* glVertexAttrib2fARB */
+    0, /* glVertexAttrib2fvARB */
+    0, /* glVertexAttrib2sARB */
+    0, /* glVertexAttrib2svARB */
+    0, /* glVertexAttrib3dARB */
+    0, /* glVertexAttrib3dvARB */
+    0, /* glVertexAttrib3fARB */
+    0, /* glVertexAttrib3fvARB */
+    0, /* glVertexAttrib3sARB */
+    0, /* glVertexAttrib3svARB */
+    0, /* glVertexAttrib4dARB */
+    0, /* glVertexAttrib4dvARB */
+    0, /* glVertexAttrib4fARB */
+    0, /* glVertexAttrib4fvARB */
+    0, /* glVertexAttrib4sARB */
+    0, /* glVertexAttrib4svARB */
+    0, /* glVertexAttrib4NubARB */
+    0, /* glVertexAttrib4NubvARB */
+    0, /* glVertexAttribs1dvNV */
+    0, /* glVertexAttribs1fvNV */
+    0, /* glVertexAttribs1svNV */
+    0, /* glVertexAttribs2dvNV */
+    0, /* glVertexAttribs2fvNV */
+    0, /* glVertexAttribs2svNV */
+    0, /* glVertexAttribs3dvNV */
+    0, /* glVertexAttribs3fvNV */
+    0, /* glVertexAttribs3svNV */
+    0, /* glVertexAttribs4dvNV */
+    0, /* glVertexAttribs4fvNV */
+    0, /* glVertexAttribs4svNV */
+    0, /* glVertexAttribs4ubvNV */
     xglNoOpPointParameteriNV,
     xglNoOpPointParameterivNV,
+    0, /* glMultiDrawArraysEXT */
+    0, /* glMultiDrawElementsEXT */
     xglNoOpActiveStencilFaceEXT,
+    0, /* glDeleteFencesNV */
+    0, /* glGenFencesNV */
+    0, /* glIsFenceNV */
+    0, /* glTestFenceNV */
+    0, /* glGetFenceivNV */
+    0, /* glFinishFenceNV */
+    0, /* glSetFenceNV */
+    0, /* glVertexAttrib4bvARB */
+    0, /* glVertexAttrib4ivARB */
+    0, /* glVertexAttrib4ubvARB */
+    0, /* glVertexAttrib4usvARB */
+    0, /* glVertexAttrib4uivARB */
+    0, /* glVertexAttrib4NbvARB */
+    0, /* glVertexAttrib4NsvARB */
+    0, /* glVertexAttrib4NivARB */
+    0, /* glVertexAttrib4NusvARB */
+    0, /* glVertexAttrib4NuivARB */
+    0, /* glVertexAttribPointerARB */
+    0, /* glEnableVertexAttribArrayARB */
+    0, /* glDisableVertexAttribArrayARB */
+    0, /* glProgramStringARB */
+    0, /* glProgramEnvParameter4dARB */
+    0, /* glProgramEnvParameter4dvARB */
+    0, /* glProgramEnvParameter4fARB */
+    0, /* glProgramEnvParameter4fvARB */
+    0, /* glProgramLocalParameter4dARB */
+    0, /* glProgramLocalParameter4dvARB */
+    0, /* glProgramLocalParameter4fARB */
+    0, /* glProgramLocalParameter4fvARB */
+    0, /* glGetProgramEnvParameterdvARB */
+    0, /* glGetProgramEnvParameterfvARB */
+    0, /* glGetProgramLocalParameterdvARB */
+    0, /* glGetProgramLocalParameterfvARB */
+    0, /* glGetProgramivARB */
+    0, /* glGetProgramStringARB */
+    0, /* glProgramNamedParameter4fNV */
+    0, /* glProgramNamedParameter4dNV */
+    0, /* glProgramNamedParameter4fvNV */
+    0, /* glProgramNamedParameter4dvNV */
+    0, /* glGetProgramNamedParameterfvNV */
+    0, /* glGetProgramNamedParameterdvNV */
+    0, /* glBindBufferARB */
+    0, /* glBufferDataARB */
+    0, /* glBufferSubDataARB */
+    0, /* glDeleteBuffersARB */
+    0, /* glGenBuffersARB */
+    0, /* glGetBufferParameterivARB */
+    0, /* glGetBufferPointervARB */
+    0, /* glGetBufferSubDataARB */
+    0, /* glIsBufferARB */
+    0, /* glMapBufferARB */
+    0, /* glUnmapBufferARB */
+    0, /* glDepthBoundsEXT */
+    0, /* glGenQueriesARB */
+    0, /* glDeleteQueriesARB */
+    0, /* glIsQueryARB */
+    0, /* glBeginQueryARB */
+    0, /* glEndQueryARB */
+    0, /* glGetQueryivARB */
+    0, /* glGetQueryObjectivARB */
+    0, /* glGetQueryObjectuivARB */
+    0, /* glMultiModeDrawArraysIBM */
+    0, /* glMultiModeDrawElementsIBM */
+    0, /* glBlendEquationSeparateEXT */
+    0, /* glDeleteObjectARB */
+    0, /* glGetHandleARB */
+    0, /* glDetachObjectARB */
+    0, /* glCreateShaderObjectARB */
+    0, /* glShaderSourceARB */
+    0, /* glCompileShaderARB */
+    0, /* glCreateProgramObjectARB */
+    0, /* glAttachObjectARB */
+    0, /* glLinkProgramARB */
+    0, /* glUseProgramObjectARB */
+    0, /* glValidateProgramARB */
+    0, /* glUniform1fARB */
+    0, /* glUniform2fARB */
+    0, /* glUniform3fARB */
+    0, /* glUniform4fARB */
+    0, /* glUniform1iARB */
+    0, /* glUniform2iARB */
+    0, /* glUniform3iARB */
+    0, /* glUniform4iARB */
+    0, /* glUniform1fvARB */
+    0, /* glUniform2fvARB */
+    0, /* glUniform3fvARB */
+    0, /* glUniform4fvARB */
+    0, /* glUniform1ivARB */
+    0, /* glUniform2ivARB */
+    0, /* glUniform3ivARB */
+    0, /* glUniform4ivARB */
+    0, /* glUniformMatrix2fvARB */
+    0, /* glUniformMatrix3fvARB */
+    0, /* glUniformMatrix4fvARB */
+    0, /* glGetObjectParameterfvARB */
+    0, /* glGetObjectParameterivARB */
+    0, /* glGetInfoLogARB */
+    0, /* glGetAttachedObjectsARB */
+    0, /* glGetUniformLocationARB */
+    0, /* glGetActiveUniformARB */
+    0, /* glGetUniformfvARB */
+    0, /* glGetUniformivARB */
+    0, /* glGetShaderSourceARB */
+    0, /* glBindAttribLocationARB */
+    0, /* glGetActiveAttribARB */
+    0, /* glGetAttribLocationARB */
+    0, /* glGetVertexAttribdvNV */
+    0, /* glGetVertexAttribfvNV */
+    0, /* glGetVertexAttribivNV */
+    0, /* glVertexAttrib1dNV */
+    0, /* glVertexAttrib1dvNV */
+    0, /* glVertexAttrib1fNV */
+    0, /* glVertexAttrib1fvNV */
+    0, /* glVertexAttrib1sNV */
+    0, /* glVertexAttrib1svNV */
+    0, /* glVertexAttrib2dNV */
+    0, /* glVertexAttrib2dvNV */
+    0, /* glVertexAttrib2fNV */
+    0, /* glVertexAttrib2fvNV */
+    0, /* glVertexAttrib2sNV */
+    0, /* glVertexAttrib2svNV */
+    0, /* glVertexAttrib3dNV */
+    0, /* glVertexAttrib3dvNV */
+    0, /* glVertexAttrib3fNV */
+    0, /* glVertexAttrib3fvNV */
+    0, /* glVertexAttrib3sNV */
+    0, /* glVertexAttrib3svNV */
+    0, /* glVertexAttrib4dNV */
+    0, /* glVertexAttrib4dvNV */
+    0, /* glVertexAttrib4fNV */
+    0, /* glVertexAttrib4fvNV */
+    0, /* glVertexAttrib4sNV */
+    0, /* glVertexAttrib4svNV */
+    0, /* glVertexAttrib4ubNV */
+    0, /* glVertexAttrib4ubvNV */
+    0, /* glGenFragmentShadersATI */
+    0, /* glBindFragmentShaderATI */
+    0, /* glDeleteFragmentShaderATI */
+    0, /* glBeginFragmentShaderATI */
+    0, /* glEndFragmentShaderATI */
+    0, /* glPassTexCoordATI */
+    0, /* glSampleMapATI */
+    0, /* glColorFragmentOp1ATI */
+    0, /* glColorFragmentOp2ATI */
+    0, /* glColorFragmentOp3ATI */
+    0, /* glAlphaFragmentOp1ATI */
+    0, /* glAlphaFragmentOp2ATI */
+    0, /* glAlphaFragmentOp3ATI */
+    0, /* glSetFragmentShaderConstantATI */
     xglNoOpIsRenderbufferEXT,
     xglNoOpBindRenderbufferEXT,
     xglNoOpDeleteRenderbuffersEXT,
@@ -3510,7 +4056,12 @@ __glProcTableEXT __glNoOpRenderTableEXT = {
     xglNoOpFramebufferTexture3DEXT,
     xglNoOpFramebufferRenderbufferEXT,
     xglNoOpGetFramebufferAttachmentParameterivEXT,
-    xglNoOpGenerateMipmapEXT
+    xglNoOpGenerateMipmapEXT,
+    0, /* glStencilFuncSeparate */
+    0, /* glStencilOpSeparate */
+    0, /* glStencilMaskSeparate */
+    0, /* glGetQueryObjecti64vEXT */
+    0  /* glGetQueryObjectui64vEXT */
 };
 
 static void
@@ -3518,8 +4069,6 @@ xglInitExtensions (xglGLContextPtr pContext)
 {
     const char *extensions;
 
-    pContext->glRenderTableEXT = __glNoOpRenderTableEXT;
-
     extensions = (const char *) glGetString (GL_EXTENSIONS);
 
     if (strstr (extensions, "GL_ARB_multitexture"))
@@ -3528,88 +4077,87 @@ xglInitExtensions (xglGLContextPtr pContext)
 	    (PFNGLACTIVETEXTUREARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glActiveTextureARB");
-	pContext->glRenderTableEXT.ClientActiveTextureARB =
+	pContext->glRenderTable.ClientActiveTextureARB =
 	    (PFNGLCLIENTACTIVETEXTUREARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glClientActiveTextureARB");
-	pContext->glRenderTableEXT.MultiTexCoord1dvARB =
+	pContext->glRenderTable.MultiTexCoord1dvARB =
 	    (PFNGLMULTITEXCOORD1DVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord1dvARB");
-	pContext->glRenderTableEXT.MultiTexCoord1fvARB =
+	pContext->glRenderTable.MultiTexCoord1fvARB =
 	    (PFNGLMULTITEXCOORD1FVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord1fvARB");
-	pContext->glRenderTableEXT.MultiTexCoord1ivARB =
+	pContext->glRenderTable.MultiTexCoord1ivARB =
 	    (PFNGLMULTITEXCOORD1IVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord1ivARB");
-	pContext->glRenderTableEXT.MultiTexCoord1svARB =
+	pContext->glRenderTable.MultiTexCoord1svARB =
 	    (PFNGLMULTITEXCOORD1SVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord1svARB");
-	pContext->glRenderTableEXT.MultiTexCoord2dvARB =
+	pContext->glRenderTable.MultiTexCoord2dvARB =
 	    (PFNGLMULTITEXCOORD2DVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord2dvARB");
-	pContext->glRenderTableEXT.MultiTexCoord2fvARB =
+	pContext->glRenderTable.MultiTexCoord2fvARB =
 	    (PFNGLMULTITEXCOORD2FVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord2fvARB");
-	pContext->glRenderTableEXT.MultiTexCoord2ivARB =
+	pContext->glRenderTable.MultiTexCoord2ivARB =
 	    (PFNGLMULTITEXCOORD2IVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord2ivARB");
-	pContext->glRenderTableEXT.MultiTexCoord2svARB =
+	pContext->glRenderTable.MultiTexCoord2svARB =
 	    (PFNGLMULTITEXCOORD2SVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord2svARB");
-	pContext->glRenderTableEXT.MultiTexCoord3dvARB =
+	pContext->glRenderTable.MultiTexCoord3dvARB =
 	    (PFNGLMULTITEXCOORD3DVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord3dvARB");
-	pContext->glRenderTableEXT.MultiTexCoord3fvARB =
+	pContext->glRenderTable.MultiTexCoord3fvARB =
 	    (PFNGLMULTITEXCOORD3FVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord3fvARB");
-	pContext->glRenderTableEXT.MultiTexCoord3ivARB =
+	pContext->glRenderTable.MultiTexCoord3ivARB =
 	    (PFNGLMULTITEXCOORD3IVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord3ivARB");
-	pContext->glRenderTableEXT.MultiTexCoord3svARB =
+	pContext->glRenderTable.MultiTexCoord3svARB =
 	    (PFNGLMULTITEXCOORD3SVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord3svARB");
-	pContext->glRenderTableEXT.MultiTexCoord4dvARB =
+	pContext->glRenderTable.MultiTexCoord4dvARB =
 	    (PFNGLMULTITEXCOORD4DVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord4dvARB");
-	pContext->glRenderTableEXT.MultiTexCoord4fvARB =
+	pContext->glRenderTable.MultiTexCoord4fvARB =
 	    (PFNGLMULTITEXCOORD4FVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord4fvARB");
-	pContext->glRenderTableEXT.MultiTexCoord4ivARB =
+	pContext->glRenderTable.MultiTexCoord4ivARB =
 	    (PFNGLMULTITEXCOORD4IVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord4ivARB");
-	pContext->glRenderTableEXT.MultiTexCoord4svARB =
+	pContext->glRenderTable.MultiTexCoord4svARB =
 	    (PFNGLMULTITEXCOORD4SVARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glMultiTexCoord4svARB");
 
-	glGetIntegerv (GL_MAX_LIST_NESTING, &pContext->maxListNesting);
 	glGetIntegerv (GL_MAX_TEXTURE_UNITS_ARB, &pContext->maxTexUnits);
 	if (pContext->maxTexUnits > XGL_MAX_TEXTURE_UNITS)
 	    pContext->maxTexUnits = XGL_MAX_TEXTURE_UNITS;
 
-	pContext->glRenderTableEXT.ActiveTextureARB = xglActiveTextureARB;
+	pContext->glRenderTable.ActiveTextureARB = xglActiveTextureARB;
     }
     else
 	pContext->maxTexUnits = 1;
 
     if (strstr (extensions, "GL_ARB_multisample"))
     {
-	pContext->glRenderTableEXT.SampleCoverageARB =
+	pContext->glRenderTable.SampleCoverageARB =
 	    (PFNGLSAMPLECOVERAGEARBPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glSampleCoverageARB");
@@ -3617,19 +4165,19 @@ xglInitExtensions (xglGLContextPtr pContext)
 
     if (strstr (extensions, "GL_EXT_texture_object"))
     {
-	pContext->glRenderTableEXT.AreTexturesResidentEXT =
+	pContext->glRenderTable.AreTexturesResidentEXT =
 	    xglAreTexturesResident;
-	pContext->glRenderTableEXT.GenTexturesEXT = xglGenTextures;
-	pContext->glRenderTableEXT.IsTextureEXT = xglIsTexture;
+	pContext->glRenderTable.GenTexturesEXT = xglGenTextures;
+	pContext->glRenderTable.IsTextureEXT = xglIsTexture;
     }
 
     if (strstr (extensions, "GL_SGIS_multisample"))
     {
-	pContext->glRenderTableEXT.SampleMaskSGIS =
+	pContext->glRenderTable.SampleMaskSGIS =
 	    (PFNGLSAMPLEMASKSGISPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glSampleMaskSGIS");
-	pContext->glRenderTableEXT.SamplePatternSGIS =
+	pContext->glRenderTable.SamplePatternSGIS =
 	    (PFNGLSAMPLEPATTERNSGISPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glSamplePatternSGIS");
@@ -3637,11 +4185,11 @@ xglInitExtensions (xglGLContextPtr pContext)
 
     if (strstr (extensions, "GL_EXT_point_parameters"))
     {
-	pContext->glRenderTableEXT.PointParameterfEXT =
+	pContext->glRenderTable.PointParameterfEXT =
 	    (PFNGLPOINTPARAMETERFEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glPointParameterfEXT");
-	pContext->glRenderTableEXT.PointParameterfvEXT =
+	pContext->glRenderTable.PointParameterfvEXT =
 	    (PFNGLPOINTPARAMETERFVEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glPointParameterfvEXT");
@@ -3653,12 +4201,13 @@ xglInitExtensions (xglGLContextPtr pContext)
 	    (PFNGLWINDOWPOS3FMESAPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glWindowPos3fMESA");
-	pContext->glRenderTableEXT.WindowPos3fMESA = xglWindowPos3fMESA;
+
+	pContext->glRenderTable.WindowPos3fMESA = xglWindowPos3fMESA;
     }
 
     if (strstr (extensions, "GL_EXT_blend_func_separate"))
     {
-	pContext->glRenderTableEXT.BlendFuncSeparateEXT =
+	pContext->glRenderTable.BlendFuncSeparateEXT =
 	    (PFNGLBLENDFUNCSEPARATEEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glBlendFuncSeparateEXT");
@@ -3666,15 +4215,15 @@ xglInitExtensions (xglGLContextPtr pContext)
 
     if (strstr (extensions, "GL_EXT_fog_coord"))
     {
-	pContext->glRenderTableEXT.FogCoordfvEXT =
+	pContext->glRenderTable.FogCoordfvEXT =
 	    (PFNGLFOGCOORDFVEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glFogCoordfvEXT");
-	pContext->glRenderTableEXT.FogCoorddvEXT =
+	pContext->glRenderTable.FogCoorddvEXT =
 	    (PFNGLFOGCOORDDVEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glFogCoorddvEXT");
-	pContext->glRenderTableEXT.FogCoordPointerEXT =
+	pContext->glRenderTable.FogCoordPointerEXT =
 	    (PFNGLFOGCOORDPOINTEREXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glFogCoordPointerEXT");
@@ -3682,39 +4231,39 @@ xglInitExtensions (xglGLContextPtr pContext)
 
     if (strstr (extensions, "GL_EXT_secondary_color"))
     {
-	pContext->glRenderTableEXT.SecondaryColor3bvEXT =
+	pContext->glRenderTable.SecondaryColor3bvEXT =
 	    (PFNGLSECONDARYCOLOR3BVEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glSecondaryColor3bvEXT");
-	pContext->glRenderTableEXT.SecondaryColor3dvEXT =
+	pContext->glRenderTable.SecondaryColor3dvEXT =
 	    (PFNGLSECONDARYCOLOR3DVEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glSecondaryColor3dvEXT");
-	pContext->glRenderTableEXT.SecondaryColor3fvEXT =
+	pContext->glRenderTable.SecondaryColor3fvEXT =
 	    (PFNGLSECONDARYCOLOR3FVEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glSecondaryColor3fvEXT");
-	pContext->glRenderTableEXT.SecondaryColor3ivEXT =
+	pContext->glRenderTable.SecondaryColor3ivEXT =
 	    (PFNGLSECONDARYCOLOR3IVEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glSecondaryColor3ivEXT");
-	pContext->glRenderTableEXT.SecondaryColor3svEXT =
+	pContext->glRenderTable.SecondaryColor3svEXT =
 	    (PFNGLSECONDARYCOLOR3SVEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glSecondaryColor3svEXT");
-	pContext->glRenderTableEXT.SecondaryColor3ubvEXT =
+	pContext->glRenderTable.SecondaryColor3ubvEXT =
 	    (PFNGLSECONDARYCOLOR3UBVEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glSecondaryColor3ubvEXT");
-	pContext->glRenderTableEXT.SecondaryColor3uivEXT =
+	pContext->glRenderTable.SecondaryColor3uivEXT =
 	    (PFNGLSECONDARYCOLOR3UIVEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glSecondaryColor3uivEXT");
-	pContext->glRenderTableEXT.SecondaryColor3usvEXT =
+	pContext->glRenderTable.SecondaryColor3usvEXT =
 	    (PFNGLSECONDARYCOLOR3USVEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glSecondaryColor3usvEXT");
-	pContext->glRenderTableEXT.SecondaryColorPointerEXT =
+	pContext->glRenderTable.SecondaryColorPointerEXT =
 	    (PFNGLSECONDARYCOLORPOINTEREXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glSecondaryColorPointerEXT");
@@ -3722,11 +4271,11 @@ xglInitExtensions (xglGLContextPtr pContext)
 
     if (strstr (extensions, "GL_NV_point_sprite"))
     {
-	pContext->glRenderTableEXT.PointParameteriNV =
+	pContext->glRenderTable.PointParameteriNV =
 	    (PFNGLPOINTPARAMETERINVPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glPointParameteriNV");
-	pContext->glRenderTableEXT.PointParameterivNV =
+	pContext->glRenderTable.PointParameterivNV =
 	    (PFNGLPOINTPARAMETERIVNVPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glPointParameterivNV");
@@ -3734,7 +4283,7 @@ xglInitExtensions (xglGLContextPtr pContext)
 
     if (strstr (extensions, "GL_EXT_stencil_two_side"))
     {
-	pContext->glRenderTableEXT.ActiveStencilFaceEXT =
+	pContext->glRenderTable.ActiveStencilFaceEXT =
 	    (PFNGLACTIVESTENCILFACEEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glActiveStencilFaceEXT");
@@ -3742,72 +4291,72 @@ xglInitExtensions (xglGLContextPtr pContext)
 
     if (strstr (extensions, "GL_EXT_framebuffer_object"))
     {
-	pContext->glRenderTableEXT.IsRenderbufferEXT =
+	pContext->glRenderTable.IsRenderbufferEXT =
 	    (PFNGLISRENDERBUFFEREXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glIsRenderbufferEXT");
-	pContext->glRenderTableEXT.BindRenderbufferEXT =
+	pContext->glRenderTable.BindRenderbufferEXT =
 	    (PFNGLBINDRENDERBUFFEREXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glBindRenderbufferEXT");
-	pContext->glRenderTableEXT.DeleteRenderbuffersEXT =
+	pContext->glRenderTable.DeleteRenderbuffersEXT =
 	    (PFNGLDELETERENDERBUFFERSEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glDeleteRenderbuffersEXT");
-	pContext->glRenderTableEXT.GenRenderbuffersEXT =
+	pContext->glRenderTable.GenRenderbuffersEXT =
 	    (PFNGLGENRENDERBUFFERSEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glGenRenderbuffersEXT");
-	pContext->glRenderTableEXT.RenderbufferStorageEXT =
+	pContext->glRenderTable.RenderbufferStorageEXT =
 	    (PFNGLRENDERBUFFERSTORAGEEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glRenderbufferStorageEXT");
-	pContext->glRenderTableEXT.GetRenderbufferParameterivEXT =
+	pContext->glRenderTable.GetRenderbufferParameterivEXT =
 	    (PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glGetRenderbufferParameterivEXT");
-	pContext->glRenderTableEXT.IsFramebufferEXT =
+	pContext->glRenderTable.IsFramebufferEXT =
 	    (PFNGLISFRAMEBUFFEREXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glIsFramebufferEXT");
-	pContext->glRenderTableEXT.BindFramebufferEXT =
+	pContext->glRenderTable.BindFramebufferEXT =
 	    (PFNGLBINDFRAMEBUFFEREXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glBindFramebufferEXT");
-	pContext->glRenderTableEXT.DeleteFramebuffersEXT =
+	pContext->glRenderTable.DeleteFramebuffersEXT =
 	    (PFNGLDELETEFRAMEBUFFERSEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glDeleteFramebuffersEXT");
-	pContext->glRenderTableEXT.GenFramebuffersEXT =
+	pContext->glRenderTable.GenFramebuffersEXT =
 	    (PFNGLGENFRAMEBUFFERSEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glGenFramebuffersEXT");
-	pContext->glRenderTableEXT.CheckFramebufferStatusEXT =
+	pContext->glRenderTable.CheckFramebufferStatusEXT =
 	    (PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glCheckFramebufferStatusEXT");
-	pContext->glRenderTableEXT.FramebufferTexture1DEXT =
+	pContext->glRenderTable.FramebufferTexture1DEXT =
 	    (PFNGLFRAMEBUFFERTEXTURE1DEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glFramebufferTexture1DEXT");
-	pContext->glRenderTableEXT.FramebufferTexture2DEXT =
+	pContext->glRenderTable.FramebufferTexture2DEXT =
 	    (PFNGLFRAMEBUFFERTEXTURE2DEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glFramebufferTexture2DEXT");
-	pContext->glRenderTableEXT.FramebufferTexture3DEXT =
+	pContext->glRenderTable.FramebufferTexture3DEXT =
 	    (PFNGLFRAMEBUFFERTEXTURE3DEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glFramebufferTexture3DEXT");
-	pContext->glRenderTableEXT.FramebufferRenderbufferEXT =
+	pContext->glRenderTable.FramebufferRenderbufferEXT =
 	    (PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glFramebufferRenderbufferEXT");
-	pContext->glRenderTableEXT.GetFramebufferAttachmentParameterivEXT =
+	pContext->glRenderTable.GetFramebufferAttachmentParameterivEXT =
 	    (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glGetFramebufferAttachment"
 					    "ParameterivEXT");
-	pContext->glRenderTableEXT.GenerateMipmapEXT =
+	pContext->glRenderTable.GenerateMipmapEXT =
 	    (PFNGLGENERATEMIPMAPEXTPROC)
 	    glitz_context_get_proc_address (pContext->context,
 					    "glGenerateMipmapEXT");
@@ -3817,12 +4366,11 @@ xglInitExtensions (xglGLContextPtr pContext)
 static void
 xglSetCurrentContext (xglGLContextPtr pContext)
 {
-  XGL_SCREEN_PRIV (pContext->pDrawBuffer->pGC->pScreen);
     cctx = pContext;
 
-    glitz_context_make_current (cctx->context, pScreenPriv->drawable);
+    glitz_context_make_current (cctx->context, cctx->pDrawBuffer->drawable);
 
-    GlxSetRenderTables (&__glNativeRenderTable, &cctx->glRenderTableEXT);
+    GlxSetRenderTables (&cctx->glRenderTable);
 }
 
 static void
@@ -3894,9 +4442,6 @@ xglFreeContext (xglGLContextPtr pContext)
     if (pContext->groupList)
 	glDeleteLists (pContext->groupList, 1);
 
-    if (pContext->pAttribStack)
-	xfree (pContext->pAttribStack);
-
     if (pContext->context)
 	glitz_context_destroy (pContext->context);
 
@@ -3927,6 +4472,7 @@ xglLoseCurrent (__GLcontext *gc)
     __GLinterface   *iface = pContext->mIface;
 
     GlxFlushContextCache ();
+    GlxSetRenderTables (0);
 
     if (!iface)
 	return GL_TRUE;
@@ -3968,9 +4514,6 @@ xglMakeCurrent (__GLcontext *gc)
 	if (pDrawBufferPriv != pReadBufferPriv)
 	    return GL_FALSE;
 
-	pContext->pReadBuffer = pReadBufferPriv;
-	pContext->pDrawBuffer = pDrawBufferPriv;
-
 	if (!pReadBufferPriv->pGC)
 	    pReadBufferPriv->pGC =
 		CreateGC (pReadBufferPriv->pDrawable,
@@ -3987,11 +4530,14 @@ xglMakeCurrent (__GLcontext *gc)
 
 	ValidateGC (pDrawBufferPriv->pDrawable, pDrawBufferPriv->pGC);
 
+	pReadBufferPriv->pPixmap = (PixmapPtr) 0;
+	pDrawBufferPriv->pPixmap = (PixmapPtr) 0;
+
 	pContext->pReadBuffer = pReadBufferPriv;
 	pContext->pDrawBuffer = pDrawBufferPriv;
 
-	pReadBufferPriv->pPixmap = (PixmapPtr) 0;
-	pDrawBufferPriv->pPixmap = (PixmapPtr) 0;
+	pContext->readPriv = readPriv;
+	pContext->drawPriv = drawPriv;
 
 	/* from now on this context can only be used with native GL stack */
 	if (mIface)
@@ -4081,47 +4627,87 @@ xglResizeBuffer (__GLdrawablePrivate *glPriv,
 
     if (pPixmap != pScreenPriv->pScreenPixmap)
     {
-	if (glPriv->modes->doubleBufferMode)
-	{
-	    glitz_surface_t *surface = pBufferPriv->backSurface;
+	if (!xglCreatePixmapSurface (pPixmap))
+	    return FALSE;
 
-	    if (!surface ||
-		(glitz_surface_get_width (surface)  != width ||
-		 glitz_surface_get_height (surface) != height))
+	if (pBufferPriv->drawable == pScreenPriv->drawable)
 	    {
-		glitz_format_t *format;
-	    
-		format = pScreenPriv->pixmapFormats[pDrawable->depth].format;
+	    if (pBufferPriv->backSurface)
+		glitz_surface_destroy (pBufferPriv->backSurface);
 
-		if (surface)
-		    glitz_surface_destroy (surface);
+	    glitz_drawable_destroy (pBufferPriv->drawable);
 	    
-		pBufferPriv->backSurface =
-		    glitz_surface_create (pScreenPriv->drawable, format,
-					  width, height, 0, NULL);
-		if (!pBufferPriv->backSurface)
-		    return FALSE;
-	    }
+	    pBufferPriv->drawable    = NULL;
+	    pBufferPriv->backSurface = NULL;
 	}
+
+	if (pBufferPriv->drawable)
+	{
+	    glitz_drawable_update_size (pBufferPriv->drawable,
+					pPixmap->drawable.width,
+					pPixmap->drawable.height);
     }
     else
     {
-	if (glPriv->modes->doubleBufferMode)
+	    glitz_drawable_format_t *format;
+
+	    format = pBufferPriv->pVisual->format.drawable;
+	    if (pBufferPriv->pVisual->pbuffer)
 	{
-	    if (!pBufferPriv->backSurface)
+		pBufferPriv->drawable =
+		    glitz_create_pbuffer_drawable (pScreenPriv->drawable,
+						   format,
+						   pPixmap->drawable.width,
+						   pPixmap->drawable.height);
+	    }
+	    else
 	    {
-		pBufferPriv->backSurface = pScreenPriv->backSurface;
-		glitz_surface_reference (pScreenPriv->backSurface);
+		pBufferPriv->drawable =
+		    glitz_create_drawable (pScreenPriv->drawable, format,
+					   pPixmap->drawable.width,
+					   pPixmap->drawable.height);
+
+		if (!pBufferPriv->drawable)
+		    return FALSE;
+
+		if (format->doublebuffer)
+		{
+		    glitz_format_t *backFormat;
+
+		    backFormat = pBufferPriv->pVisual->format.surface;
+
+		    pBufferPriv->backSurface =
+			glitz_surface_create (pScreenPriv->drawable, backFormat,
+					      pPixmap->drawable.width,
+					      pPixmap->drawable.height,
+					      0, NULL);
+		    if (pBufferPriv->backSurface)
+			glitz_surface_attach (pBufferPriv->backSurface,
+					      pBufferPriv->drawable,
+					      GLITZ_DRAWABLE_BUFFER_BACK_COLOR);
+		}
 	    }
 	}
     }
+    else
+    {
+	glitz_drawable_reference (pScreenPriv->drawable);
+
+	if (pBufferPriv->backSurface)
+	    glitz_surface_destroy (pBufferPriv->backSurface);
+
+	if (pBufferPriv->drawable)
+	    glitz_drawable_destroy (pBufferPriv->drawable);
+
+	pBufferPriv->drawable    = pScreenPriv->drawable;
+	pBufferPriv->backSurface = NULL;
+    }
 	
     ValidateGC (pDrawable, pBufferPriv->pGC);
 
     return TRUE;
 }
 
-
 static GLboolean
 xglForceCurrent (__GLcontext *gc)
 {
@@ -4129,19 +4715,31 @@ xglForceCurrent (__GLcontext *gc)
     __GLinterface   *iface = pContext->mIface;
     GLboolean	    status = GL_TRUE;
     
-    if (pContext->context)
+    if (pContext && pContext->context)
     {
+	__GLdrawablePrivate *readPriv, *drawPriv;
+
+	readPriv = pContext->readPriv;
+	drawPriv = pContext->drawPriv;
+
+	drawPriv->lockDP (drawPriv, gc);
+	if (readPriv != drawPriv)
+	    readPriv->lockDP (readPriv, gc);
+
 	cctx = pContext;
 
 	if (cctx->pReadBuffer->pDrawable && cctx->pDrawBuffer->pDrawable)
 	{
-	    DrawablePtr pDrawable;
+	    DrawablePtr pDrawable = cctx->pReadBuffer->pDrawable;
 	    PixmapPtr   pReadPixmap, pDrawPixmap;
 	
-	    pDrawable = cctx->pReadBuffer->pDrawable;
+	    XGL_SCREEN_PRIV (pDrawable->pScreen);
+
 	    if (pDrawable->type != DRAWABLE_PIXMAP)
 	    {
 		pReadPixmap = XGL_GET_WINDOW_PIXMAP (pDrawable);
+		cctx->pReadBuffer->screenX = __XGL_OFF_X_WIN (pReadPixmap);
+		cctx->pReadBuffer->screenY = __XGL_OFF_Y_WIN (pReadPixmap);
 		cctx->pReadBuffer->xOff = pDrawable->x +
 		    __XGL_OFF_X_WIN (pReadPixmap);
 		cctx->pReadBuffer->yOff = pReadPixmap->drawable.height -
@@ -4152,6 +4750,7 @@ xglForceCurrent (__GLcontext *gc)
 	    else
 	    {
 		pReadPixmap = (PixmapPtr) pDrawable;
+		cctx->pReadBuffer->screenX = cctx->pReadBuffer->screenY = 0;
 		cctx->pReadBuffer->xOff = cctx->pReadBuffer->yOff = 0;
 		cctx->pReadBuffer->yFlip = pDrawable->height;
 	    }
@@ -4160,6 +4759,8 @@ xglForceCurrent (__GLcontext *gc)
 	    if (pDrawable->type != DRAWABLE_PIXMAP)
 	    {
 		pDrawPixmap = XGL_GET_WINDOW_PIXMAP (pDrawable);
+		cctx->pDrawBuffer->screenX = __XGL_OFF_X_WIN (pDrawPixmap);
+		cctx->pDrawBuffer->screenY = __XGL_OFF_Y_WIN (pDrawPixmap);
 		cctx->pDrawBuffer->xOff = pDrawable->x +
 		    __XGL_OFF_X_WIN (pDrawPixmap);
 		cctx->pDrawBuffer->yOff = pDrawPixmap->drawable.height -
@@ -4170,43 +4771,67 @@ xglForceCurrent (__GLcontext *gc)
 	    else
 	    {
 		pDrawPixmap = (PixmapPtr) pDrawable;
+		cctx->pDrawBuffer->screenX = cctx->pDrawBuffer->screenY = 0;
 		cctx->pDrawBuffer->xOff = cctx->pDrawBuffer->yOff = 0;
 		cctx->pDrawBuffer->yFlip = pDrawable->height;
 	    }
 	    
-	    /* draw buffer changed */
+	    /* buffer changed */
 	    if (cctx->pDrawBuffer->pPixmap != pDrawPixmap ||
 		cctx->pReadBuffer->pPixmap != pReadPixmap)
 	    {
-		__GLinterface	    *iface = &pContext->iface;
-		__GLdrawablePrivate *drawPriv, *readPriv;
-    
-		if (!xglPrepareTarget (pDrawable))
-		    return FALSE;
-		
-		drawPriv = iface->imports.getDrawablePrivate (gc);
-		readPriv = iface->imports.getReadablePrivate (gc);
-		
 		if (!xglResizeBuffer (drawPriv,
 				      pDrawable->x,
 				      pDrawable->y,
 				      pDrawable->width,
 				      pDrawable->height))
+		{
+		    drawPriv->unlockDP (drawPriv);
+		    if (readPriv != drawPriv)
+			readPriv->unlockDP (readPriv);
+
 		    return FALSE;
+		}
 
 		if (!xglResizeBuffer (readPriv,
 				      cctx->pReadBuffer->pDrawable->x,
 				      cctx->pReadBuffer->pDrawable->y,
 				      cctx->pReadBuffer->pDrawable->width,
 				      cctx->pReadBuffer->pDrawable->height))
+		{
+		    drawPriv->unlockDP (drawPriv);
+		    if (readPriv != drawPriv)
+			readPriv->unlockDP (readPriv);
+
 		    return FALSE;
+		}
 
 		cctx->pReadBuffer->pPixmap = pReadPixmap;
 		cctx->pDrawBuffer->pPixmap = pDrawPixmap;
 	    }
+
+	    if (!xglSyncSurface (pContext->pDrawBuffer->pDrawable))
+	    {
+		drawPriv->unlockDP (drawPriv);
+		if (readPriv != drawPriv)
+		    readPriv->unlockDP (readPriv);
+
+		return FALSE;
+	    }
+
+	    if (pDrawPixmap != pScreenPriv->pScreenPixmap)
+	    {
+		XGL_PIXMAP_PRIV (pDrawPixmap);
+
+		glitz_surface_attach (pPixmapPriv->surface,
+				      pContext->pDrawBuffer->drawable,
+				      GLITZ_DRAWABLE_BUFFER_FRONT_COLOR);
+
+		if (pPixmapPriv->target)
+		    pPixmapPriv->target = xglPixmapTargetOut;
 	}
 
-	xglSetCurrentContext (pContext);//, cctx->pDrawBuffer);
+	    xglSetCurrentContext (pContext);
 	
 	if (cctx->needInit)
 	{
@@ -4214,10 +4839,18 @@ xglForceCurrent (__GLcontext *gc)
 	    
 	    xglInitExtensions (cctx);
 
+		glGetIntegerv (GL_MAX_LIST_NESTING, &cctx->maxListNesting);
+		glGetIntegerv (GL_MAX_ATTRIB_STACK_DEPTH,
+			       &cctx->maxAttribStackDepth);
+		if (cctx->maxAttribStackDepth > XGL_MAX_ATTRIB_STACK_DEPTH)
+		    cctx->maxAttribStackDepth = XGL_MAX_ATTRIB_STACK_DEPTH;
+
 	    cctx->attrib.scissorTest = GL_FALSE;
 	    cctx->attrib.scissor.x = cctx->attrib.scissor.y = 0;
-	    cctx->attrib.scissor.width = cctx->pDrawBuffer->pDrawable->width;
-	    cctx->attrib.scissor.height = cctx->pDrawBuffer->pDrawable->height;
+		cctx->attrib.scissor.width =
+		    cctx->pDrawBuffer->pDrawable->width;
+		cctx->attrib.scissor.height =
+		    cctx->pDrawBuffer->pDrawable->height;
 	    cctx->attrib.viewport = cctx->attrib.scissor;
 	
 	    cctx->activeTexUnit = 0;
@@ -4242,10 +4875,10 @@ xglForceCurrent (__GLcontext *gc)
 	if (cctx->pDrawBuffer->xOff != cctx->drawXoff ||
 	    cctx->pDrawBuffer->yOff != cctx->drawYoff)
 	{
-	    glViewport (cctx->attrib.scissor.x + cctx->pDrawBuffer->xOff,
-			cctx->attrib.scissor.y + cctx->pDrawBuffer->yOff,
-			cctx->attrib.scissor.width,
-			cctx->attrib.scissor.height);
+		glViewport (cctx->attrib.viewport.x + cctx->pDrawBuffer->xOff,
+			    cctx->attrib.viewport.y + cctx->pDrawBuffer->yOff,
+			    cctx->attrib.viewport.width,
+			    cctx->attrib.viewport.height);
 
 	    glBitmap (0, 0, 0, 0,
 		      cctx->pDrawBuffer->xOff - cctx->drawXoff,
@@ -4256,8 +4889,17 @@ xglForceCurrent (__GLcontext *gc)
 	    cctx->drawYoff = cctx->pDrawBuffer->yOff;
 	}
 
-	glDrawBuffer (cctx->attrib.drawBuffer);
-	glReadBuffer (cctx->attrib.readBuffer);
+	    xglDrawBuffer (cctx->attrib.drawBuffer);
+	    xglReadBuffer (cctx->attrib.readBuffer);
+	}
+	else
+	{
+	    xglSetCurrentContext (pContext);
+	}
+
+	drawPriv->unlockDP (drawPriv);
+	if (readPriv != drawPriv)
+	    readPriv->unlockDP (readPriv);
     }
     else
     {
@@ -4286,6 +4928,9 @@ xglNotifyDestroy (__GLcontext *gc)
     xglGLContextPtr pContext = (xglGLContextPtr) gc;
     __GLinterface   *iface = pContext->mIface;
 
+    pContext->pReadBuffer->pDrawable = 0;
+    pContext->pDrawBuffer->pDrawable = 0;
+
     if (iface)
 	(*iface->exports.notifyDestroy) ((__GLcontext *) iface);
 }
@@ -4335,9 +4980,13 @@ xglEndDispatchOverride (__GLcontext *gc)
 static void
 xglLoseCurrentContext (void *closure)
 {
+    if (closure == cctx)
+    {
     cctx = NULL;
 
     GlxFlushContextCache ();
+	GlxSetRenderTables (0);
+    }
 }
 
 static __GLinterface *
@@ -4354,32 +5003,31 @@ xglCreateContext (__GLimports      *imports,
 
     XGL_SCREEN_PRIV (glxCtx->pScreen);
 
-    format = glitz_drawable_get_format (pScreenPriv->drawable);
-
     pContext = xalloc (sizeof (xglGLContextRec));
     if (!pContext)
 	return NULL;
 
+    format = glitz_drawable_get_format (pScreenPriv->drawable);
     pContext->context = glitz_context_create (pScreenPriv->drawable, format);
-    glitz_context_set_user_data (pContext->context, NULL, 
+    glitz_context_set_user_data (pContext->context, pContext,
 				 xglLoseCurrentContext);
 
+    pContext->glRenderTable = __glNativeRenderTable;
     pContext->needInit	    = TRUE;
     pContext->versionString = NULL;
     pContext->errorValue    = GL_NO_ERROR;
     pContext->shared	    = NULL;
     pContext->list	    = 0;
     pContext->groupList	    = 0;
-    pContext->pAttribStack  = NULL;
+    pContext->beginCnt	    = 0;
     pContext->nAttribStack  = 0;
     pContext->refcnt	    = 1;
-    pContext->doubleBuffer  = glxCtx->pGlxVisual->doubleBuffer;
-    pContext->depthBits     = glxCtx->pGlxVisual->depthSize;
-    pContext->stencilBits   = glxCtx->pGlxVisual->stencilSize;
+    pContext->doubleBuffer  = glxCtx->modes->doubleBufferMode;
+    pContext->depthBits     = glxCtx->modes->depthBits;
+    pContext->stencilBits   = glxCtx->modes->stencilBits;
     pContext->drawXoff	    = 0;
     pContext->drawYoff	    = 0;
     pContext->maxTexUnits   = 0;
-    pContext->fbo	    = 0;
 
     if (pContext->doubleBuffer)
     {
@@ -4467,40 +5115,12 @@ xglSwapBuffers (__GLXdrawablePrivate *glxPriv)
 	    BoxPtr	    pBox = REGION_RECTS (pGC->pCompositeClip);
 	    int		    nBox = REGION_NUM_RECTS (pGC->pCompositeClip);
 
-	    XGL_SCREEN_PRIV (pGC->pScreen);
-
-	    if (!xglPrepareTarget (pDrawable))
-		return GL_FALSE;
-	    
 	    XGL_GET_DRAWABLE (pDrawable, surface, xOff, yOff);
 
-	    /* native swap buffers for fullscreen windows */
-	    if (surface == pScreenPriv->surface &&
-		nBox == 1 &&
-		pBox->x1 <= 0 &&
-		pBox->y1 <= 0 &&
-		pBox->x2 >= pGC->pScreen->width &&
-		pBox->y2 >= pGC->pScreen->height)
-	    {
-		glitz_drawable_swap_buffers (pScreenPriv->drawable);
-	    }
-	    else
-	    {
-		glitz_surface_set_clip_region (surface, xOff, yOff,
+	    glitz_drawable_swap_buffer_region (pBufferPriv->drawable,
+					       xOff, yOff,
 					       (glitz_box_t *) pBox, nBox);
 
-		glitz_copy_area (pBufferPriv->backSurface,
-				 surface,
-				 pDrawable->x + xOff,
-				 pDrawable->y + yOff,
-				 pDrawable->width,
-				 pDrawable->height,
-				 pDrawable->x + xOff,
-				 pDrawable->y + yOff);
-		
-		glitz_surface_set_clip_region (surface, 0, 0, NULL, 0);
-	    }
-
 	    xglAddBitDamage (pDrawable, pGC->pCompositeClip);
 	    DamageDamageRegion (pDrawable, pGC->pCompositeClip);
 	    REGION_EMPTY (pGC->pScreen, &pBufferPriv->damage);
@@ -4585,9 +5205,13 @@ xglBindBuffers (__GLXdrawablePrivate *glxPriv,
 	{
 	    glitz_texture_object_t *object;
 
+	    XGL_SCREEN_PRIV (pDrawable->pScreen);
 	    XGL_DRAWABLE_PIXMAP (pDrawable);
 	    XGL_PIXMAP_PRIV (pPixmap);
 
+	    if (pPixmap == pScreenPriv->pScreenPixmap)
+		return BadDrawable;
+
 	    object = glitz_texture_object_create (pPixmapPriv->surface);
 	    if (object)
 	    {
@@ -4680,7 +5304,6 @@ xglReleaseBuffers (__GLXdrawablePrivate *glxPriv,
     
     return BadDrawable;
 }
-
 static void
 xglFreeBuffers (__GLdrawablePrivate *glPriv)
 {
@@ -4697,6 +5320,9 @@ xglFreeBuffers (__GLdrawablePrivate *glPriv)
     if (pBufferPriv->backSurface)
 	glitz_surface_destroy (pBufferPriv->backSurface);
 
+    if (pBufferPriv->drawable)
+	glitz_drawable_destroy (pBufferPriv->drawable);
+
     xfree (pBufferPriv);
 }
 
@@ -4707,8 +5333,10 @@ xglCreateBuffer (__GLXdrawablePrivate *glxPriv)
     DrawablePtr		pDrawable = glxPriv->pDraw;
     ScreenPtr		pScreen = pDrawable->pScreen;
     xglGLBufferPtr	pBufferPriv;
+    xglVisualPtr	v;
 
     XGL_SCREEN_PRIV (pScreen);
+    XGL_DRAWABLE_PIXMAP (pDrawable);
     
     pBufferPriv = xalloc (sizeof (xglGLBufferRec));
     if (!pBufferPriv)
@@ -4718,7 +5346,6 @@ xglCreateBuffer (__GLXdrawablePrivate *glxPriv)
     pBufferPriv->pDrawable     = NULL;
     pBufferPriv->pPixmap       = NULL;
     pBufferPriv->pGC	       = NULL;
-    pBufferPriv->backSurface   = NULL;
 
     pBufferPriv->swapBuffers = NULL;
 
@@ -4729,48 +5356,67 @@ xglCreateBuffer (__GLXdrawablePrivate *glxPriv)
     pBufferPriv->private       = NULL;
     pBufferPriv->freeBuffers   = NULL;
 
-    REGION_NULL (pScreen, &pBufferPriv->damage);
+    pBufferPriv->drawable    = NULL;
+    pBufferPriv->backSurface = NULL;
 
-    if (pScreenPriv->fbo ||
-	((pDrawable->type == DRAWABLE_WINDOW)
+    REGION_INIT (pScreen, &pBufferPriv->damage, NullBox, 0);
 	 
-#ifdef COMPOSITE
-	 /* this is a root window, can't be redirected */
-	 && (!((WindowPtr) pDrawable)->parent)
-#endif
+    pBufferPriv->pVisual = 0;
 	 
-	    ))
+    /* glx acceleration */
+    if (pScreenPriv->accel.glx.enabled &&
+	xglCheckPixmapSize (pPixmap, &pScreenPriv->accel.glx.size))
     {
-	pBufferPriv->pDrawable = pDrawable;
+	for (v = pScreenPriv->pGlxVisual; v; v = v->next)
+	{
+	    glitz_drawable_format_t *format;
+
+	    if (pScreenPriv->accel.glx.pbuffer != v->pbuffer)
+		continue;
+
+	    format = v->format.drawable;
+	    if (!format)
+		continue;
+
+	    if (format->color.red_size   != glxPriv->modes->redBits   ||
+		format->color.green_size != glxPriv->modes->greenBits ||
+		format->color.blue_size  != glxPriv->modes->blueBits)
+		continue;
+
+	    if (format->color.alpha_size < glxPriv->modes->alphaBits   ||
+		format->depth_size	 < glxPriv->modes->depthBits   ||
+		format->stencil_size     < glxPriv->modes->stencilBits ||
+		format->doublebuffer     < glxPriv->modes->doubleBufferMode)
+		continue;
+
+	    /* this is good enought for pbuffers */
+	    if (v->pbuffer)
+		break;
+
+	    /* we want an exact match for non-pbuffer formats */
+	    if (format->color.alpha_size == glxPriv->modes->alphaBits   &&
+		format->depth_size	 == glxPriv->modes->depthBits   &&
+		format->stencil_size     == glxPriv->modes->stencilBits &&
+		format->doublebuffer     == glxPriv->modes->doubleBufferMode)
+		break;
     }
     
-/*    else if (pScreenPriv->fbo)
-    {
-	if (glxPriv->pGlxVisual->doubleBuffer)
-	{
-	int depth = pDrawable->depth;
+	pBufferPriv->pVisual = v;
+    }
 
-	    pBufferPriv->backSurface =
-		glitz_surface_create (pScreenPriv->drawable,
-				      pScreenPriv->pixmapFormats[depth].format,
-				      pDrawable->width, pDrawable->height,
-				      0, NULL);
-	    if (pBufferPriv->backSurface)
-	    {
-		if (glitz_surface_valid_target (pBufferPriv->backSurface))
+    if ((pDrawable->type == DRAWABLE_WINDOW)
+
+#ifdef COMPOSITE
+	&& (pBufferPriv->pVisual
+
+	    /* this is a root window, can't be redirected */
+	    || (!((WindowPtr) pDrawable)->parent))
+#endif
+
+	)
 	    	{
 		    pBufferPriv->pDrawable = pDrawable;
-		    ErrorF ("Backbuffer created\n");
-	    	}
-		else
-		{
-		    glitz_surface_destroy (pBufferPriv->backSurface);
-		    pBufferPriv->backSurface = NULL;
-		}
-	    }
-	}
     }
-  */
     else
     {
 	(*screenInfoPriv.createBuffer) (glxPriv);
@@ -4826,7 +5472,6 @@ xglCreateBuffer (__GLXdrawablePrivate *glxPriv)
     
     glxPriv->bindBuffers    = xglBindBuffers;
     glxPriv->releaseBuffers = xglReleaseBuffers;
-
     glPriv->frontBuffer.resize = xglResizeBuffers;
     
     glPriv->private	= (void *) pBufferPriv;
@@ -4836,49 +5481,120 @@ xglCreateBuffer (__GLXdrawablePrivate *glxPriv)
 static Bool
 xglScreenProbe (int screen)
 {
+    ScreenPtr    pScreen = screenInfo.screens[screen];
+    xglVisualPtr pVisual;
     Bool status;
+    int          i;
+
+    XGL_SCREEN_PRIV (pScreen);
 
     status = (*screenInfoPriv.screenProbe) (screen);
 
-    /* Wrap createBuffer */
-    if (__glDDXScreenInfo.createBuffer != xglCreateBuffer)
+    /* Create Xgl GLX visuals */
+    for (i = 0; i < __xglScreenInfoPtr->numVisuals; i++)
     {
-	screenInfoPriv.createBuffer    = __glDDXScreenInfo.createBuffer;
-	__glDDXScreenInfo.createBuffer = xglCreateBuffer;
-    }
+	pVisual = xglFindVisualWithId (pScreen, pScreen->visuals[i].vid);
+	if (pVisual)
+	{
+	    glitz_drawable_format_t templ, *format, *screenFormat;
+	    unsigned long	    mask;
     
-    /* Wrap createContext */
-    if (__glDDXScreenInfo.createContext != xglCreateContext)
+	    templ.color        = pVisual->format.surface->color;
+	    templ.depth_size   = __xglScreenInfoPtr->modes[i].depthBits;
+	    templ.stencil_size = __xglScreenInfoPtr->modes[i].stencilBits;
+	    templ.doublebuffer = __xglScreenInfoPtr->modes[i].doubleBufferMode;
+	    templ.samples      = 1;
+
+	    mask =
+		GLITZ_FORMAT_FOURCC_MASK       |
+		GLITZ_FORMAT_RED_SIZE_MASK     |
+		GLITZ_FORMAT_GREEN_SIZE_MASK   |
+		GLITZ_FORMAT_BLUE_SIZE_MASK    |
+		GLITZ_FORMAT_ALPHA_SIZE_MASK   |
+		GLITZ_FORMAT_DEPTH_SIZE_MASK   |
+		GLITZ_FORMAT_STENCIL_SIZE_MASK |
+		GLITZ_FORMAT_DOUBLEBUFFER_MASK |
+		GLITZ_FORMAT_SAMPLES_MASK;
+
+	    format = glitz_find_drawable_format (pScreenPriv->drawable,
+						 mask, &templ, 0);
+	    if (format)
     {
-	screenInfoPriv.createContext    = __glDDXScreenInfo.createContext;
-	__glDDXScreenInfo.createContext = xglCreateContext;
-    }
+		xglVisualPtr v, new, *prev;
     
-    return status;
+		new = xalloc (sizeof (xglVisualRec));
+		if (new)
+		{
+		    new->next    = 0;
+		    new->vid     = pVisual->vid;
+		    new->pPixel  = pVisual->pPixel;
+		    new->pbuffer = FALSE;
+
+		    new->format.surface  = pVisual->format.surface;
+		    new->format.drawable = format;
+
+		    prev = &pScreenPriv->pGlxVisual;
+		    while ((v = *prev))
+			prev = &v->next;
+
+		    *prev = new;
+		}
 }
 
-static Bool
-xglDestroyWindow (WindowPtr pWin)
-{
-    ScreenPtr pScreen = pWin->drawable.pScreen;
-    Bool      ret;
+	    /* use same drawable format as screen for pbuffers */
+	    screenFormat = glitz_drawable_get_format (pScreenPriv->drawable);
+	    templ.id = screenFormat->id;
     
-    XGL_SCREEN_PRIV (pScreen);
+	    mask =
+		GLITZ_FORMAT_ID_MASK	     |
+		GLITZ_FORMAT_FOURCC_MASK     |
+		GLITZ_FORMAT_RED_SIZE_MASK   |
+		GLITZ_FORMAT_GREEN_SIZE_MASK |
+		GLITZ_FORMAT_BLUE_SIZE_MASK  |
+		GLITZ_FORMAT_SAMPLES_MASK;
 
-    if (cctx)
+	    format = glitz_find_pbuffer_format (pScreenPriv->drawable,
+						mask, &templ, 0);
+	    if (format)
+	    {
+		xglVisualPtr v, new, *prev;
+
+		new = xalloc (sizeof (xglVisualRec));
+		if (new)
     {
-	if (cctx->pDrawBuffer->pDrawable == &pWin->drawable)
-	    cctx->pDrawBuffer->pDrawable = NULL;
+		    new->next    = 0;
+		    new->vid     = pVisual->vid;
+		    new->pPixel  = pVisual->pPixel;
+		    new->pbuffer = TRUE;
 
-	if (cctx->pReadBuffer->pDrawable == &pWin->drawable)
-	    cctx->pReadBuffer->pDrawable = NULL;
+		    new->format.surface  = pVisual->format.surface;
+		    new->format.drawable = format;
+
+		    prev = &pScreenPriv->pGlxVisual;
+		    while ((v = *prev))
+			prev = &v->next;
+
+		    *prev = new;
+		}
+	    }
+	}
+    }
+
+    /* Wrap createBuffer */
+    if (__xglScreenInfoPtr->createBuffer != xglCreateBuffer)
+    {
+	screenInfoPriv.createBuffer    = __xglScreenInfoPtr->createBuffer;
+	__xglScreenInfoPtr->createBuffer = xglCreateBuffer;
     }
     
-    XGL_SCREEN_UNWRAP (DestroyWindow);
-    ret = (*pScreen->DestroyWindow) (pWin);
-    XGL_SCREEN_WRAP (DestroyWindow, xglDestroyWindow);
+    /* Wrap createContext */
+    if (__xglScreenInfoPtr->createContext != xglCreateContext)
+    {
+	screenInfoPriv.createContext    = __xglScreenInfoPtr->createContext;
+	__xglScreenInfoPtr->createContext = xglCreateContext;
+    }
 
-    return ret;
+    return status;
 }
 
 Bool
@@ -4892,40 +5608,34 @@ xglInitVisualConfigs (ScreenPtr pScreen)
     int			    rootDepth;
     VisualID		    defaultVis;
     glitz_drawable_format_t *format;
-    xglPixelFormatPtr	    pPixel;
+    xglVisualPtr	    pVisual;
     __GLXvisualConfig	    *pConfig;
     xglGLXVisualConfigPtr   pConfigPriv, *ppConfigPriv;
     XID			    *installedCmaps;
     ColormapPtr		    installedCmap;
     int			    numInstalledCmaps;
     int			    numConfig = 1;
-    int			    depth, bpp, i;
+    int			    bpp, i;
 
     XGL_SCREEN_PRIV (pScreen);
 
-    XGL_SCREEN_WRAP (DestroyWindow, xglDestroyWindow);
-
-    depth  = pScreenPriv->pVisual->pPixel->depth;
-    bpp    = pScreenPriv->pVisual->pPixel->masks.bpp;
-    format = glitz_drawable_get_format (pScreenPriv->drawable);
-    pPixel = pScreenPriv->pixmapFormats[depth].pPixel;
+    if (xglScreenInfo.depth != 16 && xglScreenInfo.depth != 24)
+	return FALSE;
 
-    if (format->doublebuffer)
+    for (pVisual = xglVisuals; pVisual; pVisual = pVisual->next)
     {
-	pScreenPriv->backSurface =
-	    glitz_surface_create (pScreenPriv->drawable,
-				  pScreenPriv->pixmapFormats[depth].format,
-				  pScreen->width, pScreen->height,
-				  0, NULL);
-	if (!pScreenPriv->backSurface)
+	if (pVisual->pPixel->depth == xglScreenInfo.depth)
+	    break;
+    }
+
+    if (!pVisual)
 	    return FALSE;
 
-	glitz_surface_attach (pScreenPriv->backSurface,
-			      pScreenPriv->drawable,
-			      GLITZ_DRAWABLE_BUFFER_BACK_COLOR);
+    bpp = pVisual->pPixel->masks.bpp;
 
+    format = glitz_drawable_get_format (pScreenPriv->drawable);
+    if (format->doublebuffer)
 	numConfig *= 2;
-    }
 
     pConfig = xcalloc (sizeof (__GLXvisualConfig), numConfig);
     if (!pConfig)
@@ -4966,28 +5676,18 @@ xglInitVisualConfigs (ScreenPtr pScreen)
 	pConfig[i].redSize   = format->color.red_size;
 	pConfig[i].greenSize = format->color.green_size;
 	pConfig[i].blueSize  = format->color.blue_size;
-
-	pConfig[i].redMask   = pPixel->masks.red_mask;
-	pConfig[i].greenMask = pPixel->masks.green_mask;
-	pConfig[i].blueMask  = pPixel->masks.blue_mask;
-
-	if (format->color.alpha_size)
-	{
 	    pConfig[i].alphaSize = format->color.alpha_size;
-	    pConfig[i].alphaMask = pPixel->masks.alpha_mask;
-	}
-	else
-	{
-	    pConfig[i].alphaSize = 0;
-	    pConfig[i].alphaMask = 0;
-	}
+
+	pConfig[i].redMask   = pVisual->pPixel->masks.red_mask;
+	pConfig[i].greenMask = pVisual->pPixel->masks.green_mask;
+	pConfig[i].blueMask  = pVisual->pPixel->masks.blue_mask;
+	pConfig[i].alphaMask = pVisual->pPixel->masks.alpha_mask;
 
 	if (i == 1)
 	{
 	    pConfig[i].doubleBuffer = FALSE;
 	    pConfig[i].depthSize    = 0;
 	    pConfig[i].stencilSize  = 0;
-	
 	}
 	else
 	{
@@ -4998,7 +5698,7 @@ xglInitVisualConfigs (ScreenPtr pScreen)
 	
 	pConfig[i].stereo = FALSE;
 	
-	if (depth == 16)
+	if (pScreen->rootDepth == 16)
 	    pConfig[i].bufferSize = 16;
 	else
 	    pConfig[i].bufferSize = 32;
@@ -5019,10 +5719,10 @@ xglInitVisualConfigs (ScreenPtr pScreen)
     GlxSetVisualConfigs (numConfig, pConfig, (void **) ppConfigPriv);
 
     /* Wrap screenProbe */
-    if (__glDDXScreenInfo.screenProbe != xglScreenProbe)
+    if (__xglScreenInfoPtr->screenProbe != xglScreenProbe)
     {
-	screenInfoPriv.screenProbe    = __glDDXScreenInfo.screenProbe;
-	__glDDXScreenInfo.screenProbe = xglScreenProbe;
+	screenInfoPriv.screenProbe    = __xglScreenInfoPtr->screenProbe;
+	__xglScreenInfoPtr->screenProbe = xglScreenProbe;
     }
 
     visuals    = pScreen->visuals;
@@ -5060,6 +5760,10 @@ xglInitVisualConfigs (ScreenPtr pScreen)
     pScreen->rootDepth     = rootDepth;
     pScreen->rootVisual    = defaultVis;
 
+#ifndef NGLXLOG
+    xglInitGlxLog ();
+#endif
+
     xfree (installedCmaps);
     xfree (pConfigPriv);
     xfree (pConfig);
