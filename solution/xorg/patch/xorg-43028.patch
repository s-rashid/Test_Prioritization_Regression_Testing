diff --git a/dix/events.c b/dix/events.c
index 0a70296..839c456 100644
--- a/dix/events.c
+++ b/dix/events.c
@@ -3647,90 +3647,6 @@ DeliverGrabbedEvent(xEvent *xE, DeviceIntPtr thisDev,
     }
 }
 
-/**
- * Main keyboard event processing function for core keyboard events.
- * Updates the events fields from the current pointer state and delivers the
- * event.
- *
- * For key events, xE will always be a single event.
- *
- * @param xE Event list
- * @param keybd The device that caused an event.
- * @param count Number of elements in xE.
- */
-void
-CoreProcessKeyboardEvent (xEvent *xE, DeviceIntPtr keybd, int count)
-{
-    int             key, bit;
-    BYTE            *kptr;
-    GrabPtr         grab;
-    GrabInfoPtr     grabinfo;
-    Bool            deactivateGrab = FALSE;
-    KeyClassPtr     keyc = keybd->key;
-
-    grabinfo = &keybd->deviceGrab;
-    grab = grabinfo->grab;
-
-    if (!syncEvents.playingEvents)
-    {
-	NoticeTime(xE);
-	if (DeviceEventCallback)
-	{
-	    DeviceEventInfoRec eventinfo;
-	    eventinfo.events = xE;
-	    eventinfo.count = count;
-	    CallCallbacks(&DeviceEventCallback, (pointer)&eventinfo);
-	}
-    }
-
-    /* ProcessOtherEvent already updated the keyboard's state, so we need to
-     * access prev_state here! */
-    XE_KBPTR.state = XkbStateFieldFromRec(&keybd->key->xkbInfo->prev_state);
-    XE_KBPTR.state |= GetPairedDevice(keybd)->button->state;
-    XE_KBPTR.rootX = keybd->spriteInfo->sprite->hot.x;
-    XE_KBPTR.rootY = keybd->spriteInfo->sprite->hot.y;
-
-    key = xE->u.u.detail;
-    kptr = &keyc->down[key >> 3];
-    bit = 1 << (key & 7);
-
-    switch (xE->u.u.type)
-    {
-	case KeyPress:
-            /* We MUST NOT change the device itself here.  All device state
-             * changes must be performed in ProcessOtherEvents. We're dealing
-             * with the same device struct, so if we change it in POE and
-             * here, we've just screwed up the state by setting it twice.
-             *
-             * Devices may not send core events but always send XI events, so
-             * the state must be changed in POE, not here.
-             */
-	    if (!grab && CheckDeviceGrabs(keybd, xE, 0, count))
-	    {
-		grabinfo->activatingKey = key;
-		return;
-	    }
-	    break;
-	case KeyRelease:
-	    if (!(*kptr & bit)) /* guard against duplicates */
-		return;
-            /* No device state changes, see comment for KeyPress */
-	    if (grabinfo->fromPassiveGrab && (key == grabinfo->activatingKey))
-		deactivateGrab = TRUE;
-	    break;
-	default:
-	    FatalError("Impossible keyboard event");
-    }
-    if (grab)
-	DeliverGrabbedEvent(xE, keybd, deactivateGrab, count);
-    else
-	DeliverFocusedEvent(keybd, xE, keybd->spriteInfo->sprite->win, count);
-    if (deactivateGrab)
-        (*grabinfo->DeactivateGrab)(keybd);
-
-    XaceHook(XACE_KEY_AVAIL, xE, keybd, count);
-}
-
 /* This function is used to set the key pressed or key released state -
    this is only used when the pressing of keys does not cause
    the device's processInputProc to be called, as in for example Mouse Keys.
@@ -3761,94 +3677,6 @@ FixKeyState (xEvent *xE, DeviceIntPtr keybd)
         FatalError("Impossible keyboard event");
 }
 
-/**
- * Main pointer event processing function for core pointer events.
- * For motion events: update the sprite.
- * For all other events: Update the event fields based on the current sprite
- * state.
- *
- * For core pointer events, xE will always be a single event.
- *
- * @param xE Event list
- * @param mouse The device that caused an event.
- * @param count Number of elements in xE.
- */
-void
-CoreProcessPointerEvent (xEvent *xE, DeviceIntPtr mouse, int count)
-{
-    GrabPtr	        grab = mouse->deviceGrab.grab;
-    Bool                deactivateGrab = FALSE;
-    ButtonClassPtr      butc = mouse->button;
-    SpritePtr           pSprite = mouse->spriteInfo->sprite;
-
-    XkbSrvInfoPtr xkbi= GetPairedDevice(mouse)->key->xkbInfo;
-
-    if (!syncEvents.playingEvents)
-	NoticeTime(xE)
-    XE_KBPTR.state = (butc->state | xkbi->state.grab_mods);
-    {
-	NoticeTime(xE);
-	if (DeviceEventCallback)
-	{
-	    DeviceEventInfoRec eventinfo;
-	    /* see comment in EnqueueEvents regarding the next three lines */
-	    if (xE->u.u.type == MotionNotify)
-		XE_KBPTR.root =
-		    WindowTable[pSprite->hotPhys.pScreen->myNum]->drawable.id;
-	    eventinfo.events = xE;
-	    eventinfo.count = count;
-	    CallCallbacks(&DeviceEventCallback, (pointer)&eventinfo);
-	}
-    }
-    /* We need to call CheckMotion for each event. It doesn't really give us
-       any benefit for relative devices, but absolute devices may not send
-       button events to the right position otherwise. */
-    if (!CheckMotion(xE, mouse) && xE->u.u.type == MotionNotify)
-            return;
-    if (xE->u.u.type != MotionNotify)
-    {
-	int  key;
-
-	XE_KBPTR.rootX = pSprite->hot.x;
-	XE_KBPTR.rootY = pSprite->hot.y;
-
-	key = xE->u.u.detail;
-	switch (xE->u.u.type)
-	{
-	case ButtonPress:
-            /*
-             * We rely on the fact that ButtonMotionMask is the same as
-             * DeviceButtonMotionMask, so setting the motionMask
-             * to this value ensures correctness for both XI and core events.
-             */
-	    if (xE->u.u.detail == 0)
-		return;
-            filters[mouse->id][Motion_Filter(butc)] = MotionNotify;
-	    if (!grab)
-		if (CheckDeviceGrabs(mouse, xE, 0, count))
-		    return;
-	    break;
-	case ButtonRelease:
-	    if (xE->u.u.detail == 0)
-		return;
-            filters[mouse->id][Motion_Filter(butc)] = MotionNotify;
-	    if (!butc->buttonsDown && mouse->deviceGrab.fromPassiveGrab)
-		deactivateGrab = TRUE;
-	    break;
-	default:
-	    FatalError("bogus pointer event from ddx. Type %d\n", xE->u.u.type);
-	}
-    }
-
-    if (grab)
-	DeliverGrabbedEvent(xE, mouse, deactivateGrab, count);
-    else
-	DeliverDeviceEvents(pSprite->win, xE, NullGrab, NullWindow,
-			    mouse, count);
-    if (deactivateGrab)
-        (*mouse->deviceGrab.DeactivateGrab)(mouse);
-}
-
 #define AtMostOneClient \
 	(SubstructureRedirectMask | ResizeRedirectMask | ButtonPressMask)
 #define ManagerMask \
