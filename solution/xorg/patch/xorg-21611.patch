diff --git a/GL/glx/glxcmdsswap.c b/GL/glx/glxcmdsswap.c
index ae6a9d1..551824c 100644
--- a/GL/glx/glxcmdsswap.c
+++ b/GL/glx/glxcmdsswap.c
@@ -641,91 +641,7 @@ void __glXSwapGetDrawableAttributesReply(ClientPtr client,
 
 int __glXDispSwap_Render(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXRenderReq *req;
-    ClientPtr client= cl->client;
-    int left, cmdlen, error;
-    int commandsDone;
-    CARD16 opcode;
-    __GLXrenderHeader *hdr;
-    __GLXcontext *cx;
-    __GLX_DECLARE_SWAP_VARIABLES;
-
-    /*
-    ** NOTE: much of this code also appears in the nonswapping version of this
-    ** routine, __glXRender().  Any changes made here should also be
-    ** duplicated there.
-    */
-    
-    req = (xGLXRenderReq *) pc;
-    __GLX_SWAP_SHORT(&req->length);
-    __GLX_SWAP_INT(&req->contextTag);
-
-    cx = __glXForceCurrent(cl, req->contextTag, &error);
-    if (!cx) {
-	return error;
-    }
-
-    commandsDone = 0;
-    pc += sz_xGLXRenderReq;
-    left = (req->length << 2) - sz_xGLXRenderReq;
-    while (left > 0) {
-        __GLXrenderSizeData entry;
-        int extra;
-	__GLXdispatchRenderProcPtr proc;
-	int err;
-
-	/*
-	** Verify that the header length and the overall length agree.
-	** Also, each command must be word aligned.
-	*/
-	hdr = (__GLXrenderHeader *) pc;
-	__GLX_SWAP_SHORT(&hdr->length);
-	__GLX_SWAP_SHORT(&hdr->opcode);
-	cmdlen = hdr->length;
-	opcode = hdr->opcode;
-
-	err = __glXGetProtocolSizeData(& Render_dispatch_info, opcode, & entry);
-	proc = (__GLXdispatchRenderProcPtr)
-	  __glXGetProtocolDecodeFunction(& Render_dispatch_info, opcode, 1);
-
-	if ((err < 0) || (proc == NULL)) {
-	    client->errorValue = commandsDone;
-	    return __glXError(GLXBadRenderRequest);
-	}
-
-        if (entry.varsize) {
-            /* variable size command */
-            extra = (*entry.varsize)(pc + __GLX_RENDER_HDR_SIZE, True);
-            if (extra < 0) {
-                extra = 0;
-            }
-            if (cmdlen != __GLX_PAD(entry.bytes + extra)) {
-                return BadLength;
-            }
-        } else {
-            /* constant size command */
-            if (cmdlen != __GLX_PAD(entry.bytes)) {
-                return BadLength;
-            }
-        }
-	if (left < cmdlen) {
-	    return BadLength;
-	}
-
-	/*
-	** Skip over the header and execute the command.  We allow the
-	** caller to trash the command memory.  This is useful especially
-	** for things that require double alignment - they can just shift
-	** the data towards lower memory (trashing the header) by 4 bytes
-	** and achieve the required alignment.
-	*/
-	(*proc)(pc + __GLX_RENDER_HDR_SIZE);
-	pc += cmdlen;
-	left -= cmdlen;
-	commandsDone++;
-    }
-    __GLX_NOTE_UNFLUSHED_CMDS(cx);
-    return Success;
+    return DoRender(cl, pc, True);
 }
 
 /*
@@ -733,203 +649,7 @@ int __glXDispSwap_Render(__GLXclientState *cl, GLbyte *pc)
 */
 int __glXDispSwap_RenderLarge(__GLXclientState *cl, GLbyte *pc)
 {
-    xGLXRenderLargeReq *req;
-    ClientPtr client= cl->client;
-    size_t dataBytes;
-    __GLXrenderLargeHeader *hdr;
-    __GLXcontext *cx;
-    int error;
-    CARD16 opcode;
-    __GLX_DECLARE_SWAP_VARIABLES;
-
-    /*
-    ** NOTE: much of this code also appears in the nonswapping version of this
-    ** routine, __glXRenderLarge().  Any changes made here should also be
-    ** duplicated there.
-    */
-    
-    req = (xGLXRenderLargeReq *) pc;
-    __GLX_SWAP_SHORT(&req->length);
-    __GLX_SWAP_INT(&req->contextTag);
-    __GLX_SWAP_INT(&req->dataBytes);
-    __GLX_SWAP_SHORT(&req->requestNumber);
-    __GLX_SWAP_SHORT(&req->requestTotal);
-    cx = __glXForceCurrent(cl, req->contextTag, &error);
-    if (!cx) {
-	/* Reset in case this isn't 1st request. */
-	__glXResetLargeCommandStatus(cl);
-	return error;
-    }
-    dataBytes = req->dataBytes;
-
-    /*
-    ** Check the request length.
-    */
-    if ((req->length << 2) != __GLX_PAD(dataBytes) + sz_xGLXRenderLargeReq) {
-	client->errorValue = req->length;
-	/* Reset in case this isn't 1st request. */
-	__glXResetLargeCommandStatus(cl);
-	return BadLength;
-    }
-    pc += sz_xGLXRenderLargeReq;
-    
-    if (cl->largeCmdRequestsSoFar == 0) {
-	__GLXrenderSizeData entry;
-	int extra;
-	size_t cmdlen;
-	int err;
-
-	/*
-	** This is the first request of a multi request command.
-	** Make enough space in the buffer, then copy the entire request.
-	*/
-	if (req->requestNumber != 1) {
-	    client->errorValue = req->requestNumber;
-	    return __glXError(GLXBadLargeRequest);
-	}
-	hdr = (__GLXrenderLargeHeader *) pc;
-	__GLX_SWAP_INT(&hdr->length);
-	__GLX_SWAP_INT(&hdr->opcode);
-	cmdlen = hdr->length;
-	opcode = hdr->opcode;
-
-	err = __glXGetProtocolSizeData(& Render_dispatch_info, opcode, & entry);
-	if (err < 0) {
-	    client->errorValue = opcode;
-	    return __glXError(GLXBadLargeRequest);
-	}
-
-	if (entry.varsize) {
-	    /*
-	    ** If it's a variable-size command (a command whose length must
-	    ** be computed from its parameters), all the parameters needed
-	    ** will be in the 1st request, so it's okay to do this.
-	    */
-	    extra = (*entry.varsize)(pc + __GLX_RENDER_LARGE_HDR_SIZE, True);
-	    if (extra < 0) {
-		extra = 0;
-	    }
-	    /* large command's header is 4 bytes longer, so add 4 */
-	    if (cmdlen != __GLX_PAD(entry.bytes + 4 + extra)) {
-		return BadLength;
-	    }
-	} else {
-	    /* constant size command */
-	    if (cmdlen != __GLX_PAD(entry.bytes + 4)) {
-		return BadLength;
-	    }
-	}
-	/*
-	** Make enough space in the buffer, then copy the entire request.
-	*/
-	if (cl->largeCmdBufSize < cmdlen) {
-	    if (!cl->largeCmdBuf) {
-		cl->largeCmdBuf = (GLbyte *) xalloc(cmdlen);
-	    } else {
-		cl->largeCmdBuf = (GLbyte *) xrealloc(cl->largeCmdBuf, cmdlen);
-	    }
-	    if (!cl->largeCmdBuf) {
-		return BadAlloc;
-	    }
-	    cl->largeCmdBufSize = cmdlen;
-	}
-	memcpy(cl->largeCmdBuf, pc, dataBytes);
-
-	cl->largeCmdBytesSoFar = dataBytes;
-	cl->largeCmdBytesTotal = cmdlen;
-	cl->largeCmdRequestsSoFar = 1;
-	cl->largeCmdRequestsTotal = req->requestTotal;
-	return Success;
-	
-    } else {
-	/*
-	** We are receiving subsequent (i.e. not the first) requests of a
-	** multi request command.
-	*/
-
-	/*
-	** Check the request number and the total request count.
-	*/
-	if (req->requestNumber != cl->largeCmdRequestsSoFar + 1) {
-	    client->errorValue = req->requestNumber;
-	    __glXResetLargeCommandStatus(cl);
-	    return __glXError(GLXBadLargeRequest);
-	}
-	if (req->requestTotal != cl->largeCmdRequestsTotal) {
-	    client->errorValue = req->requestTotal;
-	    __glXResetLargeCommandStatus(cl);
-	    return __glXError(GLXBadLargeRequest);
-	}
-
-	/*
-	** Check that we didn't get too much data.
-	*/
-	if ((cl->largeCmdBytesSoFar + dataBytes) > cl->largeCmdBytesTotal) {
-	    client->errorValue = dataBytes;
-	    __glXResetLargeCommandStatus(cl);
-	    return __glXError(GLXBadLargeRequest);
-	}
-	memcpy(cl->largeCmdBuf + cl->largeCmdBytesSoFar, pc, dataBytes);
-	cl->largeCmdBytesSoFar += dataBytes;
-	cl->largeCmdRequestsSoFar++;
-
-	if (req->requestNumber == cl->largeCmdRequestsTotal) {
-	    __GLXdispatchRenderProcPtr proc;
-
-	    /*
-	    ** This is the last request; it must have enough bytes to complete
-	    ** the command.
-	    */
-	    /* NOTE: the two pad macros have been added below; they are needed
-	    ** because the client library pads the total byte count, but not
-	    ** the per-request byte counts.  The Protocol Encoding says the
-	    ** total byte count should not be padded, so a proposal will be 
-	    ** made to the ARB to relax the padding constraint on the total 
-	    ** byte count, thus preserving backward compatibility.  Meanwhile, 
-	    ** the padding done below fixes a bug that did not allow
-	    ** large commands of odd sizes to be accepted by the server.
-	    */
-	    if (__GLX_PAD(cl->largeCmdBytesSoFar) !=
-		__GLX_PAD(cl->largeCmdBytesTotal)) {
-		client->errorValue = dataBytes;
-		__glXResetLargeCommandStatus(cl);
-		return __glXError(GLXBadLargeRequest);
-	    }
-	    hdr = (__GLXrenderLargeHeader *) cl->largeCmdBuf;
-	    /*
-	    ** The opcode and length field in the header had already been
-	    ** swapped when the first request was received.
-	    */
-
-	    /*
-	    ** Use the opcode to index into the procedure table.
-	    */
-	    opcode = hdr->opcode;
-
-	    proc = (__GLXdispatchRenderProcPtr)
-	      __glXGetProtocolDecodeFunction(& Render_dispatch_info, opcode, 1);
-	    if (proc == NULL) {
-		client->errorValue = opcode;
-		return __glXError(GLXBadLargeRequest);
-	    }
-
-	    /*
-	    ** Skip over the header and execute the command.
-	    */
-	    (*proc)(cl->largeCmdBuf + __GLX_RENDER_LARGE_HDR_SIZE);
-	    __GLX_NOTE_UNFLUSHED_CMDS(cx);
-
-	    /*
-	    ** Reset for the next RenderLarge series.
-	    */
-	    __glXResetLargeCommandStatus(cl);
-	} else {
-	    /*
-	    ** This is neither the first nor the last request.
-	    */
-	}
-	return Success;
-    }
+    return DoRenderLarge(cl, pc, True);
 }
 
 /************************************************************************/
