diff --git a/dix/region.c b/dix/region.c
index 5ba3457..6820c1e 100644
--- a/dix/region.c
+++ b/dix/region.c
@@ -1423,237 +1423,3 @@ RegionFromRects(int nrects, xRectangle *prect, int ctype)
     }
     return pRgn;
 }
-
-#define ExchangeSpans(a, b)				    \
-{							    \
-    DDXPointRec	tpt;				    	    \
-    int    	tw;					    \
-							    \
-    tpt = spans[a]; spans[a] = spans[b]; spans[b] = tpt;    \
-    tw = widths[a]; widths[a] = widths[b]; widths[b] = tw;  \
-}
-
-/* ||| I should apply the merge sort code to rectangle sorting above, and see
-   if mapping time can be improved.  But right now I've been at work 12 hours,
-   so forget it.
-*/
-
-static void QuickSortSpans(
-    DDXPointRec spans[],
-    int	    	widths[],
-    int	    	numSpans)
-{
-    int	    y;
-    int	    i, j, m;
-    DDXPointPtr    r;
-
-    /* Always called with numSpans > 1 */
-    /* Sorts only by y, doesn't bother to sort by x */
-
-    do
-    {
-	if (numSpans < 9)
-	{
-	    /* Do insertion sort */
-	    int yprev;
-
-	    yprev = spans[0].y;
-	    i = 1;
-	    do
-	    { /* while i != numSpans */
-		y = spans[i].y;
-		if (yprev > y)
-		{
-		    /* spans[i] is out of order.  Move into proper location. */
-		    DDXPointRec tpt;
-		    int	    tw, k;
-
-		    for (j = 0; y >= spans[j].y; j++) {}
-		    tpt = spans[i];
-		    tw  = widths[i];
-		    for (k = i; k != j; k--)
-		    {
-			spans[k] = spans[k-1];
-			widths[k] = widths[k-1];
-		    }
-		    spans[j] = tpt;
-		    widths[j] = tw;
-		    y = spans[i].y;
-		} /* if out of order */
-		yprev = y;
-		i++;
-	    } while (i != numSpans);
-	    return;
-	}
-
-	/* Choose partition element, stick in location 0 */
-	m = numSpans / 2;
-	if (spans[m].y > spans[0].y)		ExchangeSpans(m, 0);
-	if (spans[m].y > spans[numSpans-1].y)   ExchangeSpans(m, numSpans-1);
-	if (spans[m].y > spans[0].y)		ExchangeSpans(m, 0);
-	y = spans[0].y;
-
-        /* Partition array */
-        i = 0;
-        j = numSpans;
-        do
-	{
-	    r = &(spans[i]);
-	    do
-	    {
-		r++;
-		i++;
-            } while (i != numSpans && r->y < y);
-	    r = &(spans[j]);
-	    do
-	    {
-		r--;
-		j--;
-            } while (y < r->y);
-            if (i < j)
-		ExchangeSpans(i, j);
-        } while (i < j);
-
-        /* Move partition element back to middle */
-        ExchangeSpans(0, j);
-
-	/* Recurse */
-        if (numSpans-j-1 > 1)
-	    QuickSortSpans(&spans[j+1], &widths[j+1], numSpans-j-1);
-        numSpans = j;
-    } while (numSpans > 1);
-}
-
-#define NextBand()						    \
-{								    \
-    clipy1 = pboxBandStart->y1;					    \
-    clipy2 = pboxBandStart->y2;					    \
-    pboxBandEnd = pboxBandStart + 1;				    \
-    while (pboxBandEnd != pboxLast && pboxBandEnd->y1 == clipy1) {  \
-	pboxBandEnd++;						    \
-    }								    \
-    for (; ppt != pptLast && ppt->y < clipy1; ppt++, pwidth++) {} \
-}
-
-/*
-    Clip a list of scanlines to a region.  The caller has allocated the
-    space.  FSorted is non-zero if the scanline origins are in ascending
-    order.
-    returns the number of new, clipped scanlines.
-*/
-
-int
-RegionClipSpans(
-    RegionPtr	prgnDst,
-    DDXPointPtr ppt,
-    int	    	*pwidth,
-    int		nspans,
-    DDXPointPtr	pptNew,
-    int		*pwidthNew,
-    int		fSorted)
-{
-    DDXPointPtr pptLast;
-    int	*pwidthNewStart;	/* the vengeance of Xerox! */
-    int	y, x1, x2;
-    int	numRects;
-
-    good(prgnDst);
-    pptLast = ppt + nspans;
-    pwidthNewStart = pwidthNew;
-
-    if (!prgnDst->data)
-    {
-	/* Do special fast code with clip boundaries in registers(?) */
-	/* It doesn't pay much to make use of fSorted in this case, 
-	   so we lump everything together. */
-
-	int clipx1, clipx2, clipy1, clipy2;
-
-	clipx1 = prgnDst->extents.x1;
-	clipy1 = prgnDst->extents.y1;
-	clipx2 = prgnDst->extents.x2;
-	clipy2 = prgnDst->extents.y2;
-	    
-	for (; ppt != pptLast; ppt++, pwidth++)
-	{
-	    y = ppt->y;
-	    x1 = ppt->x;
-	    if (clipy1 <= y && y < clipy2)
-	    {
-		x2 = x1 + *pwidth;
-		if (x1 < clipx1)    x1 = clipx1;
-		if (x2 > clipx2)    x2 = clipx2;
-		if (x1 < x2)
-		{
-		    /* part of span in clip rectangle */
-		    pptNew->x = x1;
-		    pptNew->y = y;
-		    *pwidthNew = x2 - x1;
-		    pptNew++;
-		    pwidthNew++;
-		}
-	    }
-	} /* end for */
-
-    }
-    else if ((numRects = prgnDst->data->numRects))
-    {
-	/* Have to clip against many boxes */
-	BoxPtr pboxBandStart, pboxBandEnd;
-	BoxPtr pbox;
-	BoxPtr pboxLast;
-	int clipy1, clipy2;
-
-	/* In this case, taking advantage of sorted spans gains more than
-	   the sorting costs. */
-	if ((! fSorted) && (nspans > 1))
-	    QuickSortSpans(ppt, pwidth, nspans);
-
-	pboxBandStart = RegionBoxptr(prgnDst);
-	pboxLast = pboxBandStart + numRects;
-    
-	NextBand();
-
-	for (; ppt != pptLast; )
-	{
-	    y = ppt->y;
-	    if (y < clipy2)
-	    {
-		/* span is in the current band */
-		pbox = pboxBandStart;
-		x1 = ppt->x;
-		x2 = x1 + *pwidth;
-		do
-		{ /* For each box in band */
-		    int newx1, newx2;
-
-		    newx1 = x1;
-		    newx2 = x2;
-		    if (newx1 < pbox->x1)   newx1 = pbox->x1;
-		    if (newx2 > pbox->x2)   newx2 = pbox->x2;
-		    if (newx1 < newx2)
-		    {
-			/* Part of span in clip rectangle */
-			pptNew->x = newx1;
-			pptNew->y = y;
-			*pwidthNew = newx2 - newx1;
-			pptNew++;
-			pwidthNew++;
-		    }
-		    pbox++;
-		} while (pbox != pboxBandEnd);
-		ppt++;
-		pwidth++;
-	    }
-	    else
-	    {
-		/* Move to next band, adjust ppt as needed */
-		pboxBandStart = pboxBandEnd;
-		if (pboxBandStart == pboxLast)
-		    break; /* We're completely done */
-		NextBand();
-	    }
-	}
-    }
-    return pwidthNew - pwidthNewStart;
-}
