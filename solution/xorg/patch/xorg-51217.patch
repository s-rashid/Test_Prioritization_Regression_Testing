diff --git a/randr/rrcrtc.c b/randr/rrcrtc.c
index c2f6963..1f8f2e6 100644
--- a/randr/rrcrtc.c
+++ b/randr/rrcrtc.c
@@ -90,6 +90,8 @@ RRCrtcCreate (ScreenPtr pScreen, void *devPrivate)
     crtc->devPrivate = devPrivate;
     RRTransformInit (&crtc->client_pending_transform);
     RRTransformInit (&crtc->client_current_transform);
+    pixman_transform_init_identity (&crtc->client_sprite_position_transform);
+    pixman_transform_init_identity (&crtc->client_sprite_image_transform);
     pixman_transform_init_identity (&crtc->transform);
     pixman_f_transform_init_identity (&crtc->f_transform);
     pixman_f_transform_init_identity (&crtc->f_inverse);
@@ -392,6 +394,59 @@ RRCrtcSet (RRCrtcPtr    crtc,
     return ret;
 }
 
+void
+RRFreeCrtcConfigs(RRCrtcConfigPtr configs, int num_configs)
+{
+    int	i;
+
+    for (i = 0; i < num_configs; i++)
+	free(configs[i].outputs);
+    free(configs);
+}
+
+Bool
+RRCrtcCurrentConfig(RRCrtcPtr crtc,
+		    RRCrtcConfigPtr crtc_config)
+{
+    crtc_config->crtc = crtc;
+    crtc_config->x = crtc->x;
+    crtc_config->y = crtc->y;
+    crtc_config->mode = crtc->mode;
+    crtc_config->rotation = crtc->rotation;
+    crtc_config->numOutputs = crtc->numOutputs;
+    crtc_config->outputs = calloc(crtc->numOutputs, sizeof (RROutputPtr));
+    if (!crtc_config->outputs)
+	return FALSE;
+    memcpy(crtc_config->outputs, crtc->outputs, crtc->numOutputs * sizeof (RROutputPtr));
+    crtc_config->sprite_position_transform = crtc->client_sprite_f_position_transform;
+    crtc_config->sprite_image_transform = crtc->client_sprite_f_image_transform;
+
+    /* XXX add pixmap stuff */
+    crtc_config->pixmap = NULL;
+    crtc_config->pixmap_x = 0;
+    crtc_config->pixmap_y = 0;
+    return TRUE;
+}
+
+
+/*
+ * Request that a set of crtcs be configured at the same
+ * time on a single screen
+ */
+
+Bool
+RRSetCrtcConfigs(ScreenPtr screen,
+		 RRScreenConfigPtr screen_config,
+		 RRCrtcConfigPtr crtc_configs,
+		 int num_configs)
+{
+    rrScrPrivPtr	scr_priv = rrGetScrPriv(screen);
+
+    if (!scr_priv)
+	return FALSE;
+    return (*scr_priv->rrSetCrtcConfigs)(screen, screen_config, crtc_configs, num_configs);
+}
+
 /*
  * Return crtc transform
  */
@@ -631,6 +686,44 @@ RRCrtcTransformSet (RRCrtcPtr		crtc,
 }
 
 /*
+ * Figure out whether the specific crtc_config can fit
+ * within the screen_config
+ */
+Bool
+RRScreenCoversCrtc(RRScreenConfigPtr screen_config,
+		   RRCrtcConfigPtr crtc_config,
+		   RRTransformPtr client_transform,
+		   XID *errorValue)
+{
+    int source_width;
+    int	source_height;
+    struct pixman_f_transform f_transform;
+
+    RRTransformCompute (crtc_config->x, crtc_config->y,
+			crtc_config->mode->mode.width, crtc_config->mode->mode.height,
+			crtc_config->rotation,
+			client_transform,
+			&crtc_config->sprite_position_transform,
+			&crtc_config->sprite_image_transform,
+			NULL, &f_transform, NULL, NULL, NULL, NULL);
+
+    RRModeGetScanoutSize (crtc_config->mode, &f_transform,
+			  &source_width, &source_height);
+    if (crtc_config->x + source_width > screen_config->screen_pixmap_width) {
+	if (errorValue)
+	    *errorValue = crtc_config->x;
+	return FALSE;
+    }
+
+    if (crtc_config->y + source_height > screen_config->screen_pixmap_height) {
+	if (errorValue)
+	    *errorValue = crtc_config->y;
+	return FALSE;
+    }
+    return TRUE;
+}
+
+/*
  * Initialize crtc type
  */
 Bool
@@ -1360,3 +1453,336 @@ ProcRRGetCrtcTransform (ClientPtr client)
     free(reply);
     return Success;
 }
+
+static void
+pixman_f_transform_from_xRenderTransform(struct pixman_f_transform *f_transform,
+					 xRenderTransform *x_transform)
+{
+    struct pixman_transform	transform;
+    PictTransform_from_xRenderTransform(&transform, x_transform);
+    pixman_f_transform_from_pixman_transform(f_transform, &transform);
+}
+
+static int
+RRConvertCrtcConfig(ClientPtr client, ScreenPtr screen,
+		    RRScreenConfigPtr screen_config,
+		    RRCrtcConfigPtr config, xRRCrtcConfig *x,
+		    RROutput *outputIds)
+{
+    RRCrtcPtr		crtc;
+    RROutputPtr		*outputs;
+    rrScrPrivPtr	scr_priv;
+    RRModePtr		mode;
+    PixmapPtr		pixmap;
+    int			rc, i, j;
+    Rotation		rotation;
+
+    VERIFY_RR_CRTC(x->crtc, crtc, DixSetAttrAccess);
+
+    if (x->mode == None)
+    {
+	mode = NULL;
+	if (x->nOutput > 0)
+	    return BadMatch;
+    }
+    else
+    {
+	VERIFY_RR_MODE(x->mode, mode, DixSetAttrAccess);
+	if (x->nOutput == 0)
+	    return BadMatch;
+    }
+    if (x->nOutput)
+    {
+	outputs = malloc(x->nOutput * sizeof (RROutputPtr));
+	if (!outputs)
+	    return BadAlloc;
+    }
+    else
+	outputs = NULL;
+
+    if (x->pixmap == None)
+	pixmap = NULL;
+    else
+    {
+	rc = dixLookupResourceByType((pointer *) &pixmap, x->pixmap,
+				     RT_PIXMAP, client, DixWriteAccess);
+	if (rc != Success) {
+	    free(outputs);
+	    return rc;
+	}
+	/* XXX check to make sure this is a scanout pixmap */
+    }
+
+    for (i = 0; i < x->nOutput; i++)
+    {
+	rc = dixLookupResourceByType((pointer *)(outputs + i), outputIds[i],
+				     RROutputType, client, DixSetAttrAccess);
+	if (rc != Success)
+	{
+	    free(outputs);
+	    return rc;
+	}
+	/* validate crtc for this output */
+	for (j = 0; j < outputs[i]->numCrtcs; j++)
+	    if (outputs[i]->crtcs[j] == crtc)
+		break;
+	if (j == outputs[i]->numCrtcs)
+	{
+	    free(outputs);
+	    return BadMatch;
+	}
+	/* validate mode for this output */
+	for (j = 0; j < outputs[i]->numModes + outputs[i]->numUserModes; j++)
+	{
+	    RRModePtr	m = (j < outputs[i]->numModes ?
+			     outputs[i]->modes[j] :
+			     outputs[i]->userModes[j - outputs[i]->numModes]);
+	    if (m == mode)
+		break;
+	}
+	if (j == outputs[i]->numModes + outputs[i]->numUserModes)
+	{
+	    free(outputs);
+	    return BadMatch;
+	}
+    }
+    /* validate clones */
+    for (i = 0; i < x->nOutput; i++)
+    {
+	for (j = 0; j < x->nOutput; j++)
+	{
+	    int k;
+	    if (i == j)
+		continue;
+	    for (k = 0; k < outputs[i]->numClones; k++)
+	    {
+		if (outputs[i]->clones[k] == outputs[j])
+		    break;
+	    }
+	    if (k == outputs[i]->numClones)
+	    {
+		free(outputs);
+		return BadMatch;
+	    }
+	}
+    }
+
+    if (crtc->pScreen != screen)
+	return BadMatch;
+
+    scr_priv = rrGetScrPriv(screen);
+
+    config->crtc = crtc;
+    config->x = x->x;
+    config->y = x->y;
+    config->mode = mode;
+    config->rotation = x->rotation;
+    config->numOutputs = x->nOutput;
+    config->outputs = outputs;
+    pixman_f_transform_from_xRenderTransform(&config->sprite_position_transform,
+					     &x->spritePositionTransform);
+    pixman_f_transform_from_xRenderTransform(&config->sprite_image_transform,
+					     &x->spriteImageTransform);
+    config->pixmap = pixmap;
+    config->pixmap_x = x->xPixmap;
+    config->pixmap_y = x->yPixmap;
+
+    /*
+     * Validate requested rotation
+     */
+    rotation = (Rotation) x->rotation;
+
+    /* test the rotation bits only! */
+    switch (rotation & 0xf) {
+    case RR_Rotate_0:
+    case RR_Rotate_90:
+    case RR_Rotate_180:
+    case RR_Rotate_270:
+	break;
+    default:
+	/*
+	 * Invalid rotation
+	 */
+	client->errorValue = x->rotation;
+	free(outputs);
+	return BadValue;
+    }
+
+    if (mode)
+    {
+	if ((~crtc->rotations) & rotation)
+	{
+	    /*
+	     * requested rotation or reflection not supported by screen
+	     */
+	    client->errorValue = x->rotation;
+	    free(outputs);
+	    return BadMatch;
+	}
+
+	/*
+	 * If scanning out from another pixmap, make sure the mode
+	 * fits
+	 */
+	if (pixmap)
+	{
+	    if (x->xPixmap + mode->mode.width > pixmap->drawable.width) {
+		client->errorValue = x->xPixmap;
+		free(outputs);
+		return BadValue;
+	    }
+	    if (x->yPixmap + mode->mode.height > pixmap->drawable.height) {
+		client->errorValue = x->yPixmap;
+		free(outputs);
+		return BadValue;
+	    }
+	}
+	/*
+	 * Check screen size bounds if the DDX provides a 1.2 interface
+	 * for setting screen size. Else, assume the CrtcSet sets
+	 * the size along with the mode. If the driver supports transforms,
+	 * then it must allow crtcs to display a subset of the screen, so
+	 * only do this check for drivers without transform support.
+	 */
+	else if (scr_priv->rrScreenSetSize && !crtc->transforms)
+	{
+	    if (!RRScreenCoversCrtc(screen_config, config,
+				    &crtc->client_pending_transform,
+				    &client->errorValue))
+	    {
+		free(outputs);
+		return BadValue;
+	    }
+	}
+    }
+
+    return Success;
+}
+
+int
+ProcRRSetCrtcConfigs (ClientPtr client)
+{
+    REQUEST(xRRSetCrtcConfigsReq);
+    xRRSetCrtcConfigsReply  rep;
+    DrawablePtr		    drawable;
+    ScreenPtr		    screen;
+    rrScrPrivPtr	    scr_priv;
+    xRRCrtcConfig	    *x_configs;
+    RRScreenConfigRec	    screen_config;
+    RRCrtcConfigPtr	    configs;
+    RROutput		    *output_ids;
+    int			    num_configs;
+    int			    rc, i;
+    int			    extra_len;
+    int			    num_output_ids;
+
+    REQUEST_AT_LEAST_SIZE(xRRSetCrtcConfigsReq);
+
+    extra_len = client->req_len - bytes_to_int32(sizeof(xRRSetCrtcConfigsReq));
+
+    num_configs = stuff->nConfigs;
+
+    /* Check request length against number of configs specified */
+    if (num_configs * (sizeof (xRRCrtcConfig) >> 2) > extra_len)
+	return BadLength;
+
+    extra_len -= num_configs * (sizeof (xRRCrtcConfig) >> 2);
+    x_configs = (xRRCrtcConfig *) (stuff + 1);
+
+    /* Check remaining request length against number of outputs */
+    num_output_ids = 0;
+    for (i = 0; i < num_configs; i++)
+	num_output_ids += x_configs[i].nOutput;
+
+    if (extra_len != num_output_ids)
+	return BadLength;
+
+    rc = dixLookupDrawable(&drawable, stuff->drawable, client, 0, DixGetAttrAccess);
+    if (rc != Success)
+	return rc;
+
+    screen = drawable->pScreen;
+
+    scr_priv = rrGetScrPriv(screen);
+
+    if (!scr_priv)
+    {
+	rep.status = RRSetConfigFailed;
+	goto sendReply;
+    }
+
+    if (stuff->widthInMillimeters == 0 || stuff->heightInMillimeters == 0)
+    {
+	client->errorValue = 0;
+	return BadValue;
+    }
+
+    if (stuff->screenPixmapWidth < scr_priv->minWidth ||
+	scr_priv->maxWidth < stuff->screenPixmapWidth)
+    {
+	client->errorValue = stuff->screenPixmapWidth;
+	return BadValue;
+    }
+    if (stuff->screenPixmapHeight < scr_priv->minHeight ||
+	scr_priv->maxHeight < stuff->screenPixmapHeight)
+    {
+	client->errorValue = stuff->screenPixmapHeight;
+	return BadValue;
+    }
+
+    screen_config.screen_pixmap_width = stuff->screenPixmapWidth;
+    screen_config.screen_pixmap_height = stuff->screenPixmapHeight;
+    screen_config.screen_width = stuff->screenWidth;
+    screen_config.screen_height = stuff->screenHeight;
+    screen_config.mm_width = stuff->widthInMillimeters;
+    screen_config.mm_height = stuff->heightInMillimeters;
+
+    if (num_configs == 0)
+	return Success;
+
+    output_ids = (RROutput *) (x_configs + num_configs);
+
+    /*
+     * Convert protocol crtc configurations into
+     * server crtc configurations
+     */
+    configs = calloc(num_configs, sizeof (RRCrtcConfigRec));
+    if (!configs)
+	return BadAlloc;
+    for (i = 0; i < num_configs; i++) {
+	rc = RRConvertCrtcConfig(client, screen, &screen_config,
+				 &configs[i],
+				 &x_configs[i], output_ids);
+	if (rc != Success) {
+	    rep.status = RRSetConfigFailed;
+	    goto sendReply;
+	}
+	output_ids += x_configs[i].nOutput;
+    }
+
+    if (!RRSetCrtcConfigs (screen, &screen_config, configs, num_configs))
+    {
+	rep.status = RRSetConfigFailed;
+	goto sendReply;
+    }
+    rep.status = RRSetConfigSuccess;
+    scr_priv->lastSetTime = currentTime;
+
+sendReply:
+    RRFreeCrtcConfigs(configs, num_configs);
+
+    rep.type = X_Reply;
+    /* rep.status has already been filled in */
+    rep.length = 0;
+    rep.sequenceNumber = client->sequence;
+
+    if (client->swapped)
+    {
+	int n;
+	swaps(&rep.sequenceNumber, n);
+	swapl(&rep.length, n);
+    }
+    WriteToClient(client, sizeof(xRRSetCrtcConfigsReply), (char *)&rep);
+
+    return Success;
+}
