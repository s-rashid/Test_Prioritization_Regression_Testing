diff --git a/hw/xwin/glx/indirect.c b/hw/xwin/glx/indirect.c
index 86fef55..56f677a 100644
--- a/hw/xwin/glx/indirect.c
+++ b/hw/xwin/glx/indirect.c
@@ -117,8 +117,7 @@ struct __GLXWinContext {
   HWND hwnd;                         /* For detecting when HWND has changed */
 };
 
-struct __GLXWinDrawable
-{
+struct __GLXWinDrawable {
   __GLXdrawable base;
   __GLXWinContext *drawContext;
   __GLXWinContext *readContext;
@@ -133,8 +132,7 @@ struct __GLXWinDrawable
   void *pOldBits; /* original pBits for this drawable's pixmap */
 };
 
-struct __GLXWinScreen
-{
+struct __GLXWinScreen {
   __GLXscreen base;
 
   /* Supported GLX extensions */
@@ -151,8 +149,7 @@ struct __GLXWinScreen
   CopyWindowProcPtr CopyWindow;
 };
 
-struct __GLXWinConfig
-{
+struct __GLXWinConfig {
   __GLXconfig base;
   int pixelFormatIndex;
 };
@@ -171,7 +168,8 @@ struct __GLXWinConfig
 
 glxWinDebugSettingsRec glxWinDebugSettings = { 0, 0, 0, 0, 0, 0};
 
-static void glxWinInitDebugSettings(void)
+static void
+glxWinInitDebugSettings(void)
 {
     char *envptr;
 
@@ -204,8 +202,7 @@ static void glxWinInitDebugSettings(void)
         glxWinDebugSettings.enableWGLcallTrace = (atoi(envptr) == 1);
 
     envptr = getenv("GLWIN_DEBUG_ALL");
-    if (envptr != NULL)
-      {
+    if (envptr != NULL) {
         glxWinDebugSettings.enableDebug = 1;
         glxWinDebugSettings.enableTrace = 1;
         glxWinDebugSettings.dumpPFD = 1;
@@ -217,24 +214,21 @@ static void glxWinInitDebugSettings(void)
 }
 
 static
-const char *glxWinErrorMessage(void)
+const char *
+glxWinErrorMessage(void)
 {
   static char errorbuffer[1024];
   unsigned int last_error = GetLastError();
 
-  if (!FormatMessage(
-                     FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
-                     NULL,
-                     last_error,
-                     0,
-                     (LPTSTR) &errorbuffer,
-                     sizeof(errorbuffer),
-                     NULL ))
-    {
+    if (!FormatMessage
+        (FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS |
+         FORMAT_MESSAGE_MAX_WIDTH_MASK, NULL, last_error, 0,
+         (LPTSTR) & errorbuffer, sizeof(errorbuffer), NULL)) {
       snprintf(errorbuffer, sizeof(errorbuffer), "Unknown error");
     }
 
-  if ((errorbuffer[strlen(errorbuffer)-1] == '\n') || (errorbuffer[strlen(errorbuffer)-1] == '\r'))
+    if ((errorbuffer[strlen(errorbuffer) - 1] == '\n') ||
+        (errorbuffer[strlen(errorbuffer) - 1] == '\r'))
     errorbuffer[strlen(errorbuffer)-1] = 0;
 
   sprintf(errorbuffer + strlen(errorbuffer), " (%08x)", last_error);
@@ -250,9 +244,11 @@ static void pfdOut(const PIXELFORMATDESCRIPTOR *pfd);
         pipesym = " | "; \
     }
 
-static void pfdOut(const PIXELFORMATDESCRIPTOR *pfd)
+static void
+pfdOut(const PIXELFORMATDESCRIPTOR * pfd)
 {
     const char *pipesym = ""; /* will be set after first flag dump */
+
     ErrorF("PIXELFORMATDESCRIPTOR:\n");
     ErrorF("nSize = %u\n", pfd->nSize);
     ErrorF("nVersion = %u\n", pfd->nVersion);
@@ -279,7 +275,8 @@ static void pfdOut(const PIXELFORMATDESCRIPTOR *pfd)
     ErrorF("}\n");
 
     ErrorF("iPixelType = %hu = %s\n", pfd->iPixelType,
-            (pfd->iPixelType == PFD_TYPE_RGBA ? "PFD_TYPE_RGBA" : "PFD_TYPE_COLORINDEX"));
+           (pfd->iPixelType ==
+            PFD_TYPE_RGBA ? "PFD_TYPE_RGBA" : "PFD_TYPE_COLORINDEX"));
     ErrorF("cColorBits = %hhu\n", pfd->cColorBits);
     ErrorF("cRedBits = %hhu\n", pfd->cRedBits);
     ErrorF("cRedShift = %hhu\n", pfd->cRedShift);
@@ -329,8 +326,7 @@ visual_class_name(int cls)
 static const char *
 swap_method_name(int mthd)
 {
-  switch (mthd)
-    {
+    switch (mthd) {
     case GLX_SWAP_EXCHANGE_OML:
       return "xchg";
     case GLX_SWAP_COPY_OML:
@@ -346,12 +342,14 @@ static void
 fbConfigsDump(unsigned int n, __GLXconfig *c)
 {
   ErrorF("%d fbConfigs\n", n);
-  ErrorF("pxf vis  fb                      render         Ste                     aux    accum        MS    drawable             Group/\n");
-  ErrorF("idx  ID  ID VisualType Depth Lvl RGB CI DB Swap reo  R  G  B  A   Z  S  buf AR AG AB AA  bufs num  W P Pb  Float Trans Caveat\n");
-  ErrorF("-----------------------------------------------------------------------------------------------------------------------------\n");
-
-  while (c != NULL)
-    {
+    ErrorF
+        ("pxf vis  fb                      render         Ste                     aux    accum        MS    drawable             Group/\n");
+    ErrorF
+        ("idx  ID  ID VisualType Depth Lvl RGB CI DB Swap reo  R  G  B  A   Z  S  buf AR AG AB AA  bufs num  W P Pb  Float Trans Caveat\n");
+    ErrorF
+        ("-----------------------------------------------------------------------------------------------------------------------------\n");
+
+    while (c != NULL) {
       unsigned int i = ((GLXWinConfig *)c)->pixelFormatIndex;
 
       ErrorF("%3d %3x %3x "
@@ -379,14 +377,14 @@ fbConfigsDump(unsigned int n, __GLXconfig *c)
              c->redBits, c->greenBits, c->blueBits, c->alphaBits,
              c->depthBits, c->stencilBits,
              c->numAuxBuffers,
-             c->accumRedBits, c->accumGreenBits, c->accumBlueBits, c->accumAlphaBits,
-             c->sampleBuffers, c->samples,
+               c->accumRedBits, c->accumGreenBits, c->accumBlueBits,
+               c->accumAlphaBits, c->sampleBuffers, c->samples,
              (c->drawableType & GLX_WINDOW_BIT) ? "y" : ".",
              (c->drawableType & GLX_PIXMAP_BIT) ? "y" : ".",
-             (c->drawableType & GLX_PBUFFER_BIT) ? "y" : ".",
-             ".",
+               (c->drawableType & GLX_PBUFFER_BIT) ? "y" : ".", ".",
              (c->transparentPixel != GLX_NONE_EXT) ? "y" : ".",
-             c->visualSelectGroup, (c->visualRating == GLX_SLOW_VISUAL_EXT) ? "*" : " ");
+               c->visualSelectGroup,
+               (c->visualRating == GLX_SLOW_VISUAL_EXT) ? "*" : " ");
 
       c = c->next;
     }
@@ -406,20 +404,25 @@ static __GLXdrawable *glxWinCreateDrawable(ClientPtr client,
                                           DrawablePtr pDraw,
                                           XID drawId,
                                           int type,
-                                          XID glxDrawId,
-                                          __GLXconfig *conf);
+                                           XID glxDrawId, __GLXconfig * conf);
 
 static Bool glxWinRealizeWindow(WindowPtr pWin);
 static Bool glxWinUnrealizeWindow(WindowPtr pWin);
-static void glxWinCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc);
+static void glxWinCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg,
+                             RegionPtr prgnSrc);
 
-static HDC glxWinMakeDC(__GLXWinContext *gc, __GLXWinDrawable *draw, HDC *hdc, HWND *hwnd);
+static HDC glxWinMakeDC(__GLXWinContext * gc, __GLXWinDrawable * draw,
+                        HDC * hdc, HWND * hwnd);
 static void glxWinReleaseDC(HWND hwnd, HDC hdc, __GLXWinDrawable *draw);
 
 static void glxWinCreateConfigs(HDC dc, glxWinScreen *screen);
 static void glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen);
-static int fbConfigToPixelFormat(__GLXconfig *mode, PIXELFORMATDESCRIPTOR *pfdret, int drawableTypeOverride);
-static int fbConfigToPixelFormatIndex(HDC hdc, __GLXconfig *mode, int drawableTypeOverride, glxWinScreen *winScreen);
+static int fbConfigToPixelFormat(__GLXconfig * mode,
+                                 PIXELFORMATDESCRIPTOR * pfdret,
+                                 int drawableTypeOverride);
+static int fbConfigToPixelFormatIndex(HDC hdc, __GLXconfig * mode,
+                                      int drawableTypeOverride,
+                                      glxWinScreen * winScreen);
 
 /* ---------------------------------------------------------------------- */
 /*
@@ -455,9 +458,10 @@ static int
 glxWinScreenSwapInterval(__GLXdrawable *drawable, int interval)
 {
   BOOL ret = wglSwapIntervalEXTWrapper(interval);
-  if (!ret)
-    {
-      ErrorF("wglSwapIntervalEXT interval %d failed:%s\n", interval, glxWinErrorMessage());
+
+    if (!ret) {
+        ErrorF("wglSwapIntervalEXT interval %d failed:%s\n", interval,
+               glxWinErrorMessage());
     }
   return ret;
 }
@@ -472,8 +476,7 @@ glxLogExtensions(const char *prefix, const char *extensions)
   char *strl;
   char *str = strdup(extensions);
 
-  if (str == NULL)
-    {
+    if (str == NULL) {
       ErrorF("glxLogExtensions: xalloc error\n");
       return;
     }
@@ -482,19 +485,17 @@ glxLogExtensions(const char *prefix, const char *extensions)
   ErrorF("%s%s", prefix, strl);
   length = strlen(prefix) + strlen(strl);
 
-  while (1)
-    {
+    while (1) {
       strl = strtok(NULL, " ");
-      if (strl == NULL) break;
+        if (strl == NULL)
+            break;
 
-      if (length + strlen(strl) + 1 > 120)
-        {
+        if (length + strlen(strl) + 1 > 120) {
           ErrorF("\n");
           ErrorF("%s",prefix);
           length = strlen(prefix);
         }
-      else
-        {
+        else {
           ErrorF(" ");
           length++;
         }
@@ -526,9 +527,9 @@ glxWinScreenProbe(ScreenPtr pScreen)
     if (pScreen == NULL)
 	return NULL;
 
-    if (!winCheckScreenAiglxIsSupported(pScreen))
-      {
-        LogMessage(X_ERROR,"AIGLX: No native OpenGL in modes with a root window\n");
+    if (!winCheckScreenAiglxIsSupported(pScreen)) {
+        LogMessage(X_ERROR,
+                   "AIGLX: No native OpenGL in modes with a root window\n");
         return NULL;
       }
 
@@ -551,9 +552,10 @@ glxWinScreenProbe(ScreenPtr pScreen)
 #define WIN_GL_TEST_WINDOW_CLASS "XWinGLTest"
     {
       static wATOM glTestWndClass = 0;
-      if (glTestWndClass == 0)
-        {
+
+        if (glTestWndClass == 0) {
           WNDCLASSEX wc;
+
           wc.cbSize = sizeof(WNDCLASSEX);
           wc.style = CS_HREDRAW | CS_VREDRAW;
           wc.lpfnWndProc = DefWindowProc;
@@ -574,9 +576,11 @@ glxWinScreenProbe(ScreenPtr pScreen)
     hwnd = CreateWindowExA(0,
                            WIN_GL_TEST_WINDOW_CLASS,
                            "XWin GL Renderer Capabilities Test Window",
-                           0, 0, 0, 0, 0, NULL, NULL, GetModuleHandle(NULL), NULL);
+                           0, 0, 0, 0, 0, NULL, NULL, GetModuleHandle(NULL),
+                           NULL);
     if (hwnd == NULL)
-      LogMessage(X_ERROR,"AIGLX: Couldn't create a window for render capabilities testing\n");
+        LogMessage(X_ERROR,
+                   "AIGLX: Couldn't create a window for render capabilities testing\n");
 
     hdc = GetDC(hwnd);
 
@@ -595,7 +599,8 @@ glxWinScreenProbe(ScreenPtr pScreen)
     gl_extensions = (const char *)glGetStringWrapperNonstatic(GL_EXTENSIONS);
     glxLogExtensions("GL_EXTENSIONS:  ", gl_extensions);
     wgl_extensions = wglGetExtensionsStringARBWrapper(hdc);
-    if (!wgl_extensions) wgl_extensions = "";
+    if (!wgl_extensions)
+        wgl_extensions = "";
     glxLogExtensions("WGL_EXTENSIONS: ", wgl_extensions);
 
     // Can you see the problem here?  The extensions string is DC specific
@@ -606,8 +611,8 @@ glxWinScreenProbe(ScreenPtr pScreen)
     {
       // testing facility to not use any WGL extensions
       char *envptr = getenv("GLWIN_NO_WGL_EXTENSIONS");
-      if ((envptr != NULL) && (atoi(envptr) != 0))
-        {
+
+        if ((envptr != NULL) && (atoi(envptr) != 0)) {
           ErrorF("GLWIN_NO_WGL_EXTENSIONS is set, ignoring WGL_EXTENSIONS\n");
           wgl_extensions = "";
         }
@@ -628,24 +633,26 @@ glxWinScreenProbe(ScreenPtr pScreen)
       __glXEnableExtension(screen->glx_enable_bits, "GLX_OML_swap_method");
       __glXEnableExtension(screen->glx_enable_bits, "GLX_SGIX_fbconfig");
 
-      if (strstr(wgl_extensions, "WGL_ARB_make_current_read"))
-        {
-          __glXEnableExtension(screen->glx_enable_bits, "GLX_SGI_make_current_read");
+        if (strstr(wgl_extensions, "WGL_ARB_make_current_read")) {
+            __glXEnableExtension(screen->glx_enable_bits,
+                                 "GLX_SGI_make_current_read");
           LogMessage(X_INFO, "AIGLX: enabled GLX_SGI_make_current_read\n");
           glx_sgi_make_current_read = TRUE;
         }
 
-      if (strstr(gl_extensions, "GL_WIN_swap_hint"))
-        {
-          __glXEnableExtension(screen->glx_enable_bits, "GLX_MESA_copy_sub_buffer");
+        if (strstr(gl_extensions, "GL_WIN_swap_hint")) {
+            __glXEnableExtension(screen->glx_enable_bits,
+                                 "GLX_MESA_copy_sub_buffer");
           LogMessage(X_INFO, "AIGLX: enabled GLX_MESA_copy_sub_buffer\n");
         }
 
-      if (strstr(wgl_extensions, "WGL_EXT_swap_control"))
-        {
-          __glXEnableExtension(screen->glx_enable_bits, "GLX_SGI_swap_control");
-          __glXEnableExtension(screen->glx_enable_bits, "GLX_MESA_swap_control");
-          LogMessage(X_INFO, "AIGLX: enabled GLX_SGI_swap_control and GLX_MESA_swap_control\n");
+        if (strstr(wgl_extensions, "WGL_EXT_swap_control")) {
+            __glXEnableExtension(screen->glx_enable_bits,
+                                 "GLX_SGI_swap_control");
+            __glXEnableExtension(screen->glx_enable_bits,
+                                 "GLX_MESA_swap_control");
+            LogMessage(X_INFO,
+                       "AIGLX: enabled GLX_SGI_swap_control and GLX_MESA_swap_control\n");
         }
 
 /*       // Hmm?  screen->texOffset */
@@ -656,18 +663,19 @@ glxWinScreenProbe(ScreenPtr pScreen)
 /*           screen->has_WGL_ARB_render_texture = TRUE; */
 /*         } */
 
-      if (strstr(wgl_extensions, "WGL_ARB_pbuffer"))
-        {
+        if (strstr(wgl_extensions, "WGL_ARB_pbuffer")) {
           __glXEnableExtension(screen->glx_enable_bits, "GLX_SGIX_pbuffer");
           LogMessage(X_INFO, "AIGLX: enabled GLX_SGIX_pbuffer\n");
           screen->has_WGL_ARB_pbuffer = TRUE;
         }
 
-      if (strstr(wgl_extensions, "WGL_ARB_multisample"))
-        {
-          __glXEnableExtension(screen->glx_enable_bits, "GLX_ARB_multisample");
-          __glXEnableExtension(screen->glx_enable_bits, "GLX_SGIS_multisample");
-          LogMessage(X_INFO, "AIGLX: enabled GLX_ARB_multisample and GLX_SGIS_multisample\n");
+        if (strstr(wgl_extensions, "WGL_ARB_multisample")) {
+            __glXEnableExtension(screen->glx_enable_bits,
+                                 "GLX_ARB_multisample");
+            __glXEnableExtension(screen->glx_enable_bits,
+                                 "GLX_SGIS_multisample");
+            LogMessage(X_INFO,
+                       "AIGLX: enabled GLX_ARB_multisample and GLX_SGIS_multisample\n");
           screen->has_WGL_ARB_multisample = TRUE;
         }
 
@@ -678,8 +686,7 @@ glxWinScreenProbe(ScreenPtr pScreen)
       screen->base.pScreen = pScreen;
 
       // Creating the fbConfigs initializes screen->base.fbconfigs and screen->base.numFBConfigs
-      if (strstr(wgl_extensions, "WGL_ARB_pixel_format"))
-        {
+        if (strstr(wgl_extensions, "WGL_ARB_pixel_format")) {
           glxWinCreateConfigsExt(hdc, screen);
 
           /*
@@ -687,14 +694,12 @@ glxWinScreenProbe(ScreenPtr pScreen)
             but it doesn't work usefully, so we have to be prepared for it
             to fail and fall back to using DescribePixelFormat()
           */
-          if (screen->base.numFBConfigs > 0)
-            {
+            if (screen->base.numFBConfigs > 0) {
               screen->has_WGL_ARB_pixel_format = TRUE;
             }
         }
 
-      if (screen->base.numFBConfigs <= 0)
-        {
+        if (screen->base.numFBConfigs <= 0) {
           glxWinCreateConfigs(hdc, screen);
           screen->has_WGL_ARB_pixel_format = FALSE;
         }
@@ -702,10 +707,10 @@ glxWinScreenProbe(ScreenPtr pScreen)
       /*
         If we still didn't get any fbConfigs, we can't provide GLX for this screen
        */
-      if (screen->base.numFBConfigs <= 0)
-        {
+        if (screen->base.numFBConfigs <= 0) {
           free(screen);
-          LogMessage(X_ERROR,"AIGLX: No fbConfigs could be made from native OpenGL pixel formats\n");
+            LogMessage(X_ERROR,
+                       "AIGLX: No fbConfigs could be made from native OpenGL pixel formats\n");
           return NULL;
         }
 
@@ -723,13 +728,14 @@ glxWinScreenProbe(ScreenPtr pScreen)
 
       // Generate the GLX extensions string (overrides that set by __glXScreenInit())
       {
-        unsigned int buffer_size = __glXGetExtensionString(screen->glx_enable_bits, NULL);
-        if (buffer_size > 0)
-          {
+            unsigned int buffer_size =
+                __glXGetExtensionString(screen->glx_enable_bits, NULL);
+            if (buffer_size > 0) {
             free(screen->base.GLXextensions);
 
             screen->base.GLXextensions = xnfalloc(buffer_size);
-            __glXGetExtensionString(screen->glx_enable_bits, screen->base.GLXextensions);
+                __glXGetExtensionString(screen->glx_enable_bits,
+                                        screen->base.GLXextensions);
           }
       }
 
@@ -740,21 +746,19 @@ glxWinScreenProbe(ScreenPtr pScreen)
       // SGIX_fbconfig && SGIX_pbuffer && SGI_make_current_read -> 1.3
       // ARB_multisample -> 1.4
       //
-      if (screen->has_WGL_ARB_pbuffer && glx_sgi_make_current_read)
-        {
-          if (screen->has_WGL_ARB_multisample)
-            {
+        if (screen->has_WGL_ARB_pbuffer && glx_sgi_make_current_read) {
+            if (screen->has_WGL_ARB_multisample) {
               screen->base.GLXmajor = 1;
               screen->base.GLXminor = 4;
             }
-          else
-            {
+            else {
               screen->base.GLXmajor = 1;
               screen->base.GLXminor = 3;
             }
         }
     }
-    LogMessage(X_INFO, "AIGLX: Set GLX version to %d.%d\n", screen->base.GLXmajor, screen->base.GLXminor);
+    LogMessage(X_INFO, "AIGLX: Set GLX version to %d.%d\n",
+               screen->base.GLXmajor, screen->base.GLXminor);
 
     wglMakeCurrent(NULL, NULL);
     wglDeleteContext(hglrc);
@@ -786,7 +790,6 @@ glxWinRealizeWindow(WindowPtr pWin)
     return result;
 }
 
-
 static void
 glxWinCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
 {
@@ -796,9 +799,8 @@ glxWinCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
 
     GLWIN_TRACE_MSG("glxWinCopyWindow pWindow %p", pWindow);
 
-    dixLookupResourceByType((pointer) &pGlxDraw, pWindow->drawable.id, __glXDrawableRes,
-				NullClient, DixUnknownAccess);
-
+    dixLookupResourceByType((pointer) &pGlxDraw, pWindow->drawable.id,
+                            __glXDrawableRes, NullClient, DixUnknownAccess);
 
     /*
        Discard any CopyWindow requests if a GL drawing context is pointing at the window
@@ -807,8 +809,7 @@ glxWinCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
        correct bits, so we wish to avoid shadow framebuffer damage occuring, which will
        cause those incorrect bits to be transferred to the display....
     */
-    if (pGlxDraw && pGlxDraw->drawContext)
-      {
+    if (pGlxDraw && pGlxDraw->drawContext) {
         GLWIN_DEBUG_MSG("glxWinCopyWindow: discarding");
         return;
       }
@@ -850,19 +851,21 @@ glxWinDrawableSwapBuffers(ClientPtr client, __GLXdrawable *base)
     __GLXWinDrawable *draw = (__GLXWinDrawable *)base;
 
     /* Swap buffers on the last active context for drawing on the drawable */
-    if (draw->drawContext == NULL)
-      {
+    if (draw->drawContext == NULL) {
         GLWIN_TRACE_MSG("glxWinSwapBuffers - no context for drawable");
         return GL_FALSE;
       }
 
-    GLWIN_TRACE_MSG("glxWinSwapBuffers on drawable %p, last context %p (native ctx %p)", base, draw->drawContext, draw->drawContext->ctx);
+    GLWIN_TRACE_MSG
+        ("glxWinSwapBuffers on drawable %p, last context %p (native ctx %p)",
+         base, draw->drawContext, draw->drawContext->ctx);
 
     /*
        draw->drawContext->base.drawPriv will not be set if the context is not current anymore,
        but if it is, it should point to this drawable....
     */
-    assert((draw->drawContext->base.drawPriv == NULL) || (draw->drawContext->base.drawPriv == base));
+    assert((draw->drawContext->base.drawPriv == NULL) ||
+           (draw->drawContext->base.drawPriv == base));
 
     dc = glxWinMakeDC(draw->drawContext, draw, &dc, &hwnd);
     if (dc == NULL)
@@ -872,8 +875,7 @@ glxWinDrawableSwapBuffers(ClientPtr client, __GLXdrawable *base)
 
     glxWinReleaseDC(hwnd, dc, draw);
 
-    if (!ret)
-      {
+    if (!ret) {
         ErrorF("wglSwapBuffers failed: %s\n", glxWinErrorMessage());
         return GL_FALSE;
       }
@@ -894,8 +896,8 @@ glxWinDrawableDestroy(__GLXdrawable *base)
 {
   __GLXWinDrawable *glxPriv = (__GLXWinDrawable *)base;
 
-  if (glxPriv->drawContext && (__glXLastContext == &((glxPriv->drawContext)->base)))
-    {
+    if (glxPriv->drawContext &&
+        (__glXLastContext == &((glxPriv->drawContext)->base))) {
       // if this context is current and has unflushed commands, say we have flushed them
       // (don't actually flush them, the window is going away anyhow, and an implict flush occurs
       // on the next context change)
@@ -906,26 +908,21 @@ glxWinDrawableDestroy(__GLXdrawable *base)
     }
 
   if (glxPriv->hPbuffer)
-    if (!wglDestroyPbufferARBWrapper(glxPriv->hPbuffer))
-      {
+        if (!wglDestroyPbufferARBWrapper(glxPriv->hPbuffer)) {
         ErrorF("wglDestroyPbufferARB failed: %s\n", glxWinErrorMessage());
       }
 
-  if (glxPriv->dibDC)
-    {
+    if (glxPriv->dibDC) {
       // restore the default DIB
       SelectObject(glxPriv->dibDC, glxPriv->hOldDIB);
 
-      if (!DeleteDC(glxPriv->dibDC))
-        {
+        if (!DeleteDC(glxPriv->dibDC)) {
           ErrorF("DeleteDC failed: %s\n", glxWinErrorMessage());
         }
     }
 
-  if (glxPriv->hDIB)
-    {
-      if (!DeleteObject(glxPriv->hDIB))
-        {
+    if (glxPriv->hDIB) {
+        if (!DeleteObject(glxPriv->hDIB)) {
           ErrorF("DeleteObject failed: %s\n", glxWinErrorMessage());
         }
 
@@ -940,10 +937,7 @@ static __GLXdrawable *
 glxWinCreateDrawable(ClientPtr client,
                     __GLXscreen *screen,
                     DrawablePtr pDraw,
-                    XID drawId,
-                    int type,
-                    XID glxDrawId,
-                    __GLXconfig *conf)
+                     XID drawId, int type, XID glxDrawId, __GLXconfig * conf)
 {
   __GLXWinDrawable *glxPriv;
 
@@ -954,7 +948,8 @@ glxWinCreateDrawable(ClientPtr client,
 
   memset(glxPriv, 0, sizeof *glxPriv);
 
-  if(!__glXDrawableInit(&glxPriv->base, screen, pDraw, type, glxDrawId, conf)) {
+    if (!__glXDrawableInit
+        (&glxPriv->base, screen, pDraw, type, glxDrawId, conf)) {
     free(glxPriv);
     return NULL;
   }
@@ -976,18 +971,18 @@ glxWinCreateDrawable(ClientPtr client,
  */
 
 static
-int glxWinBindTexImage(__GLXcontext  *baseContext,
-                      int            buffer,
-                      __GLXdrawable *pixmap)
+    int
+glxWinBindTexImage(__GLXcontext * baseContext,
+                   int buffer, __GLXdrawable * pixmap)
 {
   ErrorF("glxWinBindTexImage: not implemented\n");
   return FALSE;
 }
 
 static
-int glxWinReleaseTexImage(__GLXcontext  *baseContext,
-                         int            buffer,
-                         __GLXdrawable *pixmap)
+    int
+glxWinReleaseTexImage(__GLXcontext * baseContext,
+                      int buffer, __GLXdrawable * pixmap)
 {
   ErrorF(" glxWinReleaseTexImage: not implemented\n");
   return FALSE;
@@ -1013,7 +1008,8 @@ int glxWinReleaseTexImage(__GLXcontext  *baseContext,
  */
 
 static Bool
-glxWinSetPixelFormat(__GLXWinContext *gc, HDC hdc, int bppOverride, int drawableTypeOverride)
+glxWinSetPixelFormat(__GLXWinContext * gc, HDC hdc, int bppOverride,
+                     int drawableTypeOverride)
 {
   __GLXscreen *screen = gc->base.pGlxScreen;
   glxWinScreen *winScreen = (glxWinScreen *)screen;
@@ -1021,18 +1017,20 @@ glxWinSetPixelFormat(__GLXWinContext *gc, HDC hdc, int bppOverride, int drawable
   __GLXconfig *config = gc->base.config;
   GLXWinConfig *winConfig = (GLXWinConfig *)config;
 
-  GLWIN_DEBUG_MSG("glxWinSetPixelFormat: pixelFormatIndex %d", winConfig->pixelFormatIndex);
+    GLWIN_DEBUG_MSG("glxWinSetPixelFormat: pixelFormatIndex %d",
+                    winConfig->pixelFormatIndex);
 
   /*
     Normally, we can just use the the pixelFormatIndex corresponding
     to the fbconfig which has been specified by the client
   */
 
-  if (!((bppOverride && (bppOverride != (config->redBits + config->greenBits + config->blueBits) ))
-        || ((config->drawableType & drawableTypeOverride) == 0)))
-    {
-      if (!SetPixelFormat(hdc, winConfig->pixelFormatIndex, NULL))
-        {
+    if (!
+        ((bppOverride &&
+          (bppOverride !=
+           (config->redBits + config->greenBits + config->blueBits)))
+         || ((config->drawableType & drawableTypeOverride) == 0))) {
+        if (!SetPixelFormat(hdc, winConfig->pixelFormatIndex, NULL)) {
           ErrorF("SetPixelFormat error: %s\n", glxWinErrorMessage());
           return FALSE;
         }
@@ -1057,17 +1055,17 @@ glxWinSetPixelFormat(__GLXWinContext *gc, HDC hdc, int bppOverride, int drawable
        on (drawableTypeOverride) isn't supported by the selected fbConfig, reconsider
        and see if we can find a suitable one...
    */
-  ErrorF("glxWinSetPixelFormat: having second thoughts: cColorbits %d, bppOveride %d; config->drawableType %d, drawableTypeOverride %d\n",
-         (config->redBits + config->greenBits + config->blueBits), bppOverride, config->drawableType, drawableTypeOverride);
+    ErrorF
+        ("glxWinSetPixelFormat: having second thoughts: cColorbits %d, bppOveride %d; config->drawableType %d, drawableTypeOverride %d\n",
+         (config->redBits + config->greenBits + config->blueBits), bppOverride,
+         config->drawableType, drawableTypeOverride);
 
-  if (!winScreen->has_WGL_ARB_pixel_format)
-    {
+    if (!winScreen->has_WGL_ARB_pixel_format) {
       PIXELFORMATDESCRIPTOR pfd;
       int pixelFormat;
 
       /* convert fbConfig to PFD */
-      if (fbConfigToPixelFormat(gc->base.config, &pfd, drawableTypeOverride))
-        {
+        if (fbConfigToPixelFormat(gc->base.config, &pfd, drawableTypeOverride)) {
           ErrorF("glxWinSetPixelFormat: fbConfigToPixelFormat failed\n");
           return FALSE;
         }
@@ -1075,42 +1073,45 @@ glxWinSetPixelFormat(__GLXWinContext *gc, HDC hdc, int bppOverride, int drawable
       if (glxWinDebugSettings.dumpPFD)
         pfdOut(&pfd);
 
-      if (bppOverride)
-        {
-          GLWIN_DEBUG_MSG("glxWinSetPixelFormat: Forcing bpp from %d to %d\n", pfd.cColorBits, bppOverride);
+        if (bppOverride) {
+            GLWIN_DEBUG_MSG("glxWinSetPixelFormat: Forcing bpp from %d to %d\n",
+                            pfd.cColorBits, bppOverride);
           pfd.cColorBits = bppOverride;
         }
 
       pixelFormat = ChoosePixelFormat(hdc, &pfd);
-      if (pixelFormat == 0)
-        {
+        if (pixelFormat == 0) {
           ErrorF("ChoosePixelFormat error: %s\n", glxWinErrorMessage());
           return FALSE;
         }
 
-      GLWIN_DEBUG_MSG("ChoosePixelFormat: chose pixelFormatIndex %d", pixelFormat);
-      ErrorF("ChoosePixelFormat: chose pixelFormatIndex %d (rather than %d as originally planned)\n", pixelFormat, winConfig->pixelFormatIndex);
+        GLWIN_DEBUG_MSG("ChoosePixelFormat: chose pixelFormatIndex %d",
+                        pixelFormat);
+        ErrorF
+            ("ChoosePixelFormat: chose pixelFormatIndex %d (rather than %d as originally planned)\n",
+             pixelFormat, winConfig->pixelFormatIndex);
 
-      if (!SetPixelFormat(hdc, pixelFormat, &pfd))
-        {
+        if (!SetPixelFormat(hdc, pixelFormat, &pfd)) {
           ErrorF("SetPixelFormat error: %s\n", glxWinErrorMessage());
           return FALSE;
         }
     }
-  else
-    {
-      int pixelFormat = fbConfigToPixelFormatIndex(hdc, gc->base.config, drawableTypeOverride, winScreen);
-      if (pixelFormat == 0)
-        {
+    else {
+        int pixelFormat =
+            fbConfigToPixelFormatIndex(hdc, gc->base.config,
+                                       drawableTypeOverride, winScreen);
+        if (pixelFormat == 0) {
           ErrorF("wglChoosePixelFormat error: %s\n", glxWinErrorMessage());
           return FALSE;
         }
 
-      GLWIN_DEBUG_MSG("wglChoosePixelFormat: chose pixelFormatIndex %d", pixelFormat);
-      ErrorF("wglChoosePixelFormat: chose pixelFormatIndex %d (rather than %d as originally planned)\n", pixelFormat, winConfig->pixelFormatIndex);
+        GLWIN_DEBUG_MSG("wglChoosePixelFormat: chose pixelFormatIndex %d",
+                        pixelFormat);
+        ErrorF
+            ("wglChoosePixelFormat: chose pixelFormatIndex %d (rather than %d as originally planned)\n",
+             pixelFormat, winConfig->pixelFormatIndex);
 
-      if (!SetPixelFormat(hdc, pixelFormat, NULL))
-        {
+        if (!SetPixelFormat(hdc, pixelFormat, NULL)) {
           ErrorF("SetPixelFormat error: %s\n", glxWinErrorMessage());
           return FALSE;
         }
@@ -1120,34 +1121,32 @@ glxWinSetPixelFormat(__GLXWinContext *gc, HDC hdc, int bppOverride, int drawable
 }
 
 static HDC
-glxWinMakeDC(__GLXWinContext *gc, __GLXWinDrawable *draw, HDC *hdc, HWND *hwnd)
+glxWinMakeDC(__GLXWinContext * gc, __GLXWinDrawable * draw, HDC * hdc,
+             HWND * hwnd)
 {
   *hdc = NULL;
   *hwnd = NULL;
 
-  if (draw == NULL)
-    {
-      GLWIN_TRACE_MSG("No drawable for context %p (native ctx %p)", gc, gc->ctx);
+    if (draw == NULL) {
+        GLWIN_TRACE_MSG("No drawable for context %p (native ctx %p)", gc,
+                        gc->ctx);
       return NULL;
     }
 
-  switch (draw->base.type)
-  {
+    switch (draw->base.type) {
     case GLX_DRAWABLE_WINDOW:
     {
       WindowPtr pWin;
 
       pWin = (WindowPtr) draw->base.pDraw;
-      if (pWin == NULL)
-        {
+        if (pWin == NULL) {
           GLWIN_TRACE_MSG("for drawable %p, no WindowPtr", pWin);
           return NULL;
         }
 
       *hwnd = winGetWindowInfo(pWin);
 
-      if (*hwnd == NULL)
-        {
+        if (*hwnd == NULL) {
           ErrorF("No HWND error: %s\n", glxWinErrorMessage());
           return NULL;
         }
@@ -1158,18 +1157,19 @@ glxWinMakeDC(__GLXWinContext *gc, __GLXWinDrawable *draw, HDC *hdc, HWND *hwnd)
         ErrorF("GetDC error: %s\n", glxWinErrorMessage());
 
       /* Check if the hwnd has changed... */
-      if (*hwnd != gc->hwnd)
-        {
+        if (*hwnd != gc->hwnd) {
           if (glxWinDebugSettings.enableTrace)
             GLWIN_DEBUG_HWND(*hwnd);
 
-          GLWIN_TRACE_MSG("for context %p (native ctx %p), hWnd changed from %p to %p", gc, gc->ctx, gc->hwnd, *hwnd);
+            GLWIN_TRACE_MSG
+                ("for context %p (native ctx %p), hWnd changed from %p to %p",
+                 gc, gc->ctx, gc->hwnd, *hwnd);
           gc->hwnd = *hwnd;
 
           /* We must select a pixelformat, but SetPixelFormat can only be called once for a window... */
-          if (!glxWinSetPixelFormat(gc, *hdc, 0, GLX_WINDOW_BIT))
-            {
-              ErrorF("glxWinSetPixelFormat error: %s\n", glxWinErrorMessage());
+            if (!glxWinSetPixelFormat(gc, *hdc, 0, GLX_WINDOW_BIT)) {
+                ErrorF("glxWinSetPixelFormat error: %s\n",
+                       glxWinErrorMessage());
               ReleaseDC(*hwnd, *hdc);
               *hdc = NULL;
               return NULL;
@@ -1195,7 +1195,8 @@ glxWinMakeDC(__GLXWinContext *gc, __GLXWinDrawable *draw, HDC *hdc, HWND *hwnd)
 
   default:
     {
-      ErrorF("glxWinMakeDC: tried to makeDC for unhandled drawable type %d\n", draw->base.type);
+        ErrorF("glxWinMakeDC: tried to makeDC for unhandled drawable type %d\n",
+               draw->base.type);
     }
   }
 
@@ -1208,8 +1209,7 @@ glxWinMakeDC(__GLXWinContext *gc, __GLXWinDrawable *draw, HDC *hdc, HWND *hwnd)
 static void
 glxWinReleaseDC(HWND hwnd, HDC hdc,__GLXWinDrawable *draw)
 {
-  switch (draw->base.type)
-  {
+    switch (draw->base.type) {
     case GLX_DRAWABLE_WINDOW:
     {
       ReleaseDC(hwnd, hdc);
@@ -1218,8 +1218,7 @@ glxWinReleaseDC(HWND hwnd, HDC hdc,__GLXWinDrawable *draw)
 
   case GLX_DRAWABLE_PBUFFER:
     {
-      if (!wglReleasePbufferDCARBWrapper(draw->hPbuffer, hdc))
-        {
+        if (!wglReleasePbufferDCARBWrapper(draw->hPbuffer, hdc)) {
           ErrorF("wglReleasePbufferDCARB error: %s\n", glxWinErrorMessage());
         }
     }
@@ -1237,7 +1236,9 @@ glxWinReleaseDC(HWND hwnd, HDC hdc,__GLXWinDrawable *draw)
 
   default:
     {
-      ErrorF("glxWinReleaseDC: tried to releaseDC for unhandled drawable type %d\n", draw->base.type);
+        ErrorF
+            ("glxWinReleaseDC: tried to releaseDC for unhandled drawable type %d\n",
+             draw->base.type);
     }
   }
 }
@@ -1247,29 +1248,29 @@ glxWinDeferredCreateContext(__GLXWinContext *gc, __GLXWinDrawable *draw)
 {
   HDC dc;
   HWND hwnd;
-  GLWIN_DEBUG_MSG("glxWinDeferredCreateContext: attach context %p to drawable %p", gc, draw);
 
-  switch (draw->base.type)
-  {
+    GLWIN_DEBUG_MSG
+        ("glxWinDeferredCreateContext: attach context %p to drawable %p", gc,
+         draw);
+
+    switch (draw->base.type) {
     case GLX_DRAWABLE_WINDOW:
     {
       WindowPtr pWin = (WindowPtr) draw->base.pDraw;
 
-      if (!(gc->base.config->drawableType & GLX_WINDOW_BIT))
-        {
-          ErrorF("glxWinDeferredCreateContext: tried to attach a context whose fbConfig doesn't have drawableType GLX_WINDOW_BIT to a GLX_DRAWABLE_WINDOW drawable\n");
+        if (!(gc->base.config->drawableType & GLX_WINDOW_BIT)) {
+            ErrorF
+                ("glxWinDeferredCreateContext: tried to attach a context whose fbConfig doesn't have drawableType GLX_WINDOW_BIT to a GLX_DRAWABLE_WINDOW drawable\n");
         }
 
-      if (pWin == NULL)
-        {
+        if (pWin == NULL) {
           GLWIN_DEBUG_MSG("Deferring until X window is created");
           return;
         }
 
       GLWIN_DEBUG_MSG("glxWinDeferredCreateContext: pWin %p", pWin);
 
-      if (winGetWindowInfo(pWin) == NULL)
-        {
+        if (winGetWindowInfo(pWin) == NULL) {
           GLWIN_DEBUG_MSG("Deferring until native window is created");
           return;
         }
@@ -1278,47 +1279,53 @@ glxWinDeferredCreateContext(__GLXWinContext *gc, __GLXWinDrawable *draw)
 
     case GLX_DRAWABLE_PBUFFER:
     {
-      if (draw->hPbuffer == NULL)
-        {
+        if (draw->hPbuffer == NULL) {
           __GLXscreen *screen;
           glxWinScreen *winScreen;
           int pixelFormat;
+
           // XXX: which DC are supposed to use???
           HDC screenDC = GetDC(NULL);
 
-          if (!(gc->base.config->drawableType & GLX_PBUFFER_BIT))
-            {
-              ErrorF("glxWinDeferredCreateContext: tried to attach a context whose fbConfig doesn't have drawableType GLX_PBUFFER_BIT to a GLX_DRAWABLE_PBUFFER drawable\n");
+            if (!(gc->base.config->drawableType & GLX_PBUFFER_BIT)) {
+                ErrorF
+                    ("glxWinDeferredCreateContext: tried to attach a context whose fbConfig doesn't have drawableType GLX_PBUFFER_BIT to a GLX_DRAWABLE_PBUFFER drawable\n");
             }
 
           screen = gc->base.pGlxScreen;
           winScreen = (glxWinScreen *)screen;
 
-          pixelFormat = fbConfigToPixelFormatIndex(screenDC, gc->base.config, GLX_DRAWABLE_PBUFFER, winScreen);
-          if (pixelFormat == 0)
-            {
-              ErrorF("wglChoosePixelFormat error: %s\n", glxWinErrorMessage());
+            pixelFormat =
+                fbConfigToPixelFormatIndex(screenDC, gc->base.config,
+                                           GLX_DRAWABLE_PBUFFER, winScreen);
+            if (pixelFormat == 0) {
+                ErrorF("wglChoosePixelFormat error: %s\n",
+                       glxWinErrorMessage());
               return;
             }
 
-          draw->hPbuffer = wglCreatePbufferARBWrapper(screenDC, pixelFormat, draw->base.pDraw->width, draw->base.pDraw->height, NULL);
+            draw->hPbuffer =
+                wglCreatePbufferARBWrapper(screenDC, pixelFormat,
+                                           draw->base.pDraw->width,
+                                           draw->base.pDraw->height, NULL);
           ReleaseDC(NULL, screenDC);
 
-          if (draw->hPbuffer == NULL)
-            {
-              ErrorF("wglCreatePbufferARBWrapper error: %s\n", glxWinErrorMessage());
+            if (draw->hPbuffer == NULL) {
+                ErrorF("wglCreatePbufferARBWrapper error: %s\n",
+                       glxWinErrorMessage());
               return;
             }
 
-          GLWIN_DEBUG_MSG("glxWinDeferredCreateContext: pBuffer %p created for drawable %p", draw->hPbuffer, draw);
+            GLWIN_DEBUG_MSG
+                ("glxWinDeferredCreateContext: pBuffer %p created for drawable %p",
+                 draw->hPbuffer, draw);
         }
     }
     break;
 
     case GLX_DRAWABLE_PIXMAP:
     {
-      if (draw->dibDC == NULL)
-        {
+        if (draw->dibDC == NULL) {
           BITMAPINFOHEADER bmpHeader;
           void *pBits;
 
@@ -1330,21 +1337,21 @@ glxWinDeferredCreateContext(__GLXWinContext *gc, __GLXWinDrawable *draw)
           bmpHeader.biBitCount = draw->base.pDraw->bitsPerPixel;
           bmpHeader.biCompression = BI_RGB;
 
-          if (!(gc->base.config->drawableType & GLX_PIXMAP_BIT))
-            {
-              ErrorF("glxWinDeferredCreateContext: tried to attach a context whose fbConfig doesn't have drawableType GLX_PIXMAP_BIT to a GLX_DRAWABLE_PIXMAP drawable\n");
+            if (!(gc->base.config->drawableType & GLX_PIXMAP_BIT)) {
+                ErrorF
+                    ("glxWinDeferredCreateContext: tried to attach a context whose fbConfig doesn't have drawableType GLX_PIXMAP_BIT to a GLX_DRAWABLE_PIXMAP drawable\n");
             }
 
           draw->dibDC = CreateCompatibleDC(NULL);
-          if (draw->dibDC == NULL)
-            {
+            if (draw->dibDC == NULL) {
               ErrorF("CreateCompatibleDC error: %s\n", glxWinErrorMessage());
               return;
             }
 
-          draw->hDIB = CreateDIBSection(draw->dibDC, (BITMAPINFO *)&bmpHeader, DIB_RGB_COLORS, &pBits, 0, 0);
-          if (draw->dibDC == NULL)
-            {
+            draw->hDIB =
+                CreateDIBSection(draw->dibDC, (BITMAPINFO *) & bmpHeader,
+                                 DIB_RGB_COLORS, &pBits, 0, 0);
+            if (draw->dibDC == NULL) {
               ErrorF("CreateDIBSection error: %s\n", glxWinErrorMessage());
               return;
             }
@@ -1358,22 +1365,27 @@ glxWinDeferredCreateContext(__GLXWinContext *gc, __GLXWinDrawable *draw)
 
           // Select the DIB into the DC
           draw->hOldDIB = SelectObject(draw->dibDC, draw->hDIB);
-          if (!draw->hOldDIB)
-            {
+            if (!draw->hOldDIB) {
               ErrorF("SelectObject error: %s\n", glxWinErrorMessage());
             }
 
           // Set the pixel format of the bitmap
-          glxWinSetPixelFormat(gc, draw->dibDC, draw->base.pDraw->bitsPerPixel, GLX_PIXMAP_BIT);
+            glxWinSetPixelFormat(gc, draw->dibDC,
+                                 draw->base.pDraw->bitsPerPixel,
+                                 GLX_PIXMAP_BIT);
 
-          GLWIN_DEBUG_MSG("glxWinDeferredCreateContext: DIB bitmap %p created for drawable %p", draw->hDIB, draw);
+            GLWIN_DEBUG_MSG
+                ("glxWinDeferredCreateContext: DIB bitmap %p created for drawable %p",
+                 draw->hDIB, draw);
         }
     }
     break;
 
     default:
     {
-      ErrorF("glxWinDeferredCreateContext: tried to attach unhandled drawable type %d\n", draw->base.type);
+        ErrorF
+            ("glxWinDeferredCreateContext: tried to attach unhandled drawable type %d\n",
+             draw->base.type);
       return;
     }
   }
@@ -1382,21 +1394,22 @@ glxWinDeferredCreateContext(__GLXWinContext *gc, __GLXWinDrawable *draw)
   gc->ctx = wglCreateContext(dc);
   glxWinReleaseDC(hwnd, dc, draw);
 
-  if (gc->ctx == NULL)
-    {
+    if (gc->ctx == NULL) {
       ErrorF("wglCreateContext error: %s\n", glxWinErrorMessage());
       return;
     }
 
-  GLWIN_DEBUG_MSG("glxWinDeferredCreateContext: attached context %p to native context %p drawable %p", gc, gc->ctx, draw);
+    GLWIN_DEBUG_MSG
+        ("glxWinDeferredCreateContext: attached context %p to native context %p drawable %p",
+         gc, gc->ctx, draw);
 
   // if the native context was created successfully, shareLists if needed
-  if (gc->ctx && gc->shareContext)
-    {
-      GLWIN_DEBUG_MSG("glxWinCreateContextReal shareLists with context %p (native ctx %p)", gc->shareContext, gc->shareContext->ctx);
+    if (gc->ctx && gc->shareContext) {
+        GLWIN_DEBUG_MSG
+            ("glxWinCreateContextReal shareLists with context %p (native ctx %p)",
+             gc->shareContext, gc->shareContext->ctx);
 
-      if (!wglShareLists(gc->shareContext->ctx, gc->ctx))
-        {
+        if (!wglShareLists(gc->shareContext->ctx, gc->ctx)) {
           ErrorF("wglShareLists error: %s\n", glxWinErrorMessage());
         }
     }
@@ -1407,7 +1420,6 @@ glxWinDeferredCreateContext(__GLXWinContext *gc, __GLXWinDrawable *draw)
  * Context functions
  */
 
-
 /* Context manipulation routines should return TRUE on success, FALSE on failure */
 static int
 glxWinContextMakeCurrent(__GLXcontext *base)
@@ -1421,33 +1433,31 @@ glxWinContextMakeCurrent(__GLXcontext *base)
   HWND hDrawWnd;
   HWND hReadWnd;
 
-  GLWIN_TRACE_MSG("glxWinContextMakeCurrent context %p (native ctx %p)", gc, gc->ctx);
+    GLWIN_TRACE_MSG("glxWinContextMakeCurrent context %p (native ctx %p)", gc,
+                    gc->ctx);
   glWinCallDelta();
 
   /* Keep a note of the last active context in the drawable */
   drawPriv = gc->base.drawPriv;
   ((__GLXWinDrawable *)drawPriv)->drawContext = gc;
 
-  if (gc->ctx == NULL)
-    {
+    if (gc->ctx == NULL) {
       glxWinDeferredCreateContext(gc, (__GLXWinDrawable *)drawPriv);
     }
 
-  if (gc->ctx == NULL)
-    {
+    if (gc->ctx == NULL) {
       ErrorF("glxWinContextMakeCurrent: Native context is NULL\n");
       return FALSE;
     }
 
-  drawDC = glxWinMakeDC(gc, (__GLXWinDrawable *)drawPriv, &drawDC, &hDrawWnd);
-  if (drawDC == NULL)
-    {
+    drawDC =
+        glxWinMakeDC(gc, (__GLXWinDrawable *) drawPriv, &drawDC, &hDrawWnd);
+    if (drawDC == NULL) {
       ErrorF("glxWinMakeDC failed for drawDC\n");
       return FALSE;
     }
 
-  if ((gc->base.readPriv != NULL) && (gc->base.readPriv != gc->base.drawPriv))
-    {
+    if ((gc->base.readPriv != NULL) && (gc->base.readPriv != gc->base.drawPriv)) {
       // XXX: should only occur with WGL_ARB_make_current_read
       /*
         If there is a separate read drawable, create a separate read DC, and
@@ -1455,26 +1465,24 @@ glxWinContextMakeCurrent(__GLXcontext *base)
         to one DC and reading from the other
       */
       readPriv = gc->base.readPriv;
-      readDC = glxWinMakeDC(gc, (__GLXWinDrawable *)readPriv, &readDC, &hReadWnd);
-      if (readDC == NULL)
-        {
+        readDC =
+            glxWinMakeDC(gc, (__GLXWinDrawable *) readPriv, &readDC, &hReadWnd);
+        if (readDC == NULL) {
           ErrorF("glxWinMakeDC failed for readDC\n");
           glxWinReleaseDC(hDrawWnd, drawDC, (__GLXWinDrawable *)drawPriv);
           return FALSE;
         }
 
       ret = wglMakeContextCurrentARBWrapper(drawDC, readDC, gc->ctx);
-      if (!ret)
-        {
-          ErrorF("wglMakeContextCurrentARBWrapper error: %s\n", glxWinErrorMessage());
+        if (!ret) {
+            ErrorF("wglMakeContextCurrentARBWrapper error: %s\n",
+                   glxWinErrorMessage());
         }
     }
-  else
-    {
+    else {
       /* Otherwise, just use wglMakeCurrent */
       ret = wglMakeCurrent(drawDC, gc->ctx);
-      if (!ret)
-        {
+        if (!ret) {
           ErrorF("wglMakeCurrent error: %s\n", glxWinErrorMessage());
         }
     }
@@ -1495,25 +1503,27 @@ glxWinContextLoseCurrent(__GLXcontext *base)
   BOOL ret;
   __GLXWinContext *gc = (__GLXWinContext *)base;
 
-  GLWIN_TRACE_MSG("glxWinContextLoseCurrent context %p (native ctx %p)", gc, gc->ctx);
+    GLWIN_TRACE_MSG("glxWinContextLoseCurrent context %p (native ctx %p)", gc,
+                    gc->ctx);
   glWinCallDelta();
 
   /*
      An error seems to be reported if we try to make no context current
      if there is already no current context, so avoid doing that...
   */
-  if (__glXLastContext != NULL)
-    {
+    if (__glXLastContext != NULL) {
       ret = wglMakeCurrent(NULL, NULL); /* We don't need a DC when setting no current context */
       if (!ret)
-        ErrorF("glxWinContextLoseCurrent error: %s\n", glxWinErrorMessage());
+            ErrorF("glxWinContextLoseCurrent error: %s\n",
+                   glxWinErrorMessage());
     }
 
   return TRUE;
 }
 
 static int
-glxWinContextCopy(__GLXcontext *dst_base, __GLXcontext *src_base, unsigned long mask)
+glxWinContextCopy(__GLXcontext * dst_base, __GLXcontext * src_base,
+                  unsigned long mask)
 {
   __GLXWinContext *dst = (__GLXWinContext *)dst_base;
   __GLXWinContext *src = (__GLXWinContext *)src_base;
@@ -1522,8 +1532,7 @@ glxWinContextCopy(__GLXcontext *dst_base, __GLXcontext *src_base, unsigned long
   GLWIN_DEBUG_MSG("glxWinContextCopy");
 
   ret = wglCopyContext(src->ctx, dst->ctx, mask);
-  if (!ret)
-    {
+    if (!ret) {
       ErrorF("wglCopyContext error: %s\n", glxWinErrorMessage());
     }
 
@@ -1535,22 +1544,22 @@ glxWinContextDestroy(__GLXcontext *base)
 {
   __GLXWinContext *gc = (__GLXWinContext *)base;
 
-  if (gc != NULL)
-    {
-      GLWIN_DEBUG_MSG("GLXcontext %p destroyed (native ctx %p)", base, gc->ctx);
+    if (gc != NULL) {
+        GLWIN_DEBUG_MSG("GLXcontext %p destroyed (native ctx %p)", base,
+                        gc->ctx);
 
-      if (gc->ctx)
-        {
+        if (gc->ctx) {
           /* It's bad style to delete the context while it's still current */
-          if (wglGetCurrentContext() == gc->ctx)
-            {
+            if (wglGetCurrentContext() == gc->ctx) {
               wglMakeCurrent(NULL, NULL);
             }
 
           {
             BOOL ret = wglDeleteContext(gc->ctx);
+
             if (!ret)
-              ErrorF("wglDeleteContext error: %s\n", glxWinErrorMessage());
+                    ErrorF("wglDeleteContext error: %s\n",
+                           glxWinErrorMessage());
           }
 
           gc->ctx = NULL;
@@ -1562,14 +1571,12 @@ glxWinContextDestroy(__GLXcontext *base)
 
 static __GLXcontext *
 glxWinCreateContext(__GLXscreen *screen,
-                   __GLXconfig *modes,
-                   __GLXcontext *baseShareContext)
+                    __GLXconfig * modes, __GLXcontext * baseShareContext)
 {
     __GLXWinContext *context;
     __GLXWinContext *shareContext = (__GLXWinContext *)baseShareContext;
 
-    static __GLXtextureFromPixmap glxWinTextureFromPixmap =
-      {
+    static __GLXtextureFromPixmap glxWinTextureFromPixmap = {
         glxWinBindTexImage,
         glxWinReleaseTexImage
       };
@@ -1605,7 +1612,8 @@ glxWinCreateContext(__GLXscreen *screen,
  */
 
 static int
-fbConfigToPixelFormat(__GLXconfig *mode, PIXELFORMATDESCRIPTOR *pfdret, int drawableTypeOverride)
+fbConfigToPixelFormat(__GLXconfig * mode, PIXELFORMATDESCRIPTOR * pfdret,
+                      int drawableTypeOverride)
 {
     PIXELFORMATDESCRIPTOR pfd = {
       sizeof(PIXELFORMATDESCRIPTOR),   /* size of this pfd */
@@ -1650,7 +1658,9 @@ fbConfigToPixelFormat(__GLXconfig *mode, PIXELFORMATDESCRIPTOR *pfdret, int draw
     pfd.cAlphaBits = mode->alphaBits;
     pfd.cAlphaShift = 0; /* FIXME */
 
-    pfd.cAccumBits = mode->accumRedBits + mode->accumGreenBits + mode->accumBlueBits + mode->accumAlphaBits;
+    pfd.cAccumBits =
+        mode->accumRedBits + mode->accumGreenBits + mode->accumBlueBits +
+        mode->accumAlphaBits;
     pfd.cAccumRedBits = mode->accumRedBits;
     pfd.cAccumGreenBits = mode->accumGreenBits;
     pfd.cAccumBlueBits = mode->accumBlueBits;
@@ -1671,7 +1681,8 @@ fbConfigToPixelFormat(__GLXconfig *mode, PIXELFORMATDESCRIPTOR *pfdret, int draw
 #define SET_ATTR_VALUE(attr, value) { attribList[i++] = attr; attribList[i++] = value; assert(i < NUM_ELEMENTS(attribList)); }
 
 static int
-fbConfigToPixelFormatIndex(HDC hdc, __GLXconfig *mode, int drawableTypeOverride, glxWinScreen *winScreen)
+fbConfigToPixelFormatIndex(HDC hdc, __GLXconfig * mode,
+                           int drawableTypeOverride, glxWinScreen * winScreen)
 {
   UINT numFormats;
   unsigned int i = 0;
@@ -1680,8 +1691,13 @@ fbConfigToPixelFormatIndex(HDC hdc, __GLXconfig *mode, int drawableTypeOverride,
   int attribList[60];
 
   SET_ATTR_VALUE(WGL_SUPPORT_OPENGL_ARB, TRUE);
-  SET_ATTR_VALUE(WGL_PIXEL_TYPE_ARB, (mode->visualType == GLX_TRUE_COLOR) ? WGL_TYPE_RGBA_ARB : WGL_TYPE_COLORINDEX_ARB);
-  SET_ATTR_VALUE(WGL_COLOR_BITS_ARB, (mode->visualType == GLX_TRUE_COLOR) ? mode->rgbBits : mode->indexBits);
+    SET_ATTR_VALUE(WGL_PIXEL_TYPE_ARB,
+                   (mode->visualType ==
+                    GLX_TRUE_COLOR) ? WGL_TYPE_RGBA_ARB :
+                   WGL_TYPE_COLORINDEX_ARB);
+    SET_ATTR_VALUE(WGL_COLOR_BITS_ARB,
+                   (mode->visualType ==
+                    GLX_TRUE_COLOR) ? mode->rgbBits : mode->indexBits);
   SET_ATTR_VALUE(WGL_RED_BITS_ARB, mode->redBits);
   SET_ATTR_VALUE(WGL_GREEN_BITS_ARB, mode->greenBits);
   SET_ATTR_VALUE(WGL_BLUE_BITS_ARB, mode->blueBits);
@@ -1717,8 +1733,7 @@ fbConfigToPixelFormatIndex(HDC hdc, __GLXconfig *mode, int drawableTypeOverride,
 
   // XXX: this is a horrible hacky heuristic, in fact this whole drawableTypeOverride thing is a bad idea
   // try to avoid asking for formats which don't exist (by not asking for all when adjusting the config to include the drawableTypeOverride)
-  if (drawableTypeOverride == GLX_WINDOW_BIT)
-    {
+    if (drawableTypeOverride == GLX_WINDOW_BIT) {
       if (mode->drawableType & GLX_PIXMAP_BIT)
         SET_ATTR_VALUE(WGL_DRAW_TO_BITMAP_ARB, TRUE);
 
@@ -1726,8 +1741,7 @@ fbConfigToPixelFormatIndex(HDC hdc, __GLXconfig *mode, int drawableTypeOverride,
         if (winScreen->has_WGL_ARB_pbuffer)
           SET_ATTR_VALUE(WGL_DRAW_TO_PBUFFER_ARB, TRUE);
     }
-  else
-    {
+    else {
       if (drawableTypeOverride & GLX_PIXMAP_BIT)
         SET_ATTR_VALUE(WGL_DRAW_TO_BITMAP_ARB, TRUE);
 
@@ -1742,15 +1756,15 @@ fbConfigToPixelFormatIndex(HDC hdc, __GLXconfig *mode, int drawableTypeOverride,
   {
     int pixelFormatIndex;
 
-    if (!wglChoosePixelFormatARBWrapper(hdc, attribList, NULL, 1, &pixelFormatIndex, &numFormats))
-      {
+        if (!wglChoosePixelFormatARBWrapper
+            (hdc, attribList, NULL, 1, &pixelFormatIndex, &numFormats)) {
         ErrorF("wglChoosePixelFormat error: %s\n", glxWinErrorMessage());
       }
-    else
-      {
-        if (numFormats > 0)
-          {
-            GLWIN_DEBUG_MSG("wglChoosePixelFormat: chose pixelFormatIndex %d)", pixelFormatIndex);
+        else {
+            if (numFormats > 0) {
+                GLWIN_DEBUG_MSG
+                    ("wglChoosePixelFormat: chose pixelFormatIndex %d)",
+                     pixelFormatIndex);
             return pixelFormatIndex;
           }
         else
@@ -1783,14 +1797,15 @@ glxWinCreateConfigs(HDC hdc, glxWinScreen *screen)
   screen->base.fbconfigs = NULL;
 
   // get the number of pixelformats
-  numConfigs = DescribePixelFormat(hdc, 1, sizeof(PIXELFORMATDESCRIPTOR), NULL);
-  GLWIN_DEBUG_MSG("DescribePixelFormat says %d possible pixel formats", numConfigs);
+    numConfigs =
+        DescribePixelFormat(hdc, 1, sizeof(PIXELFORMATDESCRIPTOR), NULL);
+    GLWIN_DEBUG_MSG("DescribePixelFormat says %d possible pixel formats",
+                    numConfigs);
 
   /* alloc */
   result = malloc(sizeof(GLXWinConfig) * numConfigs);
 
-  if (NULL == result)
-    {
+    if (NULL == result) {
       return;
     }
 
@@ -1798,32 +1813,35 @@ glxWinCreateConfigs(HDC hdc, glxWinScreen *screen)
   n = 0;
 
   /* fill in configs */
-  for (i = 0;  i < numConfigs; i++)
-    {
+    for (i = 0; i < numConfigs; i++) {
       int rc;
 
       c = &(result[i]);
       c->base.next = NULL;
       c->pixelFormatIndex = i+1;
 
-      rc = DescribePixelFormat(hdc, i+1, sizeof(PIXELFORMATDESCRIPTOR), &pfd);
+        rc = DescribePixelFormat(hdc, i + 1, sizeof(PIXELFORMATDESCRIPTOR),
+                                 &pfd);
 
-      if (!rc)
-        {
-          ErrorF("DescribePixelFormat failed for index %d, error %s\n", i+1, glxWinErrorMessage());
+        if (!rc) {
+            ErrorF("DescribePixelFormat failed for index %d, error %s\n", i + 1,
+                   glxWinErrorMessage());
           break;
         }
 
       if (glxWinDebugSettings.dumpPFD)
         pfdOut(&pfd);
 
-      if (!(pfd.dwFlags & (PFD_DRAW_TO_WINDOW | PFD_DRAW_TO_BITMAP)) || !(pfd.dwFlags & PFD_SUPPORT_OPENGL))
-        {
-          GLWIN_DEBUG_MSG("pixelFormat %d has unsuitable flags 0x%08lx, skipping", i+1, pfd.dwFlags);
+        if (!(pfd.dwFlags & (PFD_DRAW_TO_WINDOW | PFD_DRAW_TO_BITMAP)) ||
+            !(pfd.dwFlags & PFD_SUPPORT_OPENGL)) {
+            GLWIN_DEBUG_MSG
+                ("pixelFormat %d has unsuitable flags 0x%08lx, skipping", i + 1,
+                 pfd.dwFlags);
           continue;
         }
 
-      c->base.doubleBufferMode = (pfd.dwFlags & PFD_DOUBLEBUFFER) ? GL_TRUE : GL_FALSE;
+        c->base.doubleBufferMode =
+            (pfd.dwFlags & PFD_DOUBLEBUFFER) ? GL_TRUE : GL_FALSE;
       c->base.stereoMode = (pfd.dwFlags & PFD_STEREO) ? GL_TRUE : GL_FALSE;
 
       c->base.redBits = pfd.cRedBits;
@@ -1832,18 +1850,19 @@ glxWinCreateConfigs(HDC hdc, glxWinScreen *screen)
       c->base.alphaBits = pfd.cAlphaBits;
 
       c->base.redMask = BITS_AND_SHIFT_TO_MASK(pfd.cRedBits, pfd.cRedShift);
-      c->base.greenMask =  BITS_AND_SHIFT_TO_MASK(pfd.cGreenBits, pfd.cGreenShift);
-      c->base.blueMask = BITS_AND_SHIFT_TO_MASK(pfd.cBlueBits, pfd.cBlueShift);
-      c->base.alphaMask = BITS_AND_SHIFT_TO_MASK(pfd.cAlphaBits, pfd.cAlphaShift);
+        c->base.greenMask =
+            BITS_AND_SHIFT_TO_MASK(pfd.cGreenBits, pfd.cGreenShift);
+        c->base.blueMask =
+            BITS_AND_SHIFT_TO_MASK(pfd.cBlueBits, pfd.cBlueShift);
+        c->base.alphaMask =
+            BITS_AND_SHIFT_TO_MASK(pfd.cAlphaBits, pfd.cAlphaShift);
 
       c->base.rgbBits = pfd.cColorBits;
 
-      if (pfd.iPixelType == PFD_TYPE_COLORINDEX)
-        {
+        if (pfd.iPixelType == PFD_TYPE_COLORINDEX) {
           c->base.indexBits = pfd.cColorBits;
         }
-      else
-        {
+        else {
           c->base.indexBits = 0;
         }
 
@@ -1866,29 +1885,25 @@ glxWinCreateConfigs(HDC hdc, glxWinScreen *screen)
       c->base.visualID = -1;  // will be set by __glXScreenInit()
 
       /* EXT_visual_rating / GLX 1.2 */
-      if (pfd.dwFlags & PFD_GENERIC_FORMAT)
-        {
+        if (pfd.dwFlags & PFD_GENERIC_FORMAT) {
           c->base.visualRating = GLX_SLOW_VISUAL_EXT;
         }
-      else
-        {
+        else {
           // PFD_GENERIC_ACCELERATED is not considered, so this may be MCD or ICD acclerated...
           c->base.visualRating = GLX_NONE_EXT;
         }
 
       /* EXT_visual_info / GLX 1.2 */
-      if (pfd.iPixelType == PFD_TYPE_COLORINDEX)
-        {
+        if (pfd.iPixelType == PFD_TYPE_COLORINDEX) {
           c->base.visualType = GLX_STATIC_COLOR;
 
-          if (!getenv("GLWIN_ENABLE_COLORINDEX_FBCONFIGS"))
-            {
-              GLWIN_DEBUG_MSG("pixelFormat %d is PFD_TYPE_COLORINDEX, skipping", i+1);
+            if (!getenv("GLWIN_ENABLE_COLORINDEX_FBCONFIGS")) {
+                GLWIN_DEBUG_MSG
+                    ("pixelFormat %d is PFD_TYPE_COLORINDEX, skipping", i + 1);
               continue;
             }
         }
-      else
-        {
+        else {
           c->base.visualType = GLX_TRUE_COLOR;
         }
 
@@ -1905,15 +1920,14 @@ glxWinCreateConfigs(HDC hdc, glxWinScreen *screen)
       c->base.samples = 0;
 
       /* SGIX_fbconfig / GLX 1.3 */
-      c->base.drawableType = (((pfd.dwFlags & PFD_DRAW_TO_WINDOW) ? GLX_WINDOW_BIT : 0)
+        c->base.drawableType =
+            (((pfd.dwFlags & PFD_DRAW_TO_WINDOW) ? GLX_WINDOW_BIT : 0)
                          | ((pfd.dwFlags & PFD_DRAW_TO_BITMAP) ? GLX_PIXMAP_BIT : 0));
 
-      if (pfd.iPixelType == PFD_TYPE_COLORINDEX)
-        {
+        if (pfd.iPixelType == PFD_TYPE_COLORINDEX) {
           c->base.renderType = GLX_RGBA_BIT | GLX_COLOR_INDEX_BIT;
         }
-      else
-        {
+        else {
           c->base.renderType = GLX_RGBA_BIT;
         }
 
@@ -1930,8 +1944,7 @@ glxWinCreateConfigs(HDC hdc, glxWinScreen *screen)
 
       /* SGIX_visual_select_group */
       // arrange for visuals with the best acceleration to be preferred in selection
-      switch (pfd.dwFlags & (PFD_GENERIC_FORMAT | PFD_GENERIC_ACCELERATED))
-        {
+        switch (pfd.dwFlags & (PFD_GENERIC_FORMAT | PFD_GENERIC_ACCELERATED)) {
         case 0:
           c->base.visualSelectGroup = 2;
           break;
@@ -1976,7 +1989,8 @@ glxWinCreateConfigs(HDC hdc, glxWinScreen *screen)
       prev = c;
     }
 
-  GLWIN_DEBUG_MSG("found %d pixelFormats suitable for conversion to fbConfigs", n);
+    GLWIN_DEBUG_MSG
+        ("found %d pixelFormats suitable for conversion to fbConfigs", n);
 
   screen->base.numFBConfigs = n;
   screen->base.fbconfigs = &(result->base);
@@ -1984,19 +1998,22 @@ glxWinCreateConfigs(HDC hdc, glxWinScreen *screen)
 
 // helper function to access an attribute value from an attribute value array by attribute
 static
-int getAttrValue(const int attrs[], int values[], unsigned int num, int attr, int fallback)
+    int
+getAttrValue(const int attrs[], int values[], unsigned int num, int attr,
+             int fallback)
 {
   unsigned int i;
-  for (i = 0; i < num; i++)
-    {
-      if (attrs[i] == attr)
-        {
-          GLWIN_TRACE_MSG("getAttrValue attr 0x%x, value %d", attr, values[i]);
+
+    for (i = 0; i < num; i++) {
+        if (attrs[i] == attr) {
+            GLWIN_TRACE_MSG("getAttrValue attr 0x%x, value %d", attr,
+                            values[i]);
           return values[i];
         }
     }
 
-  ErrorF("getAttrValue failed to find attr 0x%x, using default value %d\n", attr, fallback);
+    ErrorF("getAttrValue failed to find attr 0x%x, using default value %d\n",
+           attr, fallback);
   return fallback;
 }
 
@@ -2021,19 +2038,21 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
   screen->base.numFBConfigs = 0;
   screen->base.fbconfigs = NULL;
 
-  if (!wglGetPixelFormatAttribivARBWrapper(hdc, 0, 0, 1, &attr, &numConfigs))
-    {
-      ErrorF("wglGetPixelFormatAttribivARB failed for WGL_NUMBER_PIXEL_FORMATS_ARB: %s\n", glxWinErrorMessage());
+    if (!wglGetPixelFormatAttribivARBWrapper(hdc, 0, 0, 1, &attr, &numConfigs)) {
+        ErrorF
+            ("wglGetPixelFormatAttribivARB failed for WGL_NUMBER_PIXEL_FORMATS_ARB: %s\n",
+             glxWinErrorMessage());
       return;
     }
 
-  GLWIN_DEBUG_MSG("wglGetPixelFormatAttribivARB says %d possible pixel formats", numConfigs);
+    GLWIN_DEBUG_MSG
+        ("wglGetPixelFormatAttribivARB says %d possible pixel formats",
+         numConfigs);
 
   /* alloc */
   result = malloc(sizeof(GLXWinConfig) * numConfigs);
 
-  if (NULL == result)
-    {
+    if (NULL == result) {
       return;
     }
 
@@ -2075,22 +2094,19 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
   ADD_ATTR(WGL_AUX_BUFFERS_ARB);
   ADD_ATTR(WGL_SWAP_METHOD_ARB);
 
-  if (screen->has_WGL_ARB_multisample)
-    {
+    if (screen->has_WGL_ARB_multisample) {
       // we may not query these attrs if WGL_ARB_multisample is not offered
       ADD_ATTR(WGL_SAMPLE_BUFFERS_ARB);
       ADD_ATTR(WGL_SAMPLES_ARB);
     }
 
-  if (screen->has_WGL_ARB_render_texture)
-    {
+    if (screen->has_WGL_ARB_render_texture) {
       // we may not query these attrs if WGL_ARB_render_texture is not offered
       ADD_ATTR(WGL_BIND_TO_TEXTURE_RGB_ARB);
       ADD_ATTR(WGL_BIND_TO_TEXTURE_RGBA_ARB);
     }
 
-  if (screen->has_WGL_ARB_pbuffer)
-    {
+    if (screen->has_WGL_ARB_pbuffer) {
       // we may not query these attrs if WGL_ARB_pbuffer is not offered
       ADD_ATTR(WGL_DRAW_TO_PBUFFER_ARB);
       ADD_ATTR(WGL_MAX_PBUFFER_PIXELS_ARB);
@@ -2099,29 +2115,32 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
     }
 
   /* fill in configs */
-  for (i = 0;  i < numConfigs; i++)
-    {
+    for (i = 0; i < numConfigs; i++) {
       int values[num_attrs];
 
       c = &(result[i]);
       c->base.next = NULL;
       c->pixelFormatIndex = i+1;
 
-      if (!wglGetPixelFormatAttribivARBWrapper(hdc, i+1, 0, num_attrs, attrs, values))
-        {
-          ErrorF("wglGetPixelFormatAttribivARB failed for index %d, error %s\n", i+1, glxWinErrorMessage());
+        if (!wglGetPixelFormatAttribivARBWrapper
+            (hdc, i + 1, 0, num_attrs, attrs, values)) {
+            ErrorF
+                ("wglGetPixelFormatAttribivARB failed for index %d, error %s\n",
+                 i + 1, glxWinErrorMessage());
           break;
         }
 
 #define ATTR_VALUE(a, d) getAttrValue(attrs, values, num_attrs, (a), (d))
 
-      if (!ATTR_VALUE(WGL_SUPPORT_OPENGL_ARB, 0))
-        {
-          GLWIN_DEBUG_MSG("pixelFormat %d isn't WGL_SUPPORT_OPENGL_ARB, skipping", i+1);
+        if (!ATTR_VALUE(WGL_SUPPORT_OPENGL_ARB, 0)) {
+            GLWIN_DEBUG_MSG
+                ("pixelFormat %d isn't WGL_SUPPORT_OPENGL_ARB, skipping",
+                 i + 1);
           continue;
         }
 
-      c->base.doubleBufferMode = ATTR_VALUE(WGL_DOUBLE_BUFFER_ARB, 0) ? GL_TRUE : GL_FALSE;
+        c->base.doubleBufferMode =
+            ATTR_VALUE(WGL_DOUBLE_BUFFER_ARB, 0) ? GL_TRUE : GL_FALSE;
       c->base.stereoMode = ATTR_VALUE(WGL_STEREO_ARB, 0) ? GL_TRUE : GL_FALSE;
 
       c->base.redBits = ATTR_VALUE(WGL_RED_BITS_ARB, 0);
@@ -2129,32 +2148,43 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
       c->base.blueBits = ATTR_VALUE(WGL_BLUE_BITS_ARB, 0);
       c->base.alphaBits = ATTR_VALUE(WGL_ALPHA_BITS_ARB, 0);
 
-      c->base.redMask = BITS_AND_SHIFT_TO_MASK(c->base.redBits, ATTR_VALUE(WGL_RED_SHIFT_ARB, 0));
-      c->base.greenMask = BITS_AND_SHIFT_TO_MASK(c->base.greenBits, ATTR_VALUE(WGL_GREEN_SHIFT_ARB, 0));
-      c->base.blueMask = BITS_AND_SHIFT_TO_MASK(c->base.blueBits, ATTR_VALUE(WGL_BLUE_SHIFT_ARB, 0));
-      c->base.alphaMask = BITS_AND_SHIFT_TO_MASK(c->base.alphaBits, ATTR_VALUE(WGL_ALPHA_SHIFT_ARB, 0));
-
-      switch (ATTR_VALUE(WGL_PIXEL_TYPE_ARB, 0))
-        {
+        c->base.redMask =
+            BITS_AND_SHIFT_TO_MASK(c->base.redBits,
+                                   ATTR_VALUE(WGL_RED_SHIFT_ARB, 0));
+        c->base.greenMask =
+            BITS_AND_SHIFT_TO_MASK(c->base.greenBits,
+                                   ATTR_VALUE(WGL_GREEN_SHIFT_ARB, 0));
+        c->base.blueMask =
+            BITS_AND_SHIFT_TO_MASK(c->base.blueBits,
+                                   ATTR_VALUE(WGL_BLUE_SHIFT_ARB, 0));
+        c->base.alphaMask =
+            BITS_AND_SHIFT_TO_MASK(c->base.alphaBits,
+                                   ATTR_VALUE(WGL_ALPHA_SHIFT_ARB, 0));
+
+        switch (ATTR_VALUE(WGL_PIXEL_TYPE_ARB, 0)) {
         case WGL_TYPE_COLORINDEX_ARB:
           c->base.indexBits = ATTR_VALUE(WGL_COLOR_BITS_ARB, 0);
           c->base.rgbBits = 0;
           c->base.visualType = GLX_STATIC_COLOR;
 
-          if (!getenv("GLWIN_ENABLE_COLORINDEX_FBCONFIGS"))
-            {
-              GLWIN_DEBUG_MSG("pixelFormat %d is WGL_TYPE_COLORINDEX_ARB, skipping", i+1);
+            if (!getenv("GLWIN_ENABLE_COLORINDEX_FBCONFIGS")) {
+                GLWIN_DEBUG_MSG
+                    ("pixelFormat %d is WGL_TYPE_COLORINDEX_ARB, skipping",
+                     i + 1);
               continue;
             }
 
           break;
 
         case WGL_TYPE_RGBA_FLOAT_ARB:
-          GLWIN_DEBUG_MSG("pixelFormat %d is WGL_TYPE_RGBA_FLOAT_ARB, skipping", i+1);
+            GLWIN_DEBUG_MSG
+                ("pixelFormat %d is WGL_TYPE_RGBA_FLOAT_ARB, skipping", i + 1);
           continue;
 
         case WGL_TYPE_RGBA_UNSIGNED_FLOAT_EXT:
-          GLWIN_DEBUG_MSG("pixelFormat %d is WGL_TYPE_RGBA_UNSIGNED_FLOAT_EXT, skipping", i+1);
+            GLWIN_DEBUG_MSG
+                ("pixelFormat %d is WGL_TYPE_RGBA_UNSIGNED_FLOAT_EXT, skipping",
+                 i + 1);
           continue;
 
         case WGL_TYPE_RGBA_ARB:
@@ -2164,7 +2194,9 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
           break;
 
         default:
-          ErrorF("wglGetPixelFormatAttribivARB returned unknown value 0x%x for WGL_PIXEL_TYPE_ARB\n", ATTR_VALUE(WGL_PIXEL_TYPE_ARB, 0));
+            ErrorF
+                ("wglGetPixelFormatAttribivARB returned unknown value 0x%x for WGL_PIXEL_TYPE_ARB\n",
+                 ATTR_VALUE(WGL_PIXEL_TYPE_ARB, 0));
           continue;
         }
 
@@ -2178,11 +2210,15 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
       c->base.numAuxBuffers = ATTR_VALUE(WGL_AUX_BUFFERS_ARB, 0);
 
       {
-        int layers = ATTR_VALUE(WGL_NUMBER_OVERLAYS_ARB,0) + ATTR_VALUE(WGL_NUMBER_UNDERLAYS_ARB, 0);
+            int layers =
+                ATTR_VALUE(WGL_NUMBER_OVERLAYS_ARB,
+                           0) + ATTR_VALUE(WGL_NUMBER_UNDERLAYS_ARB, 0);
 
-        if (layers > 0)
-          {
-            ErrorF("pixelFormat %d: has %d overlay, %d underlays which aren't currently handled", i, ATTR_VALUE(WGL_NUMBER_OVERLAYS_ARB,0), ATTR_VALUE(WGL_NUMBER_UNDERLAYS_ARB, 0));
+            if (layers > 0) {
+                ErrorF
+                    ("pixelFormat %d: has %d overlay, %d underlays which aren't currently handled",
+                     i, ATTR_VALUE(WGL_NUMBER_OVERLAYS_ARB, 0),
+                     ATTR_VALUE(WGL_NUMBER_UNDERLAYS_ARB, 0));
             // XXX: need to iterate over layers?
           }
       }
@@ -2192,10 +2228,11 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
       c->base.visualID = -1;  // will be set by __glXScreenInit()
 
       /* EXT_visual_rating / GLX 1.2 */
-      switch (ATTR_VALUE(WGL_ACCELERATION_ARB, 0))
-        {
+        switch (ATTR_VALUE(WGL_ACCELERATION_ARB, 0)) {
         default:
-          ErrorF("wglGetPixelFormatAttribivARB returned unknown value 0x%x for WGL_ACCELERATION_ARB\n", ATTR_VALUE(WGL_ACCELERATION_ARB, 0));
+            ErrorF
+                ("wglGetPixelFormatAttribivARB returned unknown value 0x%x for WGL_ACCELERATION_ARB\n",
+                 ATTR_VALUE(WGL_ACCELERATION_ARB, 0));
 
         case WGL_NO_ACCELERATION_ARB:
           c->base.visualRating = GLX_SLOW_VISUAL_EXT;
@@ -2209,17 +2246,23 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
 
       /* EXT_visual_info / GLX 1.2 */
       // c->base.visualType is set above
-      if (ATTR_VALUE(WGL_TRANSPARENT_ARB, 0))
-        {
-          c->base.transparentPixel = (c->base.visualType == GLX_TRUE_COLOR) ? GLX_TRANSPARENT_RGB_EXT : GLX_TRANSPARENT_INDEX_EXT;
-          c->base.transparentRed = ATTR_VALUE(WGL_TRANSPARENT_RED_VALUE_ARB, 0);
-          c->base.transparentGreen = ATTR_VALUE(WGL_TRANSPARENT_GREEN_VALUE_ARB, 0);
-          c->base.transparentBlue = ATTR_VALUE(WGL_TRANSPARENT_BLUE_VALUE_ARB, 0);
-          c->base.transparentAlpha = ATTR_VALUE(WGL_TRANSPARENT_ALPHA_VALUE_ARB, 0);
-          c->base.transparentIndex = ATTR_VALUE(WGL_TRANSPARENT_INDEX_VALUE_ARB, 0);
-        }
-      else
-        {
+        if (ATTR_VALUE(WGL_TRANSPARENT_ARB, 0)) {
+            c->base.transparentPixel =
+                (c->base.visualType ==
+                 GLX_TRUE_COLOR) ? GLX_TRANSPARENT_RGB_EXT :
+                GLX_TRANSPARENT_INDEX_EXT;
+            c->base.transparentRed =
+                ATTR_VALUE(WGL_TRANSPARENT_RED_VALUE_ARB, 0);
+            c->base.transparentGreen =
+                ATTR_VALUE(WGL_TRANSPARENT_GREEN_VALUE_ARB, 0);
+            c->base.transparentBlue =
+                ATTR_VALUE(WGL_TRANSPARENT_BLUE_VALUE_ARB, 0);
+            c->base.transparentAlpha =
+                ATTR_VALUE(WGL_TRANSPARENT_ALPHA_VALUE_ARB, 0);
+            c->base.transparentIndex =
+                ATTR_VALUE(WGL_TRANSPARENT_INDEX_VALUE_ARB, 0);
+        }
+        else {
           c->base.transparentPixel = GLX_NONE_EXT;
           c->base.transparentRed = GLX_NONE;
           c->base.transparentGreen = GLX_NONE;
@@ -2229,19 +2272,18 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
         }
 
       /* ARB_multisample / SGIS_multisample */
-      if (screen->has_WGL_ARB_multisample)
-        {
+        if (screen->has_WGL_ARB_multisample) {
           c->base.sampleBuffers = ATTR_VALUE(WGL_SAMPLE_BUFFERS_ARB, 0);
           c->base.samples = ATTR_VALUE(WGL_SAMPLES_ARB, 0);
         }
-      else
-        {
+        else {
           c->base.sampleBuffers = 0;
           c->base.samples = 0;
         }
 
       /* SGIX_fbconfig / GLX 1.3 */
-      c->base.drawableType = ((ATTR_VALUE(WGL_DRAW_TO_WINDOW_ARB, 0) ? GLX_WINDOW_BIT : 0)
+        c->base.drawableType =
+            ((ATTR_VALUE(WGL_DRAW_TO_WINDOW_ARB, 0) ? GLX_WINDOW_BIT : 0)
                          | (ATTR_VALUE(WGL_DRAW_TO_BITMAP_ARB, 0) ? GLX_PIXMAP_BIT : 0)
                          | (ATTR_VALUE(WGL_DRAW_TO_PBUFFER_ARB, 0) ? GLX_PBUFFER_BIT : 0));
 
@@ -2253,12 +2295,10 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
 
         Color index rendering is only supported on single-channel visuals
       */
-      if (c->base.visualType == GLX_STATIC_COLOR)
-        {
+        if (c->base.visualType == GLX_STATIC_COLOR) {
           c->base.renderType = GLX_RGBA_BIT | GLX_COLOR_INDEX_BIT;
         }
-      else
-        {
+        else {
           c->base.renderType = GLX_RGBA_BIT;
         }
 
@@ -2266,14 +2306,14 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
       c->base.fbconfigID = -1; // will be set by __glXScreenInit()
 
       /* SGIX_pbuffer / GLX 1.3 */
-      if (screen->has_WGL_ARB_pbuffer)
-        {
+        if (screen->has_WGL_ARB_pbuffer) {
           c->base.maxPbufferWidth = ATTR_VALUE(WGL_MAX_PBUFFER_WIDTH_ARB, -1);
-          c->base.maxPbufferHeight = ATTR_VALUE(WGL_MAX_PBUFFER_HEIGHT_ARB, -1);
-          c->base.maxPbufferPixels =  ATTR_VALUE(WGL_MAX_PBUFFER_PIXELS_ARB, -1);
+            c->base.maxPbufferHeight =
+                ATTR_VALUE(WGL_MAX_PBUFFER_HEIGHT_ARB, -1);
+            c->base.maxPbufferPixels =
+                ATTR_VALUE(WGL_MAX_PBUFFER_PIXELS_ARB, -1);
         }
-      else
-        {
+        else {
           c->base.maxPbufferWidth = -1;
           c->base.maxPbufferHeight = -1;
           c->base.maxPbufferPixels =  -1;
@@ -2283,8 +2323,7 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
 
       /* SGIX_visual_select_group */
       // arrange for visuals with the best acceleration to be preferred in selection
-      switch (ATTR_VALUE(WGL_ACCELERATION_ARB, 0))
-        {
+        switch (ATTR_VALUE(WGL_ACCELERATION_ARB, 0)) {
         case WGL_FULL_ACCELERATION_ARB:
           c->base.visualSelectGroup = 2;
           break;
@@ -2300,8 +2339,7 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
         }
 
       /* OML_swap_method */
-      switch (ATTR_VALUE(WGL_SWAP_METHOD_ARB, 0))
-        {
+        switch (ATTR_VALUE(WGL_SWAP_METHOD_ARB, 0)) {
         case WGL_SWAP_EXCHANGE_ARB:
           c->base.swapMethod = GLX_SWAP_EXCHANGE_OML;
           break;
@@ -2311,7 +2349,9 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
           break;
 
         default:
-          ErrorF("wglGetPixelFormatAttribivARB returned unknown value 0x%x for WGL_SWAP_METHOD_ARB\n", ATTR_VALUE(WGL_SWAP_METHOD_ARB, 0));
+            ErrorF
+                ("wglGetPixelFormatAttribivARB returned unknown value 0x%x for WGL_SWAP_METHOD_ARB\n",
+                 ATTR_VALUE(WGL_SWAP_METHOD_ARB, 0));
 
         case WGL_SWAP_UNDEFINED_ARB:
           c->base.swapMethod = GLX_SWAP_UNDEFINED_OML;
@@ -2326,18 +2366,20 @@ glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
          bindToTextureRgb/bindToTextureRgba to FALSE means that swrast can't find any fbConfigs to use,
          so setting these to 0, even if we know bindToTexture isn't available, isn't a good idea...
        */
-      if (screen->has_WGL_ARB_render_texture)
-        {
-          c->base.bindToTextureRgb = ATTR_VALUE(WGL_BIND_TO_TEXTURE_RGB_ARB, -1);
-          c->base.bindToTextureRgba = ATTR_VALUE(WGL_BIND_TO_TEXTURE_RGBA_ARB, -1);
+        if (screen->has_WGL_ARB_render_texture) {
+            c->base.bindToTextureRgb =
+                ATTR_VALUE(WGL_BIND_TO_TEXTURE_RGB_ARB, -1);
+            c->base.bindToTextureRgba =
+                ATTR_VALUE(WGL_BIND_TO_TEXTURE_RGBA_ARB, -1);
         }
-      else
-        {
+        else {
           c->base.bindToTextureRgb = -1;
           c->base.bindToTextureRgba = -1;
         }
       c->base.bindToMipmapTexture = -1;
-      c->base.bindToTextureTargets = GLX_TEXTURE_1D_BIT_EXT | GLX_TEXTURE_2D_BIT_EXT | GLX_TEXTURE_RECTANGLE_BIT_EXT;
+        c->base.bindToTextureTargets =
+            GLX_TEXTURE_1D_BIT_EXT | GLX_TEXTURE_2D_BIT_EXT |
+            GLX_TEXTURE_RECTANGLE_BIT_EXT;
       c->base.yInverted = -1;
 
       n++;
