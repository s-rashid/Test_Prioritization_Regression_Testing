diff --git a/hw/xfree86/exa/exa_accel.c b/hw/xfree86/exa/exa_accel.c
deleted file mode 100644
index cbecddc..0000000
--- a/hw/xfree86/exa/exa_accel.c
+++ /dev/null
@@ -1,789 +0,0 @@
-/*
- * Copyright © 2001 Keith Packard
- *
- * Partly based on code that is Copyright © The XFree86 Project Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and its
- * documentation for any purpose is hereby granted without fee, provided that
- * the above copyright notice appear in all copies and that both that
- * copyright notice and this permission notice appear in supporting
- * documentation, and that the name of Keith Packard not be used in
- * advertising or publicity pertaining to distribution of the software without
- * specific, written prior permission.  Keith Packard makes no
- * representations about the suitability of this software for any purpose.  It
- * is provided "as is" without express or implied warranty.
- *
- * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
- * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
- * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
- * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
- * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
- * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
- * PERFORMANCE OF THIS SOFTWARE.
- */
-
-#ifdef HAVE_CONFIG_H
-#include <xorg-config.h>
-#endif
-#include "exa_priv.h"
-#include <X11/fonts/fontstruct.h>
-#include "dixfontstr.h"
-#include "xf86str.h"
-#include "xf86.h"
-#include "exa.h"
-#include "cw.h"
-
-static void
-exaFillSpans(DrawablePtr pDrawable, GCPtr pGC, int n,
-	     DDXPointPtr ppt, int *pwidth, int fSorted)
-{
-    ScreenPtr	    pScreen = pDrawable->pScreen;
-    ExaScreenPriv (pScreen);
-    RegionPtr	    pClip = fbGetCompositeClip(pGC);
-    PixmapPtr	    pPixmap;
-    BoxPtr	    pextent, pbox;
-    int		    nbox;
-    int		    extentX1, extentX2, extentY1, extentY2;
-    int		    fullX1, fullX2, fullY1;
-    int		    partX1, partX2;
-    int		    off_x, off_y;
-
-
-    ScrnInfoPtr pScrn = XF86SCRNINFO(pScreen);
-    if (!pScrn->vtSema) {
-        ExaCheckFillSpans(pDrawable, pGC, n, ppt, pwidth, fSorted);
-        return;
-    }
-
-    if (pGC->fillStyle != FillSolid ||
-	pDrawable->width > pExaScr->info->card.maxX ||
-	pDrawable->height > pExaScr->info->card.maxY ||
-	!(pPixmap = exaGetOffscreenPixmap (pDrawable, &off_x, &off_y)) ||
-	!(*pExaScr->info->accel.PrepareSolid) (pPixmap,
-                                               pGC->alu,
-                                               pGC->planemask,
-                                               pGC->fgPixel))
-    {
-	ExaCheckFillSpans (pDrawable, pGC, n, ppt, pwidth, fSorted);
-	return;
-    }
-
-    pextent = REGION_EXTENTS(pGC->pScreen, pClip);
-    extentX1 = pextent->x1;
-    extentY1 = pextent->y1;
-    extentX2 = pextent->x2;
-    extentY2 = pextent->y2;
-    while (n--)
-    {
-	fullX1 = ppt->x;
-	fullY1 = ppt->y;
-	fullX2 = fullX1 + (int) *pwidth;
-	ppt++;
-	pwidth++;
-
-	if (fullY1 < extentY1 || extentY2 <= fullY1)
-	    continue;
-
-	if (fullX1 < extentX1)
-	    fullX1 = extentX1;
-
-	if (fullX2 > extentX2)
-	    fullX2 = extentX2;
-
-	if (fullX1 >= fullX2)
-	    continue;
-
-	nbox = REGION_NUM_RECTS (pClip);
-	if (nbox == 1)
-	{
-	    (*pExaScr->info->accel.Solid) (pPixmap,
-                                           fullX1 + off_x, fullY1 + off_y,
-                                           fullX2 + off_x, fullY1 + 1 + off_y);
-	}
-	else
-	{
-	    pbox = REGION_RECTS(pClip);
-	    while(nbox--)
-	    {
-		if (pbox->y1 <= fullY1 && fullY1 < pbox->y2)
-		{
-		    partX1 = pbox->x1;
-		    if (partX1 < fullX1)
-			partX1 = fullX1;
-		    partX2 = pbox->x2;
-		    if (partX2 > fullX2)
-			partX2 = fullX2;
-		    if (partX2 > partX1)
-			(*pExaScr->info->accel.Solid) (pPixmap,
-                                                       partX1 + off_x, fullY1 + off_y,
-                                                       partX2 + off_x, fullY1 + 1 + off_y);
-		}
-		pbox++;
-	    }
-	}
-    }
-    (*pExaScr->info->accel.DoneSolid) (pPixmap);
-    exaDrawableDirty (pDrawable);
-    exaMarkSync(pScreen);
-}
-
-void
-exaCopyNtoN (DrawablePtr    pSrcDrawable,
-	     DrawablePtr    pDstDrawable,
-	     GCPtr	    pGC,
-	     BoxPtr	    pbox,
-	     int	    nbox,
-	     int	    dx,
-	     int	    dy,
-	     Bool	    reverse,
-	     Bool	    upsidedown,
-	     Pixel	    bitplane,
-	     void	    *closure)
-{
-    ExaScreenPriv (pDstDrawable->pScreen);
-    PixmapPtr pSrcPixmap, pDstPixmap;
-    int	    src_off_x, src_off_y;
-    int	    dst_off_x, dst_off_y;
-
-    /* Respect maxX/maxY in a trivial way: don't set up drawing when we might
-     * violate the limits.  The proper solution would be a temporary pixmap
-     * adjusted so that the drawing happened within limits.
-     */
-    if (pSrcDrawable->width > pExaScr->info->card.maxX ||
-	pSrcDrawable->height > pExaScr->info->card.maxY ||
-	pDstDrawable->width > pExaScr->info->card.maxX ||
-	pDstDrawable->height > pExaScr->info->card.maxY)
-    {
-	exaDrawableUseMemory (pSrcDrawable);
-	exaDrawableUseMemory (pDstDrawable);
-	goto fallback;
-    }
-
-    /* If either drawable is already in framebuffer, try to get both of them
-     * there.  Otherwise, be happy with where they are.
-     */
-    if (exaDrawableIsOffscreen(pDstDrawable) ||
-	exaDrawableIsOffscreen(pSrcDrawable))
-    {
-	exaDrawableUseScreen (pSrcDrawable);
-	exaDrawableUseScreen (pDstDrawable);
-    } else {
-	exaDrawableUseMemory (pSrcDrawable);
-	exaDrawableUseMemory (pDstDrawable);
-    }
-
-    if ((pSrcPixmap = exaGetOffscreenPixmap (pSrcDrawable, &src_off_x, &src_off_y)) &&
-	(pDstPixmap = exaGetOffscreenPixmap (pDstDrawable, &dst_off_x, &dst_off_y)) &&
-	(*pExaScr->info->accel.PrepareCopy) (pSrcPixmap,
-                                             pDstPixmap,
-                                             dx,
-                                             dy,
-                                             pGC ? pGC->alu : GXcopy,
-                                             pGC ? pGC->planemask : FB_ALLONES))
-    {
-	while (nbox--)
-	{
-	    (*pExaScr->info->accel.Copy) (pDstPixmap,
-                                          pbox->x1 + dx + src_off_x,
-                                          pbox->y1 + dy + src_off_y,
-                                          pbox->x1 + dst_off_x, pbox->y1 + dst_off_y,
-                                          pbox->x2 - pbox->x1,
-                                          pbox->y2 - pbox->y1);
-	    pbox++;
-	}
-	(*pExaScr->info->accel.DoneCopy) (pDstPixmap);
-	exaMarkSync(pDstDrawable->pScreen);
-	exaDrawableDirty (pDstDrawable);
-	return;
-    }
-
-fallback:
-    EXA_FALLBACK(("from 0x%lx to 0x%lx\n", (long)pSrcDrawable,
-		  (long)pDstDrawable));
-    exaPrepareAccess (pDstDrawable, EXA_PREPARE_DEST);
-    exaPrepareAccess (pSrcDrawable, EXA_PREPARE_SRC);
-    fbCopyNtoN (pSrcDrawable, pDstDrawable, pGC,
-		pbox, nbox, dx, dy, reverse, upsidedown,
-		bitplane, closure);
-    exaFinishAccess (pSrcDrawable, EXA_PREPARE_SRC);
-    exaFinishAccess (pDstDrawable, EXA_PREPARE_DEST);
-}
-
-RegionPtr
-exaCopyArea(DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable, GCPtr pGC,
-	    int srcx, int srcy, int width, int height, int dstx, int dsty)
-{
-    ScrnInfoPtr pScrn = XF86SCRNINFO(pDstDrawable->pScreen);
-    if (!pScrn->vtSema) {
-        return  ExaCheckCopyArea(pSrcDrawable, pDstDrawable, pGC,
-                                 srcx, srcy, width, height, dstx, dsty);
-    }
-
-    return  fbDoCopy (pSrcDrawable, pDstDrawable, pGC,
-                      srcx, srcy, width, height,
-                      dstx, dsty, exaCopyNtoN, 0, NULL);
-}
-
-static void
-exaPolyFillRect(DrawablePtr pDrawable,
-		GCPtr	    pGC,
-		int	    nrect,
-		xRectangle  *prect)
-{
-    ExaScreenPriv (pDrawable->pScreen);
-    RegionPtr	    pClip = fbGetCompositeClip(pGC);
-    ScrnInfoPtr     pScrn = XF86SCRNINFO(pDrawable->pScreen);
-    PixmapPtr	    pPixmap;
-    register BoxPtr pbox;
-    BoxPtr	    pextent;
-    int		    extentX1, extentX2, extentY1, extentY2;
-    int		    fullX1, fullX2, fullY1, fullY2;
-    int		    partX1, partX2, partY1, partY2;
-    int		    xoff, yoff;
-    int		    xorg, yorg;
-    int		    n;
-
-    if (!pScrn->vtSema ||
-        pGC->fillStyle != FillSolid ||
-	pDrawable->width > pExaScr->info->card.maxX ||
-	pDrawable->height > pExaScr->info->card.maxY ||
-	!(pPixmap = exaGetOffscreenPixmap (pDrawable, &xoff, &yoff)) ||
-	!(*pExaScr->info->accel.PrepareSolid) (pPixmap,
-                                               pGC->alu,
-                                               pGC->planemask,
-                                               pGC->fgPixel))
-    {
-	ExaCheckPolyFillRect (pDrawable, pGC, nrect, prect);
-	return;
-    }
-
-    xorg = pDrawable->x;
-    yorg = pDrawable->y;
-
-    pextent = REGION_EXTENTS(pGC->pScreen, pClip);
-    extentX1 = pextent->x1;
-    extentY1 = pextent->y1;
-    extentX2 = pextent->x2;
-    extentY2 = pextent->y2;
-    while (nrect--)
-    {
-	fullX1 = prect->x + xorg;
-	fullY1 = prect->y + yorg;
-	fullX2 = fullX1 + (int) prect->width;
-	fullY2 = fullY1 + (int) prect->height;
-	prect++;
-
-	if (fullX1 < extentX1)
-	    fullX1 = extentX1;
-
-	if (fullY1 < extentY1)
-	    fullY1 = extentY1;
-
-	if (fullX2 > extentX2)
-	    fullX2 = extentX2;
-
-	if (fullY2 > extentY2)
-	    fullY2 = extentY2;
-
-	if ((fullX1 >= fullX2) || (fullY1 >= fullY2))
-	    continue;
-	n = REGION_NUM_RECTS (pClip);
-	if (n == 1)
-	{
-	    (*pExaScr->info->accel.Solid) (pPixmap,
-                                           fullX1 + xoff, fullY1 + yoff,
-                                           fullX2 + xoff, fullY2 + yoff);
-	}
-	else
-	{
-	    pbox = REGION_RECTS(pClip);
-	    /*
-	     * clip the rectangle to each box in the clip region
-	     * this is logically equivalent to calling Intersect()
-	     */
-	    while(n--)
-	    {
-		partX1 = pbox->x1;
-		if (partX1 < fullX1)
-		    partX1 = fullX1;
-		partY1 = pbox->y1;
-		if (partY1 < fullY1)
-		    partY1 = fullY1;
-		partX2 = pbox->x2;
-		if (partX2 > fullX2)
-		    partX2 = fullX2;
-		partY2 = pbox->y2;
-		if (partY2 > fullY2)
-		    partY2 = fullY2;
-
-		pbox++;
-
-		if (partX1 < partX2 && partY1 < partY2)
-		    (*pExaScr->info->accel.Solid) (pPixmap,
-                                                   partX1 + xoff, partY1 + yoff,
-                                                   partX2 + xoff, partY2 + yoff);
-	    }
-	}
-    }
-    (*pExaScr->info->accel.DoneSolid) (pPixmap);
-    exaDrawableDirty (pDrawable);
-    exaMarkSync(pDrawable->pScreen);
-}
-
-static void
-exaSolidBoxClipped (DrawablePtr	pDrawable,
-		    RegionPtr	pClip,
-		    FbBits	pm,
-		    FbBits	fg,
-		    int		x1,
-		    int		y1,
-		    int		x2,
-		    int		y2)
-{
-    ExaScreenPriv (pDrawable->pScreen);
-    ScrnInfoPtr pScrn = XF86SCRNINFO(pDrawable->pScreen);
-    PixmapPtr   pPixmap;
-    BoxPtr	pbox;
-    int		nbox;
-    int		xoff, yoff;
-    int		partX1, partX2, partY1, partY2;
-
-    if (!pScrn->vtSema ||
-	pDrawable->width > pExaScr->info->card.maxX ||
-	pDrawable->height > pExaScr->info->card.maxY ||
-        !(pPixmap = exaGetOffscreenPixmap (pDrawable, &xoff, &yoff)) ||
-	!(*pExaScr->info->accel.PrepareSolid) (pPixmap, GXcopy, pm, fg))
-    {
-	EXA_FALLBACK(("to 0x%lx\n", (long)pDrawable));
-	exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
-	fg = fbReplicatePixel (fg, pDrawable->bitsPerPixel);
-	fbSolidBoxClipped (pDrawable, pClip, x1, y1, x2, y2,
-			   fbAnd (GXcopy, fg, pm),
-			   fbXor (GXcopy, fg, pm));
-	exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
-	return;
-    }
-    for (nbox = REGION_NUM_RECTS(pClip), pbox = REGION_RECTS(pClip);
-	 nbox--;
-	 pbox++)
-    {
-	partX1 = pbox->x1;
-	if (partX1 < x1)
-	    partX1 = x1;
-
-	partX2 = pbox->x2;
-	if (partX2 > x2)
-	    partX2 = x2;
-
-	if (partX2 <= partX1)
-	    continue;
-
-	partY1 = pbox->y1;
-	if (partY1 < y1)
-	    partY1 = y1;
-
-	partY2 = pbox->y2;
-	if (partY2 > y2)
-	    partY2 = y2;
-
-	if (partY2 <= partY1)
-	    continue;
-
-	(*pExaScr->info->accel.Solid) (pPixmap,
-                                       partX1 + xoff, partY1 + yoff,
-                                       partX2 + xoff, partY2 + yoff);
-    }
-    (*pExaScr->info->accel.DoneSolid) (pPixmap);
-    exaDrawableDirty (pDrawable);
-    exaMarkSync(pDrawable->pScreen);
-}
-
-static void
-exaImageGlyphBlt (DrawablePtr	pDrawable,
-		  GCPtr		pGC,
-		  int		x,
-		  int		y,
-		  unsigned int	nglyph,
-		  CharInfoPtr	*ppciInit,
-		  pointer	pglyphBase)
-{
-    FbGCPrivPtr	    pPriv = fbGetGCPrivate(pGC);
-    CharInfoPtr	    *ppci;
-    CharInfoPtr	    pci;
-    unsigned char   *pglyph;		/* pointer bits in glyph */
-    int		    gWidth, gHeight;	/* width and height of glyph */
-    FbStride	    gStride;		/* stride of glyph */
-    Bool	    opaque;
-    int		    n;
-    int		    gx, gy;
-    void	    (*glyph) (FbBits *,
-			      FbStride,
-			      int,
-			      FbStip *,
-			      FbBits,
-			      int,
-			      int);
-    FbBits	    *dst;
-    FbStride	    dstStride;
-    int		    dstBpp;
-    int		    dstXoff, dstYoff;
-    FbBits	    depthMask;
-
-    depthMask = FbFullMask(pDrawable->depth);
-    if ((pGC->planemask & depthMask) != depthMask)
-    {
-	ExaCheckImageGlyphBlt(pDrawable, pGC, x, y, nglyph, ppciInit, pglyphBase);
-	return;
-    }
-    glyph = NULL;
-    fbGetDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
-    switch (dstBpp) {
-    case 8:	glyph = fbGlyph8; break;
-    case 16:    glyph = fbGlyph16; break;
-    case 24:    glyph = fbGlyph24; break;
-    case 32:    glyph = fbGlyph32; break;
-    }
-
-    x += pDrawable->x;
-    y += pDrawable->y;
-
-    if (TERMINALFONT (pGC->font) && !glyph)
-    {
-	opaque = TRUE;
-    }
-    else
-    {
-	int		xBack, widthBack;
-	int		yBack, heightBack;
-
-	ppci = ppciInit;
-	n = nglyph;
-	widthBack = 0;
-	while (n--)
-	    widthBack += (*ppci++)->metrics.characterWidth;
-
-        xBack = x;
-	if (widthBack < 0)
-	{
-	    xBack += widthBack;
-	    widthBack = -widthBack;
-	}
-	yBack = y - FONTASCENT(pGC->font);
-	heightBack = FONTASCENT(pGC->font) + FONTDESCENT(pGC->font);
-        exaSolidBoxClipped (pDrawable,
-			    fbGetCompositeClip(pGC),
-			    pGC->planemask,
-			    pGC->bgPixel,
-			    xBack,
-			    yBack,
-			    xBack + widthBack,
-			    yBack + heightBack);
-	opaque = FALSE;
-    }
-
-    EXA_FALLBACK(("to 0x%lx\n", (long)pDrawable));
-    exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
-
-    ppci = ppciInit;
-    while (nglyph--)
-    {
-	pci = *ppci++;
-	pglyph = FONTGLYPHBITS(pglyphBase, pci);
-	gWidth = GLYPHWIDTHPIXELS(pci);
-	gHeight = GLYPHHEIGHTPIXELS(pci);
-	if (gWidth && gHeight)
-	{
-	    gx = x + pci->metrics.leftSideBearing;
-	    gy = y - pci->metrics.ascent;
-	    if (glyph && gWidth <= sizeof (FbStip) * 8 &&
-		fbGlyphIn (fbGetCompositeClip(pGC), gx, gy, gWidth, gHeight))
-	    {
-		(*glyph) (dst + (gy + dstYoff) * dstStride,
-			  dstStride,
-			  dstBpp,
-			  (FbStip *) pglyph,
-			  pPriv->fg,
-			  gx + dstXoff,
-			  gHeight);
-	    }
-	    else
-	    {
-		gStride = GLYPHWIDTHBYTESPADDED(pci) / sizeof (FbStip);
-		fbPutXYImage (pDrawable,
-			      fbGetCompositeClip(pGC),
-			      pPriv->fg,
-			      pPriv->bg,
-			      pPriv->pm,
-			      GXcopy,
-			      opaque,
-
-			      gx,
-			      gy,
-			      gWidth, gHeight,
-
-			      (FbStip *) pglyph,
-			      gStride,
-			      0);
-	    }
-	}
-	x += pci->metrics.characterWidth;
-    }
-    exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
-}
-
-const GCOps exaOps = {
-    exaFillSpans,
-    ExaCheckSetSpans,
-    ExaCheckPutImage,
-    exaCopyArea,
-    ExaCheckCopyPlane,
-    ExaCheckPolyPoint,
-    ExaCheckPolylines,
-    ExaCheckPolySegment,
-    miPolyRectangle,
-    ExaCheckPolyArc,
-    miFillPolygon,
-    exaPolyFillRect,
-    miPolyFillArc,
-    miPolyText8,
-    miPolyText16,
-    miImageText8,
-    miImageText16,
-    exaImageGlyphBlt,
-    ExaCheckPolyGlyphBlt,
-    ExaCheckPushPixels,
-#ifdef NEED_LINEHELPER
-    ,NULL
-#endif
-};
-
-void
-exaCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
-{
-    RegionRec	rgnDst;
-    int		dx, dy;
-    PixmapPtr	pPixmap = (*pWin->drawable.pScreen->GetWindowPixmap) (pWin);
-    ScrnInfoPtr pScrn = XF86SCRNINFO(pWin->drawable.pScreen);
-
-    if (!pScrn->vtSema) {
-        ExaScreenPriv(pWin->drawable.pScreen);
-        pExaScr->SavedCopyWindow (pWin, ptOldOrg, prgnSrc);
-        exaDrawableDirty (&pWin->drawable);
-        return;
-    }
-
-    dx = ptOldOrg.x - pWin->drawable.x;
-    dy = ptOldOrg.y - pWin->drawable.y;
-    REGION_TRANSLATE(pWin->drawable.pScreen, prgnSrc, -dx, -dy);
-
-    REGION_INIT (pWin->drawable.pScreen, &rgnDst, NullBox, 0);
-
-    REGION_INTERSECT(pWin->drawable.pScreen, &rgnDst, &pWin->borderClip, prgnSrc);
-#ifdef COMPOSITE
-    if (pPixmap->screen_x || pPixmap->screen_y)
-	REGION_TRANSLATE (pWin->drawable.pScreen, &rgnDst,
-			  -pPixmap->screen_x, -pPixmap->screen_y);
-#endif
-
-    fbCopyRegion (&pPixmap->drawable, &pPixmap->drawable,
-		  NULL,
-		  &rgnDst, dx, dy, exaCopyNtoN, 0, NULL);
-
-    REGION_UNINIT(pWin->drawable.pScreen, &rgnDst);
-}
-
-static void
-exaFillRegionSolid (DrawablePtr	pDrawable,
-		    RegionPtr	pRegion,
-		    Pixel	pixel)
-{
-    ExaScreenPriv(pDrawable->pScreen);
-    PixmapPtr pPixmap;
-    int xoff, yoff;
-
-    if (pDrawable->width <= pExaScr->info->card.maxX &&
-	pDrawable->height <= pExaScr->info->card.maxY &&
-	(pPixmap = exaGetOffscreenPixmap (pDrawable, &xoff, &yoff)) &&
-	(*pExaScr->info->accel.PrepareSolid) (pPixmap, GXcopy, FB_ALLONES, pixel))
-    {
-	int	nbox = REGION_NUM_RECTS (pRegion);
-	BoxPtr	pBox = REGION_RECTS (pRegion);
-
-	while (nbox--)
-	{
-	    (*pExaScr->info->accel.Solid) (pPixmap,
-                                           pBox->x1 + xoff, pBox->y1 + yoff,
-                                           pBox->x2 + xoff, pBox->y2 + yoff);
-	    pBox++;
-	}
-	(*pExaScr->info->accel.DoneSolid) (pPixmap);
-	exaMarkSync(pDrawable->pScreen);
-	exaDrawableDirty (pDrawable);
-    }
-    else
-    {
-	EXA_FALLBACK(("to 0x%lx\n", (long)pDrawable));
-	exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
-	fbFillRegionSolid (pDrawable, pRegion, 0,
-			   fbReplicatePixel (pixel, pDrawable->bitsPerPixel));
-	exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
-    }
-}
-
-/* Try to do an accelerated tile of the pTile into pRegion of pDrawable.
- * Based on fbFillRegionTiled(), fbTile().
- */
-static void
-exaFillRegionTiled (DrawablePtr	pDrawable,
-		    RegionPtr	pRegion,
-		    PixmapPtr	pTile)
-{
-    ExaScreenPriv(pDrawable->pScreen);
-    PixmapPtr pPixmap;
-    int xoff, yoff;
-    int tileWidth, tileHeight;
-
-    tileWidth = pTile->drawable.width;
-    tileHeight = pTile->drawable.height;
-
-    if (pDrawable->width > pExaScr->info->card.maxX ||
-	pDrawable->height > pExaScr->info->card.maxY ||
-	tileWidth > pExaScr->info->card.maxX ||
-	tileHeight > pExaScr->info->card.maxY)
-    {
-	goto fallback;
-    }
-
-    /* If we're filling with a solid color, grab it out and go to
-     * FillRegionSolid, saving numerous copies.
-     */
-    if (tileWidth == 1 && tileHeight == 1) {
-	CARD32 pixel;
-
-	exaDrawableUseMemory(&pTile->drawable);
-	exaPrepareAccess(&pTile->drawable, EXA_PREPARE_SRC);
-	switch (pTile->drawable.bitsPerPixel) {
-	case 8:
-	    pixel = *(CARD8 *)(pTile->devPrivate.ptr);
-	    break;
-	case 16:
-	    pixel = *(CARD16 *)(pTile->devPrivate.ptr);
-	    break;
-	case 32:
-	    pixel = *(CARD32 *)(pTile->devPrivate.ptr);
-	    break;
-	default:
-	    exaFinishAccess(&pTile->drawable, EXA_PREPARE_SRC);
-	    goto fallback;
-	}
-	exaFinishAccess(&pTile->drawable, EXA_PREPARE_SRC);
-	exaFillRegionSolid(pDrawable, pRegion, pixel);
-	return;
-    }
-
-    pPixmap = exaGetOffscreenPixmap (pDrawable, &xoff, &yoff);
-    if (!pPixmap)
-	goto fallback;
-
-    exaPixmapUseScreen(pTile);
-    if (!exaPixmapIsOffscreen(pTile))
-	goto fallback;
-
-    if ((*pExaScr->info->accel.PrepareCopy) (pTile, pPixmap, 0, 0, GXcopy,
-					     FB_ALLONES))
-    {
-	int nbox = REGION_NUM_RECTS (pRegion);
-	BoxPtr pBox = REGION_RECTS (pRegion);
-
-	while (nbox--)
-	{
-	    int height = pBox->y2 - pBox->y1;
-	    int dstY = pBox->y1;
-	    int tileY;
-
-	    tileY = (dstY - pDrawable->y) % tileHeight;
-	    while (height > 0) {
-		int width = pBox->x2 - pBox->x1;
-		int dstX = pBox->x1;
-		int tileX;
-		int h = tileHeight - tileY;
-
-		if (h > height)
-		    h = height;
-		height -= h;
-
-		tileX = (dstX - pDrawable->x) % tileWidth;
-		while (width > 0) {
-		    int w = tileWidth - tileX;
-		    if (w > width)
-			w = width;
-		    width -= w;
-
-		    (*pExaScr->info->accel.Copy) (pPixmap,
-						  tileX, tileY,
-						  dstX + xoff, dstY + yoff,
-						  w, h);
-		    dstX += w;
-		    tileX = 0;
-		}
-		dstY += h;
-		tileY = 0;
-	    }
-	    pBox++;
-	}
-	(*pExaScr->info->accel.DoneCopy) (pPixmap);
-	exaMarkSync(pDrawable->pScreen);
-	exaDrawableDirty (pDrawable);
-	return;
-    }
-
-fallback:
-    EXA_FALLBACK(("from 0x%lx to 0x%lx\n", (long)pTile, (long)pDrawable));
-    exaPrepareAccess (pDrawable, EXA_PREPARE_DEST);
-    exaPrepareAccess ((DrawablePtr)pTile, EXA_PREPARE_SRC);
-    fbFillRegionTiled (pDrawable, pRegion, pTile);
-    exaFinishAccess ((DrawablePtr)pTile, EXA_PREPARE_SRC);
-    exaFinishAccess (pDrawable, EXA_PREPARE_DEST);
-}
-
-void
-exaPaintWindow(WindowPtr pWin, RegionPtr pRegion, int what)
-{
-    ScrnInfoPtr pScrn = XF86SCRNINFO(pWin->drawable.pScreen);
-
-    if (!REGION_NUM_RECTS(pRegion))
-	return;
-    if (pScrn->vtSema) {
-        switch (what) {
-        case PW_BACKGROUND:
-            switch (pWin->backgroundState) {
-            case None:
-                return;
-            case ParentRelative:
-                do {
-                    pWin = pWin->parent;
-                } while (pWin->backgroundState == ParentRelative);
-                (*pWin->drawable.pScreen->PaintWindowBackground)(pWin, pRegion,
-                                                                 what);
-                return;
-            case BackgroundPixel:
-                exaFillRegionSolid((DrawablePtr)pWin, pRegion, pWin->background.pixel);
-                return;
-            case BackgroundPixmap:
-                exaFillRegionTiled((DrawablePtr)pWin, pRegion, pWin->background.pixmap);
-                return;
-            }
-            break;
-        case PW_BORDER:
-            if (pWin->borderIsPixel) {
-                exaFillRegionSolid((DrawablePtr)pWin, pRegion, pWin->border.pixel);
-                return;
-            } else {
-                exaFillRegionTiled((DrawablePtr)pWin, pRegion, pWin->border.pixmap);
-                return;
-            }
-            break;
-        }
-    }
-    ExaCheckPaintWindow (pWin, pRegion, what);
-}
