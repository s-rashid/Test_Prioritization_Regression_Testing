diff --git a/hw/xfree86/common/xf86Bus.c b/hw/xfree86/common/xf86Bus.c
index 537ddf7..1959f79 100644
--- a/hw/xfree86/common/xf86Bus.c
+++ b/hw/xfree86/common/xf86Bus.c
@@ -1549,213 +1549,6 @@ RemoveOverlaps(resPtr target, resPtr list, Bool pow2Alignment, Bool useEstimated
 #endif
 
 /*
- * Resource request code
- */
-
-#define ALIGN(x,a) ((x) + a) &~(a)
-
-_X_EXPORT resRange 
-xf86GetBlock(unsigned long type, memType size,
-	 memType window_start, memType window_end,
-	 memType align_mask, resPtr avoid)
-{
-    memType min, max, tmp;
-    resRange r = {ResEnd,0,0};
-    resPtr res_range = ResRange;
-    
-    if (!size) return r;
-    if (window_end < window_start || (window_end - window_start) < (size - 1)) {
-	ErrorF("Requesting insufficient memory window!:"
-	       " start: 0x%lx end: 0x%lx size 0x%lx\n",
-	       window_start,window_end,size);
-	return r;
-    }
-    type = (type & ~(ResExtMask | ResBios | ResEstimated)) | ResBlock;
-    
-    while (res_range) {
-	if ((type & ResTypeMask) == (res_range->res_type & ResTypeMask)) {
-	    if (res_range->block_begin > window_start)
-		min = res_range->block_begin;
-	    else
-		min = window_start;
-	    if (res_range->block_end < window_end)
-		max = res_range->block_end;
-	    else
-		max = window_end;
-	    min = ALIGN(min,align_mask);
-	    /* do not produce an overflow! */
-	    while (min < max && (max - min) >= (size - 1)) {
-		RANGE(r,min,min + size - 1,type);
-		tmp = ChkConflict(&r,Acc,SETUP);
-		if (!tmp) {
-		    tmp = ChkConflict(&r,avoid,SETUP);
-		    if (!tmp) {
-			return r;
-		    } 
-		}
-		min = ALIGN(tmp,align_mask);
-	    }
-	}
-	res_range = res_range->next;
-    }
-    RANGE(r,0,0,ResEnd);
-    return r;
-}
-
-#define mt_max ~(memType)0
-#define length sizeof(memType) * 8
-/*
- * make_base() -- assign the lowest bits to the bits set in mask.
- *                example: mask 011010 val 0000110 -> 011000 
- */
-static memType
-make_base(memType val, memType mask)
-{
-    int i,j = 0;
-    memType ret = 0
-	;
-    for (i = 0;i<length;i++) {
-	if ((1 << i) & mask) {
-	    ret |= (((val >> j) & 1) << i);
-	    j++;
-	}
-    }
-    return ret;
-}
-
-/*
- * make_base() -- assign the bits set in mask to the lowest bits.
- *                example: mask 011010 , val 010010 -> 000011
- */
-static memType
-unmake_base(memType val, memType mask)
-{
-    int i,j = 0;
-    memType ret = 0;
-    
-    for (i = 0;i<length;i++) {
-	if ((1 << i) & mask) {
-	    ret |= (((val >> i) & 1) << j);
-	    j++;
-	}
-    }
-    return ret;
-}
-
-static memType
-fix_counter(memType val, memType old_mask, memType mask)
-{
-    mask = old_mask & mask;
-    
-    val = make_base(val,old_mask);
-    return unmake_base(val,mask);
-}
-
-_X_EXPORT resRange
-xf86GetSparse(unsigned long type,  memType fixed_bits,
-	  memType decode_mask, memType address_mask, resPtr avoid)
-{
-    resRange r = {ResEnd,0,0};
-    memType new_mask;
-    memType mask1;
-    memType base;
-    memType counter = 0;
-    memType counter1;
-    memType max_counter = ~(memType)0;
-    memType max_counter1;
-    memType conflict = 0;
-    
-    /* for sanity */
-    type = (type & ~(ResExtMask | ResBios | ResEstimated)) | ResSparse;
-
-    /*
-     * a sparse address consists of 3 parts:
-     * fixed_bits:   F bits which hard decoded by the hardware
-     * decode_bits:  D bits which are used to decode address
-     *                 but which may be set by software
-     * address_bits: A bits which are used to address the
-     *                 sparse range.
-     * the decode_mask marks all decode bits while the address_mask
-     * masks out all address_bits:
-     *                F D A
-     * decode_mask:   0 1 0
-     * address_mask:  1 1 0
-     */
-    decode_mask &= address_mask;
-    new_mask = decode_mask;
-
-    /*
-     * We start by setting the decode_mask bits to different values
-     * when a conflict is found the address_mask of the conflicting
-     * resource is returned. We remove those bits from decode_mask
-     * that are also set in the returned address_mask as they always
-     * conflict with resources which use them as address masks.
-     * The resoulting mask is stored in new_mask.
-     * We continue until no conflict is found or until we have
-     * tried all possible settings of new_mask.
-     */
-    while (1) {
-	base = make_base(counter,new_mask) | fixed_bits;
-	RANGE(r,base,address_mask,type);
-	conflict = ChkConflict(&r,Acc,SETUP);
-	if (!conflict) {
-	    conflict = ChkConflict(&r,avoid,SETUP);
-	    if (!conflict) {
-		return r;
-	    }
-	}
-	counter = fix_counter(counter,new_mask,conflict);
-	max_counter = fix_counter(max_counter,new_mask,conflict);
-	new_mask &= conflict;
-	counter ++;
-	if (counter > max_counter) break;
-    }
-    if (!new_mask && (new_mask == decode_mask)) {
-	RANGE(r,0,0,ResEnd);
-	return r;
-    }
-    /*
-     * if we haven't been successful we also try to modify those
-     * bits in decode_mask that are not at the same time set in
-     * new mask. These bits overlap with address_bits of some
-     * resources. If a conflict with a resource of this kind is
-     * found (ie. returned_mask & mask1 != mask1) with
-     * mask1 = decode_mask & ~new_mask we cannot
-     * use our choice of bits in the new_mask part. We try
-     * another choice.
-     */
-    max_counter = fix_counter(mt_max,mt_max,new_mask);
-    mask1 = decode_mask & ~new_mask;
-    max_counter1 = fix_counter(mt_max,mt_max,mask1);
-    counter = 0;
-    
-    while (1) {
-	counter1 = 0;
-	while (1) {
-	    base = make_base(counter1,mask1);
-	    RANGE(r,base,address_mask,type);
-	    conflict = ChkConflict(&r,Acc,SETUP);
-	    if (!conflict) {
-		conflict = ChkConflict(&r,avoid,SETUP);
-		if (!conflict) {
-		    return r;
-		}
-	    }
-	    counter1 ++;
-	    if ((mask1 & conflict) != mask1 || counter1 > max_counter1)
-		break;
-	}
-	counter ++;
-	if (counter > max_counter) break;
-    }
-    RANGE(r,0,0,ResEnd);
-    return r;
-}
-
-#undef length
-#undef mt_max
-
-/*
  * Resource registrarion
  */
 
