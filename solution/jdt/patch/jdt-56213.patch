diff --git a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
index 10045c2..32d3bb7 100644
--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
@@ -11,75 +11,168 @@
 package org.eclipse.jdt.internal.compiler.codegen;
 
 import org.eclipse.jdt.core.compiler.CharOperation;
-import org.eclipse.jdt.internal.compiler.*;
-
-import org.eclipse.jdt.internal.compiler.impl.*;
-import org.eclipse.jdt.internal.compiler.ast.*;
-import org.eclipse.jdt.internal.compiler.classfmt.*;
-import org.eclipse.jdt.internal.compiler.flow.*;
+import org.eclipse.jdt.internal.compiler.ClassFile;
+import org.eclipse.jdt.internal.compiler.CompilationResult;
+import org.eclipse.jdt.internal.compiler.ast.ASTNode;
+import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
+import org.eclipse.jdt.internal.compiler.ast.AllocationExpression;
+import org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall;
+import org.eclipse.jdt.internal.compiler.ast.Expression;
+import org.eclipse.jdt.internal.compiler.ast.OperatorIds;
+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants;
+import org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.compiler.impl.Constant;
 import org.eclipse.jdt.internal.compiler.lookup.*;
+import org.eclipse.jdt.internal.compiler.problem.AbortMethod;
 
-public class CodeStream implements OperatorIds, Opcodes, TypeConstants, TypeIds {
+public class CodeStream {
 
 	public static final boolean DEBUG = false;
 	
 	// It will be responsible for the following items.
 	// -> Tracking Max Stack.
 
-	public int stackMax; // Use Ints to keep from using extra bc when adding
-	public int stackDepth; // Use Ints to keep from using extra bc when adding
-	public int maxLocals;
+	public static FieldBinding[] ImplicitThis = new FieldBinding[] {};
 	public static final int LABELS_INCREMENT = 5;
-	public byte[] bCodeStream;
-	public int pcToSourceMapSize;
-	public int[] pcToSourceMap = new int[24];
-	public int lastEntryPC; // last entry recorded
-	public int[] lineSeparatorPositions;
-	public int position; // So when first set can be incremented
-	public int classFileOffset;
-	public int startingClassFileOffset; // I need to keep the starting point inside the byte array
-	public ConstantPool constantPool; // The constant pool used to generate bytecodes that need to store information into the constant pool
-	public ClassFile classFile; // The current classfile it is associated to.
 	// local variable attributes output
 	public static final int LOCALS_INCREMENT = 10;
-	public LocalVariableBinding[] locals = new LocalVariableBinding[LOCALS_INCREMENT];
+	static ExceptionLabel[] noExceptionHandlers = new ExceptionLabel[LABELS_INCREMENT];
+	static Label[] noLabels = new Label[LABELS_INCREMENT];
 	static LocalVariableBinding[] noLocals = new LocalVariableBinding[LOCALS_INCREMENT];
-	public LocalVariableBinding[] visibleLocals = new LocalVariableBinding[LOCALS_INCREMENT];
 	static LocalVariableBinding[] noVisibleLocals = new LocalVariableBinding[LOCALS_INCREMENT];
-	int visibleLocalsCount;
-	public AbstractMethodDeclaration methodDeclaration;
+	public static final CompilationResult RESTART_IN_WIDE_MODE = new CompilationResult((char[])null, 0, 0, 0);
+	/**
+	 * This methods searches for an existing entry inside the pcToSourceMap table with a pc equals to @pc.
+	 * If there is an existing entry it returns -1 (no insertion required).
+	 * Otherwise it returns the index where the entry for the pc has to be inserted.
+	 * This is based on the fact that the pcToSourceMap table is sorted according to the pc.
+	 *
+	 * @param pcToSourceMap the given pcToSourceMap array
+	 * @param length the given length
+	 * @param pc the given pc
+	 * @return int
+	 */
+	public static int insertionIndex(int[] pcToSourceMap, int length, int pc) {
+		int g = 0;
+		int d = length - 2;
+		int m = 0;
+		while (g <= d) {
+			m = (g + d) / 2;
+			// we search only on even indexes
+			if ((m % 2) != 0)
+				m--;
+			int currentPC = pcToSourceMap[m];
+			if (pc < currentPC) {
+				d = m - 2;
+			} else
+				if (pc > currentPC) {
+					g = m + 2;
+				} else {
+					return -1;
+				}
+		}
+		if (pc < pcToSourceMap[m])
+			return m;
+		return m + 2;
+	}
+	public static final void sort(int[] tab, int lo0, int hi0, int[] result) {
+		int lo = lo0;
+		int hi = hi0;
+		int mid;
+		if (hi0 > lo0) {
+			/* Arbitrarily establishing partition element as the midpoint of
+			  * the array.
+			  */
+			mid = tab[ (lo0 + hi0) / 2];
+			// loop through the array until indices cross
+			while (lo <= hi) {
+				/* find the first element that is greater than or equal to 
+				 * the partition element starting from the left Index.
+				 */
+				while ((lo < hi0) && (tab[lo] < mid))
+					++lo;
+				/* find an element that is smaller than or equal to 
+				 * the partition element starting from the right Index.
+				 */
+				while ((hi > lo0) && (tab[hi] > mid))
+					--hi;
+				// if the indexes have not crossed, swap
+				if (lo <= hi) {
+					swap(tab, lo, hi, result);
+					++lo;
+					--hi;
+				}
+			}
+			/* If the right index has not reached the left side of array
+			  * must now sort the left partition.
+			  */
+			if (lo0 < hi)
+				sort(tab, lo0, hi, result);
+			/* If the left index has not reached the right side of array
+			  * must now sort the right partition.
+			  */
+			if (lo < hi0)
+				sort(tab, lo, hi0, result);
+		}
+	}
+	private static final void swap(int a[], int i, int j, int result[]) {
+		int T;
+		T = a[i];
+		a[i] = a[j];
+		a[j] = T;
+		T = result[j];
+		result[j] = result[i];
+		result[i] = T;
+	}
+	public int allLocalsCounter;
+	public byte[] bCodeStream;
+	public ClassFile classFile; // The current classfile it is associated to.
+	public int classFileOffset;
+	public ConstantPool constantPool; // The constant pool used to generate bytecodes that need to store information into the constant pool
+	public int countLabels;
 	public ExceptionLabel[] exceptionHandlers = new ExceptionLabel[LABELS_INCREMENT];
-	static ExceptionLabel[] noExceptionHandlers = new ExceptionLabel[LABELS_INCREMENT];
-	public int exceptionHandlersIndex;
 	public int exceptionHandlersCounter;
-	
-	public static FieldBinding[] ImplicitThis = new FieldBinding[] {};
+	public int exceptionHandlersIndex;
 	public boolean generateLineNumberAttributes;
 	public boolean generateLocalVariableTableAttributes;
-	public boolean preserveUnusedLocals;
 	// store all the labels placed at the current position to be able to optimize
 	// a jump to the next bytecode.
 	public Label[] labels = new Label[LABELS_INCREMENT];
-	static Label[] noLabels = new Label[LABELS_INCREMENT];
-	public int countLabels;
-	public int allLocalsCounter;
+	public int lastEntryPC; // last entry recorded
+	public int[] lineSeparatorPositions;
+	
+	public LocalVariableBinding[] locals = new LocalVariableBinding[LOCALS_INCREMENT];
+	public boolean manageLocalVariables;
 	public int maxFieldCount;
-	// to handle goto_w
-	public boolean wideMode = false;
-	public static final CompilationResult RESTART_IN_WIDE_MODE = new CompilationResult((char[])null, 0, 0, 0);
+	
+	public int maxLocals;
+	public AbstractMethodDeclaration methodDeclaration;
+	public int[] pcToSourceMap = new int[24];
+	public int pcToSourceMapSize;
+	public int position; // So when first set can be incremented
+	public boolean preserveUnusedLocals;
+	public int stackDepth; // Use Ints to keep from using extra bc when adding
+	public int stackMax; // Use Ints to keep from using extra bc when adding
+	public int startingClassFileOffset; // I need to keep the starting point inside the byte array
 	
 	// target level to manage different code generation between different target levels
 	private long targetLevel;
 	
-public CodeStream(ClassFile classFile, long targetLevel) {
-	this.targetLevel = targetLevel;
+public LocalVariableBinding[] visibleLocals = new LocalVariableBinding[LOCALS_INCREMENT];
+int visibleLocalsCount;
+// to handle goto_w
+public boolean wideMode = false;
+public CodeStream(ClassFile classFile) {
+	this.targetLevel = classFile.targetJDK;
 	this.generateLineNumberAttributes = (classFile.produceDebugAttributes & CompilerOptions.Lines) != 0;
+	this.manageLocalVariables = (classFile.produceDebugAttributes & CompilerOptions.Vars) != 0;
 	this.generateLocalVariableTableAttributes = (classFile.produceDebugAttributes & CompilerOptions.Vars) != 0;
 	if (this.generateLineNumberAttributes) {
 		this.lineSeparatorPositions = classFile.referenceBinding.scope.referenceCompilationUnit().compilationResult.getLineSeparatorPositions();
 	}
 }
-final public void aaload() {
+public void aaload() {
 	if (DEBUG) System.out.println(position + "\t\taaload"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -87,9 +180,9 @@ final public void aaload() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_aaload;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_aaload;
 }
-final public void aastore() {
+public void aastore() {
 	if (DEBUG) System.out.println(position + "\t\taastore"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 3;
@@ -97,9 +190,9 @@ final public void aastore() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_aastore;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_aastore;
 }
-final public void aconst_null() {
+public void aconst_null() {
 	if (DEBUG) System.out.println(position + "\t\taconst_null"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -110,11 +203,11 @@ final public void aconst_null() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_aconst_null;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_aconst_null;
 }
-public final void addDefinitelyAssignedVariables(Scope scope, int initStateIndex) {
+public void addDefinitelyAssignedVariables(Scope scope, int initStateIndex) {
 	// Required to fix 1PR0XVS: LFRE:WINNT - Compiler: variable table for method appears incorrect
-	if (!generateLocalVariableTableAttributes)
+	if (!this.generateLocalVariableTableAttributes)
 		return;
 /*	if (initStateIndex == lastInitStateIndexWhenAddingInits)
 		return;
@@ -129,7 +222,7 @@ public final void addDefinitelyAssignedVariables(Scope scope, int initStateIndex
 		LocalVariableBinding localBinding = visibleLocals[i];
 		if (localBinding != null) {
 			// Check if the local is definitely assigned
-			if ((initStateIndex != -1) && isDefinitelyAssigned(scope, initStateIndex, localBinding)) {
+			if (isDefinitelyAssigned(scope, initStateIndex, localBinding)) {
 				if ((localBinding.initializationCount == 0) || (localBinding.initializationPCs[((localBinding.initializationCount - 1) << 1) + 1] != -1)) {
 					/* There are two cases:
 					 * 1) there is no initialization interval opened ==> add an opened interval
@@ -152,14 +245,14 @@ public void addLabel(Label aLabel) {
 	labels[countLabels++] = aLabel;
 }
 public void addVisibleLocalVariable(LocalVariableBinding localBinding) {
-	if (!generateLocalVariableTableAttributes)
+	if (!manageLocalVariables)
 		return;
 
 	if (visibleLocalsCount >= visibleLocals.length)
 		System.arraycopy(visibleLocals, 0, visibleLocals = new LocalVariableBinding[visibleLocalsCount * 2], 0, visibleLocalsCount);
 	visibleLocals[visibleLocalsCount++] = localBinding;
 }
-final public void aload(int iArg) {
+public void aload(int iArg) {
 	if (DEBUG) System.out.println(position + "\t\taload:"+iArg); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -173,8 +266,8 @@ final public void aload(int iArg) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_wide;
-		bCodeStream[classFileOffset++] = OPC_aload;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_wide;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_aload;
 		writeUnsignedShort(iArg);
 	} else {
 		// Don't need to use the wide bytecode
@@ -182,11 +275,11 @@ final public void aload(int iArg) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_aload;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_aload;
 		bCodeStream[classFileOffset++] = (byte) iArg;
 	}
 }
-final public void aload_0() {
+public void aload_0() {
 	if (DEBUG) System.out.println(position + "\t\taload_0"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -200,9 +293,9 @@ final public void aload_0() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_aload_0;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_aload_0;
 }
-final public void aload_1() {
+public void aload_1() {
 	if (DEBUG) System.out.println(position + "\t\taload_1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -215,9 +308,9 @@ final public void aload_1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_aload_1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_aload_1;
 }
-final public void aload_2() {
+public void aload_2() {
 	if (DEBUG) System.out.println(position + "\t\taload_2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -230,9 +323,9 @@ final public void aload_2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_aload_2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_aload_2;
 }
-final public void aload_3() {
+public void aload_3() {
 	if (DEBUG) System.out.println(position + "\t\taload_3"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -245,19 +338,19 @@ final public void aload_3() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_aload_3;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_aload_3;
 }
-public final void anewarray(TypeBinding typeBinding) {
+public void anewarray(TypeBinding typeBinding) {
 	if (DEBUG) System.out.println(position + "\t\tanewarray: " + typeBinding); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset + 2 >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_anewarray;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_anewarray;
 	writeUnsignedShort(constantPool.literalIndexForType(typeBinding.constantPoolName()));
 }
-final public void areturn() {
+public void areturn() {
 	if (DEBUG) System.out.println(position + "\t\tareturn"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -266,30 +359,30 @@ final public void areturn() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_areturn;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_areturn;
 }
 public void arrayAt(int typeBindingID) {
 	switch (typeBindingID) {
-		case T_int :
+		case TypeIds.T_int :
 			this.iaload();
 			break;
-		case T_byte :
-		case T_boolean :
+		case TypeIds.T_byte :
+		case TypeIds.T_boolean :
 			this.baload();
 			break;
-		case T_short :
+		case TypeIds.T_short :
 			this.saload();
 			break;
-		case T_char :
+		case TypeIds.T_char :
 			this.caload();
 			break;
-		case T_long :
+		case TypeIds.T_long :
 			this.laload();
 			break;
-		case T_float :
+		case TypeIds.T_float :
 			this.faload();
 			break;
-		case T_double :
+		case TypeIds.T_double :
 			this.daload();
 			break;
 		default :
@@ -298,38 +391,38 @@ public void arrayAt(int typeBindingID) {
 }
 public void arrayAtPut(int elementTypeID, boolean valueRequired) {
 	switch (elementTypeID) {
-		case T_int :
+		case TypeIds.T_int :
 			if (valueRequired)
 				dup_x2();
 			iastore();
 			break;
-		case T_byte :
-		case T_boolean :
+		case TypeIds.T_byte :
+		case TypeIds.T_boolean :
 			if (valueRequired)
 				dup_x2();
 			bastore();
 			break;
-		case T_short :
+		case TypeIds.T_short :
 			if (valueRequired)
 				dup_x2();
 			sastore();
 			break;
-		case T_char :
+		case TypeIds.T_char :
 			if (valueRequired)
 				dup_x2();
 			castore();
 			break;
-		case T_long :
+		case TypeIds.T_long :
 			if (valueRequired)
 				dup2_x2();
 			lastore();
 			break;
-		case T_float :
+		case TypeIds.T_float :
 			if (valueRequired)
 				dup_x2();
 			fastore();
 			break;
-		case T_double :
+		case TypeIds.T_double :
 			if (valueRequired)
 				dup2_x2();
 			dastore();
@@ -340,16 +433,16 @@ public void arrayAtPut(int elementTypeID, boolean valueRequired) {
 			aastore();
 	}
 }
-final public void arraylength() {
+public void arraylength() {
 	if (DEBUG) System.out.println(position + "\t\tarraylength"); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_arraylength;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_arraylength;
 }
-final public void astore(int iArg) {
+public void astore(int iArg) {
 	if (DEBUG) System.out.println(position + "\t\tastore:"+iArg); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -361,19 +454,19 @@ final public void astore(int iArg) {
 			resizeByteArray();
 		}
 		position+=2;
-		bCodeStream[classFileOffset++] = OPC_wide;
-		bCodeStream[classFileOffset++] = OPC_astore;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_wide;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_astore;
 		writeUnsignedShort(iArg);
 	} else {
 		if (classFileOffset + 1 >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position+=2;
-		bCodeStream[classFileOffset++] = OPC_astore;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_astore;
 		bCodeStream[classFileOffset++] = (byte) iArg;
 	}
 }
-final public void astore_0() {
+public void astore_0() {
 	if (DEBUG) System.out.println(position + "\t\tastore_0"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -384,9 +477,9 @@ final public void astore_0() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_astore_0;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_astore_0;
 }
-final public void astore_1() {
+public void astore_1() {
 	if (DEBUG) System.out.println(position + "\t\tastore_1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -397,9 +490,9 @@ final public void astore_1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_astore_1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_astore_1;
 }
-final public void astore_2() {
+public void astore_2() {
 	if (DEBUG) System.out.println(position + "\t\tastore_2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -410,9 +503,9 @@ final public void astore_2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_astore_2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_astore_2;
 }
-final public void astore_3() {
+public void astore_3() {
 	if (DEBUG) System.out.println(position + "\t\tastore_3"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -423,9 +516,9 @@ final public void astore_3() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_astore_3;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_astore_3;
 }
-final public void athrow() {
+public void athrow() {
 	if (DEBUG) System.out.println(position + "\t\tathrow"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -433,9 +526,9 @@ final public void athrow() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_athrow;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_athrow;
 }
-final public void baload() {
+public void baload() {
 	if (DEBUG) System.out.println(position + "\t\tbaload"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -443,9 +536,9 @@ final public void baload() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_baload;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_baload;
 }
-final public void bastore() {
+public void bastore() {
 	if (DEBUG) System.out.println(position + "\t\tbastore"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 3;
@@ -453,9 +546,9 @@ final public void bastore() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_bastore;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_bastore;
 }
-final public void bipush(byte b) {
+public void bipush(byte b) {
 	if (DEBUG) System.out.println(position + "\t\tbipush "+b); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -465,10 +558,10 @@ final public void bipush(byte b) {
 		resizeByteArray();
 	}
 	position += 2;
-	bCodeStream[classFileOffset++] = OPC_bipush;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_bipush;
 	bCodeStream[classFileOffset++] = b;
 }
-final public void caload() {
+public void caload() {
 	if (DEBUG) System.out.println(position + "\t\tcaload"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -476,9 +569,9 @@ final public void caload() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_caload;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_caload;
 }
-final public void castore() {
+public void castore() {
 	if (DEBUG) System.out.println(position + "\t\tcastore"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 3;
@@ -486,19 +579,52 @@ final public void castore() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_castore;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_castore;
+}
+public void checkcast(int baseId) {
+	this.countLabels = 0;
+	if (classFileOffset + 2 >= bCodeStream.length) {
+		resizeByteArray();
+	}
+	this.position++;
+	this.bCodeStream[this.classFileOffset++] = Opcodes.OPC_checkcast;
+	switch (baseId) {
+		case TypeIds.T_byte :
+			writeUnsignedShort(this.constantPool.literalIndexForType(ConstantPool.JavaLangByteConstantPoolName));
+			break;
+		case TypeIds.T_short :
+			writeUnsignedShort(this.constantPool.literalIndexForType(ConstantPool.JavaLangShortConstantPoolName));
+			break;
+		case TypeIds.T_char :
+			writeUnsignedShort(this.constantPool.literalIndexForType(ConstantPool.JavaLangCharacterConstantPoolName));
+			break;
+		case TypeIds.T_int :
+			writeUnsignedShort(this.constantPool.literalIndexForType(ConstantPool.JavaLangIntegerConstantPoolName));
+			break;
+		case TypeIds.T_long :
+			writeUnsignedShort(this.constantPool.literalIndexForType(ConstantPool.JavaLangLongConstantPoolName));
+			break;
+		case TypeIds.T_float :
+			writeUnsignedShort(this.constantPool.literalIndexForType(ConstantPool.JavaLangFloatConstantPoolName));
+			break;
+		case TypeIds.T_double :
+			writeUnsignedShort(this.constantPool.literalIndexForType(ConstantPool.JavaLangDoubleConstantPoolName));
+			break;
+		case TypeIds.T_boolean :
+			writeUnsignedShort(this.constantPool.literalIndexForType(ConstantPool.JavaLangBooleanConstantPoolName));
+	}
 }
-public final void checkcast(TypeBinding typeBinding) {
+public void checkcast(TypeBinding typeBinding) {
 	if (DEBUG) System.out.println(position + "\t\tcheckcast:"+typeBinding.debugName()); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset + 2 >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_checkcast;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_checkcast;
 	writeUnsignedShort(constantPool.literalIndexForType(typeBinding.constantPoolName()));
 }
-final public void d2f() {
+public void d2f() {
 	if (DEBUG) System.out.println(position + "\t\td2f"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -506,9 +632,9 @@ final public void d2f() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_d2f;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_d2f;
 }
-final public void d2i() {
+public void d2i() {
 	if (DEBUG) System.out.println(position + "\t\td2i"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -516,18 +642,18 @@ final public void d2i() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_d2i;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_d2i;
 }
-final public void d2l() {
+public void d2l() {
 	if (DEBUG) System.out.println(position + "\t\td2l"); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_d2l;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_d2l;
 }
-final public void dadd() {
+public void dadd() {
 	if (DEBUG) System.out.println(position + "\t\tdadd"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -535,18 +661,18 @@ final public void dadd() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dadd;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dadd;
 }
-final public void daload() {
+public void daload() {
 	if (DEBUG) System.out.println(position + "\t\tdaload"); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_daload;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_daload;
 }
-final public void dastore() {
+public void dastore() {
 	if (DEBUG) System.out.println(position + "\t\tdastore"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 4;
@@ -554,9 +680,9 @@ final public void dastore() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dastore;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dastore;
 }
-final public void dcmpg() {
+public void dcmpg() {
 	if (DEBUG) System.out.println(position + "\t\tdcmpg"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 3;
@@ -564,9 +690,9 @@ final public void dcmpg() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dcmpg;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dcmpg;
 }
-final public void dcmpl() {
+public void dcmpl() {
 	if (DEBUG) System.out.println(position + "\t\tdcmpl"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 3;
@@ -574,9 +700,9 @@ final public void dcmpl() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dcmpl;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dcmpl;
 }
-final public void dconst_0() {
+public void dconst_0() {
 	if (DEBUG) System.out.println(position + "\t\tdconst_0"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -586,9 +712,9 @@ final public void dconst_0() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dconst_0;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dconst_0;
 }
-final public void dconst_1() {
+public void dconst_1() {
 	if (DEBUG) System.out.println(position + "\t\tdconst_1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -598,9 +724,9 @@ final public void dconst_1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dconst_1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dconst_1;
 }
-final public void ddiv() {
+public void ddiv() {
 	if (DEBUG) System.out.println(position + "\t\tddiv"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -608,12 +734,12 @@ final public void ddiv() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_ddiv;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_ddiv;
 }
 public void decrStackSize(int offset) {
 	stackDepth -= offset;
 }
-final public void dload(int iArg) {
+public void dload(int iArg) {
 	if (DEBUG) System.out.println(position + "\t\tdload:"+iArg); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -627,8 +753,8 @@ final public void dload(int iArg) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_wide;
-		bCodeStream[classFileOffset++] = OPC_dload;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_wide;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_dload;
 		writeUnsignedShort(iArg);
 	} else {
 		// Don't need to use the wide bytecode
@@ -636,11 +762,11 @@ final public void dload(int iArg) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_dload;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_dload;
 		bCodeStream[classFileOffset++] = (byte) iArg;
 	}
 }
-final public void dload_0() {
+public void dload_0() {
 	if (DEBUG) System.out.println(position + "\t\tdload_0"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -653,9 +779,9 @@ final public void dload_0() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dload_0;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dload_0;
 }
-final public void dload_1() {
+public void dload_1() {
 	if (DEBUG) System.out.println(position + "\t\tdload_1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -668,9 +794,9 @@ final public void dload_1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dload_1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dload_1;
 }
-final public void dload_2() {
+public void dload_2() {
 	if (DEBUG) System.out.println(position + "\t\tdload_2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -683,9 +809,9 @@ final public void dload_2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dload_2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dload_2;
 }
-final public void dload_3() {
+public void dload_3() {
 	if (DEBUG) System.out.println(position + "\t\tdload_3"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -698,9 +824,9 @@ final public void dload_3() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dload_3;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dload_3;
 }
-final public void dmul() {
+public void dmul() {
 	if (DEBUG) System.out.println(position + "\t\tdmul"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -708,18 +834,18 @@ final public void dmul() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dmul;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dmul;
 }
-final public void dneg() {
+public void dneg() {
 	if (DEBUG) System.out.println(position + "\t\tdneg"); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dneg;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dneg;
 }
-final public void drem() {
+public void drem() {
 	if (DEBUG) System.out.println(position + "\t\tdrem"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -727,9 +853,9 @@ final public void drem() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_drem;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_drem;
 }
-final public void dreturn() {
+public void dreturn() {
 	if (DEBUG) System.out.println(position + "\t\tdreturn"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -738,9 +864,9 @@ final public void dreturn() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dreturn;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dreturn;
 }
-final public void dstore(int iArg) {
+public void dstore(int iArg) {
 	if (DEBUG) System.out.println(position + "\t\tdstore:"+iArg); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -752,19 +878,19 @@ final public void dstore(int iArg) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_wide;
-		bCodeStream[classFileOffset++] = OPC_dstore;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_wide;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_dstore;
 		writeUnsignedShort(iArg);
 	} else {
 		if (classFileOffset + 1 >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_dstore;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_dstore;
 		bCodeStream[classFileOffset++] = (byte) iArg;
 	}
 }
-final public void dstore_0() {
+public void dstore_0() {
 	if (DEBUG) System.out.println(position + "\t\tdstore_0"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -775,9 +901,9 @@ final public void dstore_0() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dstore_0;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dstore_0;
 }
-final public void dstore_1() {
+public void dstore_1() {
 	if (DEBUG) System.out.println(position + "\t\tdstore_1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -788,9 +914,9 @@ final public void dstore_1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dstore_1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dstore_1;
 }
-final public void dstore_2() {
+public void dstore_2() {
 	if (DEBUG) System.out.println(position + "\t\tdstore_2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -801,9 +927,9 @@ final public void dstore_2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dstore_2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dstore_2;
 }
-final public void dstore_3() {
+public void dstore_3() {
 	if (DEBUG) System.out.println(position + "\t\tdstore_3"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -814,9 +940,9 @@ final public void dstore_3() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dstore_3;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dstore_3;
 }
-final public void dsub() {
+public void dsub() {
 	if (DEBUG) System.out.println(position + "\t\tdsub"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -824,9 +950,9 @@ final public void dsub() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dsub;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dsub;
 }
-final public void dup() {
+public void dup() {
 	if (DEBUG) System.out.println(position + "\t\tdup"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -837,9 +963,9 @@ final public void dup() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dup;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dup;
 }
-final public void dup_x1() {
+public void dup_x1() {
 	if (DEBUG) System.out.println(position + "\t\tdup_x1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -849,9 +975,9 @@ final public void dup_x1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dup_x1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dup_x1;
 }
-final public void dup_x2() {
+public void dup_x2() {
 	if (DEBUG) System.out.println(position + "\t\tdup_x2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -861,9 +987,9 @@ final public void dup_x2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dup_x2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dup_x2;
 }
-final public void dup2() {
+public void dup2() {
 	if (DEBUG) System.out.println(position + "\t\tdup2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -873,9 +999,9 @@ final public void dup2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dup2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dup2;
 }
-final public void dup2_x1() {
+public void dup2_x1() {
 	if (DEBUG) System.out.println(position + "\t\tdup2_x1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -885,9 +1011,9 @@ final public void dup2_x1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dup2_x1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dup2_x1;
 }
-final public void dup2_x2() {
+public void dup2_x2() {
 	if (DEBUG) System.out.println(position + "\t\tdup2_x2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -897,28 +1023,28 @@ final public void dup2_x2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_dup2_x2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_dup2_x2;
 }
 public void exitUserScope(BlockScope currentScope) {
 	// mark all the scope's locals as losing their definite assignment
 
-	if (!generateLocalVariableTableAttributes)
+	if (!manageLocalVariables)
 		return;
 	while (visibleLocalsCount > 0) {
 		LocalVariableBinding visibleLocal = visibleLocals[this.visibleLocalsCount - 1];
-		if (visibleLocal == null)
-			continue;
-		if (visibleLocal.declaringScope != currentScope) // left currentScope
+		if (visibleLocal == null || visibleLocal.declaringScope != currentScope) {
+			// left currentScope
 			break;
+		}
 
 		// there may be some preserved locals never initialized
-		if (visibleLocal.initializationCount > 0){
+		if (visibleLocal.initializationCount > 0 && this.generateLocalVariableTableAttributes){
 			visibleLocal.recordInitializationEndPC(position);
 		}
 		visibleLocals[--this.visibleLocalsCount] = null; // this variable is no longer visible afterwards
 	}
 }
-final public void f2d() {
+public void f2d() {
 	if (DEBUG) System.out.println(position + "\t\tf2d"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -928,18 +1054,18 @@ final public void f2d() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_f2d;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_f2d;
 }
-final public void f2i() {
+public void f2i() {
 	if (DEBUG) System.out.println(position + "\t\tf2i"); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_f2i;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_f2i;
 }
-final public void f2l() {
+public void f2l() {
 	if (DEBUG) System.out.println(position + "\t\tf2l"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -949,9 +1075,9 @@ final public void f2l() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_f2l;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_f2l;
 }
-final public void fadd() {
+public void fadd() {
 	if (DEBUG) System.out.println(position + "\t\tfadd"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -959,9 +1085,9 @@ final public void fadd() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fadd;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fadd;
 }
-final public void faload() {
+public void faload() {
 	if (DEBUG) System.out.println(position + "\t\tfaload"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -969,9 +1095,9 @@ final public void faload() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_faload;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_faload;
 }
-final public void fastore() {
+public void fastore() {
 	if (DEBUG) System.out.println(position + "\t\tfaload"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 3;
@@ -979,9 +1105,9 @@ final public void fastore() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fastore;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fastore;
 }
-final public void fcmpg() {
+public void fcmpg() {
 	if (DEBUG) System.out.println(position + "\t\tfcmpg"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -989,9 +1115,9 @@ final public void fcmpg() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fcmpg;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fcmpg;
 }
-final public void fcmpl() {
+public void fcmpl() {
 	if (DEBUG) System.out.println(position + "\t\tfcmpl"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -999,9 +1125,9 @@ final public void fcmpl() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fcmpl;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fcmpl;
 }
-final public void fconst_0() {
+public void fconst_0() {
 	if (DEBUG) System.out.println(position + "\t\tfconst_0"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -1011,9 +1137,9 @@ final public void fconst_0() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fconst_0;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fconst_0;
 }
-final public void fconst_1() {
+public void fconst_1() {
 	if (DEBUG) System.out.println(position + "\t\tfconst_1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -1023,9 +1149,9 @@ final public void fconst_1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fconst_1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fconst_1;
 }
-final public void fconst_2() {
+public void fconst_2() {
 	if (DEBUG) System.out.println(position + "\t\tfconst_2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -1035,9 +1161,9 @@ final public void fconst_2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fconst_2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fconst_2;
 }
-final public void fdiv() {
+public void fdiv() {
 	if (DEBUG) System.out.println(position + "\t\tfdiv"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -1045,9 +1171,9 @@ final public void fdiv() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fdiv;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fdiv;
 }
-final public void fload(int iArg) {
+public void fload(int iArg) {
 	if (DEBUG) System.out.println(position + "\t\tfload:"+iArg); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -1061,19 +1187,19 @@ final public void fload(int iArg) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_wide;
-		bCodeStream[classFileOffset++] = OPC_fload;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_wide;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_fload;
 		writeUnsignedShort(iArg);
 	} else {
 		if (classFileOffset + 1 >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_fload;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_fload;
 		bCodeStream[classFileOffset++] = (byte) iArg;
 	}
 }
-final public void fload_0() {
+public void fload_0() {
 	if (DEBUG) System.out.println(position + "\t\tfload_0"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -1086,9 +1212,9 @@ final public void fload_0() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fload_0;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fload_0;
 }
-final public void fload_1() {
+public void fload_1() {
 	if (DEBUG) System.out.println(position + "\t\tfload_1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -1101,9 +1227,9 @@ final public void fload_1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fload_1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fload_1;
 }
-final public void fload_2() {
+public void fload_2() {
 	if (DEBUG) System.out.println(position + "\t\tfload_2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -1116,9 +1242,9 @@ final public void fload_2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fload_2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fload_2;
 }
-final public void fload_3() {
+public void fload_3() {
 	if (DEBUG) System.out.println(position + "\t\tfload_3"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -1131,9 +1257,9 @@ final public void fload_3() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fload_3;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fload_3;
 }
-final public void fmul() {
+public void fmul() {
 	if (DEBUG) System.out.println(position + "\t\tfmul"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -1141,18 +1267,18 @@ final public void fmul() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fmul;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fmul;
 }
-final public void fneg() {
+public void fneg() {
 	if (DEBUG) System.out.println(position + "\t\tfneg"); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fneg;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fneg;
 }
-final public void frem() {
+public void frem() {
 	if (DEBUG) System.out.println(position + "\t\tfrem"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -1160,9 +1286,9 @@ final public void frem() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_frem;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_frem;
 }
-final public void freturn() {
+public void freturn() {
 	if (DEBUG) System.out.println(position + "\t\tfreturn"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -1171,9 +1297,9 @@ final public void freturn() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_freturn;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_freturn;
 }
-final public void fstore(int iArg) {
+public void fstore(int iArg) {
 	if (DEBUG) System.out.println(position + "\t\tfstore:"+iArg); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -1185,19 +1311,19 @@ final public void fstore(int iArg) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_wide;
-		bCodeStream[classFileOffset++] = OPC_fstore;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_wide;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_fstore;
 		writeUnsignedShort(iArg);
 	} else {
 		if (classFileOffset + 1 >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_fstore;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_fstore;
 		bCodeStream[classFileOffset++] = (byte) iArg;
 	}
 }
-final public void fstore_0() {
+public void fstore_0() {
 	if (DEBUG) System.out.println(position + "\t\tfstore_0"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -1208,9 +1334,9 @@ final public void fstore_0() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fstore_0;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fstore_0;
 }
-final public void fstore_1() {
+public void fstore_1() {
 	if (DEBUG) System.out.println(position + "\t\tfstore_1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -1221,9 +1347,9 @@ final public void fstore_1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fstore_1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fstore_1;
 }
-final public void fstore_2() {
+public void fstore_2() {
 	if (DEBUG) System.out.println(position + "\t\tfstore_2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -1234,9 +1360,9 @@ final public void fstore_2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fstore_2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fstore_2;
 }
-final public void fstore_3() {
+public void fstore_3() {
 	if (DEBUG) System.out.println(position + "\t\tfstore_3"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -1247,9 +1373,10 @@ final public void fstore_3() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fstore_3;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fstore_3;
 }
-final public void fsub() {
+
+public void fsub() {
 	if (DEBUG) System.out.println(position + "\t\tfsub"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -1257,263 +1384,632 @@ final public void fsub() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_fsub;
-}
-/**
- * Macro for building a class descriptor object
- */
-public void generateClassLiteralAccessForType(TypeBinding accessedType, FieldBinding syntheticFieldBinding) {
-	Label endLabel;
-	ExceptionLabel anyExceptionHandler;
-	int saveStackSize;
-	if (accessedType.isBaseType() && accessedType != TypeBinding.NULL) {
-		this.getTYPE(accessedType.id);
-		return;
-	}
-
-	if (this.targetLevel >= ClassFileConstants.JDK1_5) {
-		// generation using the new ldc_w bytecode
-		this.ldc(accessedType);
-	} else {
-		endLabel = new Label(this);
-		if (syntheticFieldBinding != null) { // non interface case
-			this.getstatic(syntheticFieldBinding);
-			this.dup();
-			this.ifnonnull(endLabel);
-			this.pop();
-		}
-
-		/* Macro for building a class descriptor object... using or not a field cache to store it into...
-		this sequence is responsible for building the actual class descriptor.
-		
-		If the fieldCache is set, then it is supposed to be the body of a synthetic access method
-		factoring the actual descriptor creation out of the invocation site (saving space).
-		If the fieldCache is nil, then we are dumping the bytecode on the invocation site, since
-		we have no way to get a hand on the field cache to do better. */
-	
-	
-		// Wrap the code in an exception handler to convert a ClassNotFoundException into a NoClassDefError
-	
-		anyExceptionHandler = new ExceptionLabel(this, TypeBinding.NULL /* represents ClassNotFoundException*/);
-		this.ldc(accessedType == TypeBinding.NULL ? "java.lang.Object" : String.valueOf(accessedType.constantPoolName()).replace('/', '.')); //$NON-NLS-1$
-		this.invokeClassForName();
-	
-		/* See https://bugs.eclipse.org/bugs/show_bug.cgi?id=37565
-		if (accessedType == BaseTypes.NullBinding) {
-			this.ldc("java.lang.Object"); //$NON-NLS-1$
-		} else if (accessedType.isArrayType()) {
-			this.ldc(String.valueOf(accessedType.constantPoolName()).replace('/', '.'));
-		} else {
-			// we make it an array type (to avoid class initialization)
-			this.ldc("[L" + String.valueOf(accessedType.constantPoolName()).replace('/', '.') + ";"); //$NON-NLS-1$//$NON-NLS-2$
-		}
-		this.invokeClassForName();
-		if (!accessedType.isArrayType()) { // extract the component type, which doesn't initialize the class
-			this.invokeJavaLangClassGetComponentType();
-		}	
-		*/
-		/* We need to protect the runtime code from binary inconsistencies
-		in case the accessedType is missing, the ClassNotFoundException has to be converted
-		into a NoClassDefError(old ex message), we thus need to build an exception handler for this one. */
-		anyExceptionHandler.placeEnd();
-	
-		if (syntheticFieldBinding != null) { // non interface case
-			this.dup();
-			this.putstatic(syntheticFieldBinding);
-		}
-		this.goto_(endLabel);
-	
-	
-		// Generate the body of the exception handler
-		saveStackSize = stackDepth;
-		stackDepth = 1;
-		/* ClassNotFoundException on stack -- the class literal could be doing more things
-		on the stack, which means that the stack may not be empty at this point in the
-		above code gen. So we save its state and restart it from 1. */
-	
-		anyExceptionHandler.place();
-	
-		// Transform the current exception, and repush and throw a 
-		// NoClassDefFoundError(ClassNotFound.getMessage())
-	
-		this.newNoClassDefFoundError();
-		this.dup_x1();
-		this.swap();
-	
-		// Retrieve the message from the old exception
-		this.invokeThrowableGetMessage();
-	
-		// Send the constructor taking a message string as an argument
-		this.invokeNoClassDefFoundErrorStringConstructor();
-		this.athrow();
-		stackDepth = saveStackSize;
-		endLabel.place();
-	}
-}
-/**
- * This method generates the code attribute bytecode
- */
-final public void generateCodeAttributeForProblemMethod(String problemMessage) {
-	newJavaLangError();
-	dup();
-	ldc(problemMessage);
-	invokeJavaLangErrorConstructor();
-	athrow();
-}
-public void generateConstant(Constant constant, int implicitConversionCode) {
-	int targetTypeID = (implicitConversionCode & IMPLICIT_CONVERSION_MASK) >> 4;
-	if (targetTypeID != 0) {
-		switch (targetTypeID) {
-			case T_boolean :
-				generateInlinedValue(constant.booleanValue());
-				break;
-			case T_char :
-				generateInlinedValue(constant.charValue());
-				break;
-			case T_byte :
-				generateInlinedValue(constant.byteValue());
-				break;
-			case T_short :
-				generateInlinedValue(constant.shortValue());
-				break;
-			case T_int :
-				generateInlinedValue(constant.intValue());
-				break;
-			case T_long :
-				generateInlinedValue(constant.longValue());
-				break;
-			case T_float :
-				generateInlinedValue(constant.floatValue());
-				break;
-			case T_double :
-				generateInlinedValue(constant.doubleValue());
-				break;
-			case T_JavaLangString :
-				ldc(constant.stringValue());
-		}
-	} else {
-		ldc(constant.stringValue());
-	}
-	if ((implicitConversionCode & BOXING) != 0) {
-		// need boxing
-		generateBoxingConversion(targetTypeID);
-	}
+	bCodeStream[classFileOffset++] = Opcodes.OPC_fsub;
 }
-
-/**
- * Generates the sequence of instructions which will perform the conversion of the expression
- * on the stack into a different type (e.g. long l = someInt; --> i2l must be inserted).
- * @param implicitConversionCode int
- */
-public void generateImplicitConversion(int implicitConversionCode) {
-	if ((implicitConversionCode & UNBOXING) != 0) {
-		final int typeId = implicitConversionCode & COMPILE_TYPE_MASK;
-		generateUnboxingConversion(typeId);
-		// unboxing can further involve base type conversions
-	}
-	switch (implicitConversionCode & IMPLICIT_CONVERSION_MASK) {
-		case Float2Char :
-			this.f2i();
-			this.i2c();
-			break;
-		case Double2Char :
-			this.d2i();
-			this.i2c();
-			break;
-		case Int2Char :
-		case Short2Char :
-		case Byte2Char :
-			this.i2c();
-			break;
-		case Long2Char :
-			this.l2i();
-			this.i2c();
-			break;
-		case Char2Float :
-		case Short2Float :
-		case Int2Float :
-		case Byte2Float :
-			this.i2f();
-			break;
-		case Double2Float :
-			this.d2f();
-			break;
-		case Long2Float :
-			this.l2f();
-			break;
-		case Float2Byte :
+public void generateBoxingConversion(int unboxedTypeID) {
+    switch (unboxedTypeID) {
+        case TypeIds.T_byte :
+            if (this.targetLevel >= ClassFileConstants.JDK1_5) {
+    			if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Byte.valueOf(byte)"); //$NON-NLS-1$
+               // invokestatic: Byte.valueOf(byte)
+                this.invoke(
+                    Opcodes.OPC_invokestatic,
+                    1, // argCount
+                    1, // return type size
+                    ConstantPool.JavaLangByteConstantPoolName,
+                    ConstantPool.ValueOf,
+                    ConstantPool.byteByteSignature);
+            } else {
+               // new Byte( byte )
+    			if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Byte(byte)"); //$NON-NLS-1$
+                newWrapperFor(unboxedTypeID);
+                dup_x1();
+                swap();
+                this.invoke(
+                    Opcodes.OPC_invokespecial,
+                    1, // argCount
+                    0, // return type size
+                    ConstantPool.JavaLangByteConstantPoolName,
+                    ConstantPool.Init,
+                    ConstantPool.ByteConstrSignature);
+            }       
+            break;
+        case TypeIds.T_short :
+            if ( this.targetLevel >= ClassFileConstants.JDK1_5 ) {
+                // invokestatic: Short.valueOf(short)
+    			if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Short.valueOf(short)"); //$NON-NLS-1$
+                this.invoke(
+                    Opcodes.OPC_invokestatic,
+                    1, // argCount
+                    1, // return type size
+                    ConstantPool.JavaLangShortConstantPoolName,
+                    ConstantPool.ValueOf,
+                    ConstantPool.shortShortSignature);
+            } else {
+                // new Short(short)
+            	if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Short(short)"); //$NON-NLS-1$
+            	newWrapperFor(unboxedTypeID);                
+                dup_x1();
+                swap();             
+                this.invoke(
+                    Opcodes.OPC_invokespecial,
+                    1, // argCount
+                    0, // return type size
+                    ConstantPool.JavaLangShortConstantPoolName,
+                    ConstantPool.Init,
+                    ConstantPool.ShortConstrSignature);     
+            }
+            break;
+        case TypeIds.T_char :
+            if ( this.targetLevel >= ClassFileConstants.JDK1_5 ) {
+                // invokestatic: Character.valueOf(char)
+            	if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Character.valueOf(char)"); //$NON-NLS-1$
+                this.invoke(
+                    Opcodes.OPC_invokestatic,
+                    1, // argCount
+                    1, // return type size
+                    ConstantPool.JavaLangCharacterConstantPoolName,
+                    ConstantPool.ValueOf,
+                    ConstantPool.charCharacterSignature);
+            } else {
+                // new Char( char )
+            	if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Character(char)"); //$NON-NLS-1$
+                newWrapperFor(unboxedTypeID);
+                dup_x1();
+                swap();
+                this.invoke(
+                    Opcodes.OPC_invokespecial,
+                    1, // argCount
+                    0, // return type size
+                    ConstantPool.JavaLangCharacterConstantPoolName,
+                    ConstantPool.Init,
+                    ConstantPool.CharConstrSignature);
+            }       
+            break;
+        case TypeIds.T_int :             
+            if (this.targetLevel >= ClassFileConstants.JDK1_5) {
+                // invokestatic: Integer.valueOf(int)
+            	if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Integer.valueOf(int)"); //$NON-NLS-1$
+                this.invoke(
+                    Opcodes.OPC_invokestatic,
+                    1, // argCount
+                    1, // return type size
+                    ConstantPool.JavaLangIntegerConstantPoolName,
+                    ConstantPool.ValueOf,
+                    ConstantPool.IntIntegerSignature);
+            } else {
+                // new Integer(int)
+            	if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Integer(int)"); //$NON-NLS-1$
+                newWrapperFor(unboxedTypeID);
+                dup_x1();
+                swap();             
+                this.invoke(
+                    Opcodes.OPC_invokespecial,
+                    1, // argCount
+                    0, // return type size
+                    ConstantPool.JavaLangIntegerConstantPoolName,
+                    ConstantPool.Init,
+                    ConstantPool.IntConstrSignature);
+            }
+            break;
+        case TypeIds.T_long :
+            if (this.targetLevel >= ClassFileConstants.JDK1_5) { 
+                // invokestatic: Long.valueOf(long)
+            	if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Long.valueOf(long)"); //$NON-NLS-1$
+                this.invoke(
+                    Opcodes.OPC_invokestatic,
+                    2, // argCount
+                    1, // return type size
+                    ConstantPool.JavaLangLongConstantPoolName,
+                    ConstantPool.ValueOf,
+                    ConstantPool.longLongSignature);
+            } else {
+                // new Long( long )
+            	if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Long(long)"); //$NON-NLS-1$
+                newWrapperFor(unboxedTypeID);
+                dup_x2();
+                dup_x2();
+                pop();
+                this.invoke(
+                    Opcodes.OPC_invokespecial,
+                    2, // argCount
+                    0, // return type size
+                    ConstantPool.JavaLangLongConstantPoolName,
+                    ConstantPool.Init,
+                    ConstantPool.LongConstrSignature);
+            }                   
+            break;
+        case TypeIds.T_float :
+            if ( this.targetLevel >= ClassFileConstants.JDK1_5 ) {
+                // invokestatic: Float.valueOf(float)
+            	if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Float.valueOf(float)"); //$NON-NLS-1$
+                this.invoke(
+                    Opcodes.OPC_invokestatic,
+                    1, // argCount
+                    1, // return type size
+                    ConstantPool.JavaLangFloatConstantPoolName,
+                    ConstantPool.ValueOf,
+                    ConstantPool.floatFloatSignature);
+            } else {
+                // new Float(float)
+            	if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Float(float)"); //$NON-NLS-1$
+                newWrapperFor(unboxedTypeID);
+                dup_x1();
+                swap();             
+                this.invoke(
+                    Opcodes.OPC_invokespecial,
+                    1, // argCount
+                    0, // return type size
+                    ConstantPool.JavaLangFloatConstantPoolName,
+                    ConstantPool.Init,
+                    ConstantPool.FloatConstrSignature);
+            }       
+            break;
+        case TypeIds.T_double :
+            if ( this.targetLevel >= ClassFileConstants.JDK1_5 ) { 
+                // invokestatic: Double.valueOf(double)
+            	if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Double.valueOf(double)"); //$NON-NLS-1$
+                this.invoke(
+                    Opcodes.OPC_invokestatic,
+                    2, // argCount
+                    1, // return type size
+                    ConstantPool.JavaLangDoubleConstantPoolName,
+                    ConstantPool.ValueOf,
+                    ConstantPool.doubleDoubleSignature);
+            } else {
+                // new Double( double )
+            	if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Double(double)"); //$NON-NLS-1$
+            	newWrapperFor(unboxedTypeID);                
+                dup_x2();
+                dup_x2();
+                pop();
+                
+                this.invoke(
+                    Opcodes.OPC_invokespecial,
+                    2, // argCount
+                    0, // return type size
+                    ConstantPool.JavaLangDoubleConstantPoolName,
+                    ConstantPool.Init,
+                    ConstantPool.DoubleConstrSignature);
+            }       
+            
+            break;  
+        case TypeIds.T_boolean :
+            if ( this.targetLevel >= ClassFileConstants.JDK1_5 ) {
+                // invokestatic: Boolean.valueOf(boolean)
+            	if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Boolean.valueOf(boolean)"); //$NON-NLS-1$
+                this.invoke(
+                    Opcodes.OPC_invokestatic,
+                    1, // argCount
+                    1, // return type size
+                    ConstantPool.JavaLangBooleanConstantPoolName,
+                    ConstantPool.ValueOf,
+                    ConstantPool.booleanBooleanSignature);
+            } else {
+                // new Boolean(boolean)
+            	if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Boolean(boolean)"); //$NON-NLS-1$
+                newWrapperFor(unboxedTypeID);
+                dup_x1();
+                swap();             
+                this.invoke(
+                    Opcodes.OPC_invokespecial,
+                    1, // argCount
+                    0, // return type size
+                    ConstantPool.JavaLangBooleanConstantPoolName,
+                    ConstantPool.Init,
+                    ConstantPool.BooleanConstrSignature);
+            }
+    }
+}
+/**
+ * Macro for building a class descriptor object
+ */
+public void generateClassLiteralAccessForType(TypeBinding accessedType, FieldBinding syntheticFieldBinding) {
+	Label endLabel;
+	ExceptionLabel anyExceptionHandler;
+	int saveStackSize;
+	if (accessedType.isBaseType() && accessedType != TypeBinding.NULL) {
+		this.getTYPE(accessedType.id);
+		return;
+	}
+
+	if (this.targetLevel >= ClassFileConstants.JDK1_5) {
+		// generation using the new ldc_w bytecode
+		this.ldc(accessedType);
+	} else {
+		endLabel = new Label(this);
+		if (syntheticFieldBinding != null) { // non interface case
+			this.getstatic(syntheticFieldBinding);
+			this.dup();
+			this.ifnonnull(endLabel);
+			this.pop();
+		}
+
+		/* Macro for building a class descriptor object... using or not a field cache to store it into...
+		this sequence is responsible for building the actual class descriptor.
+		
+		If the fieldCache is set, then it is supposed to be the body of a synthetic access method
+		factoring the actual descriptor creation out of the invocation site (saving space).
+		If the fieldCache is nil, then we are dumping the bytecode on the invocation site, since
+		we have no way to get a hand on the field cache to do better. */
+	
+	
+		// Wrap the code in an exception handler to convert a ClassNotFoundException into a NoClassDefError
+	
+		anyExceptionHandler = new ExceptionLabel(this, TypeBinding.NULL /* represents ClassNotFoundException*/);
+		this.ldc(accessedType == TypeBinding.NULL ? "java.lang.Object" : String.valueOf(accessedType.constantPoolName()).replace('/', '.')); //$NON-NLS-1$
+		this.invokeClassForName();
+	
+		/* See https://bugs.eclipse.org/bugs/show_bug.cgi?id=37565
+		if (accessedType == BaseTypes.NullBinding) {
+			this.ldc("java.lang.Object"); //$NON-NLS-1$
+		} else if (accessedType.isArrayType()) {
+			this.ldc(String.valueOf(accessedType.constantPoolName()).replace('/', '.'));
+		} else {
+			// we make it an array type (to avoid class initialization)
+			this.ldc("[L" + String.valueOf(accessedType.constantPoolName()).replace('/', '.') + ";"); //$NON-NLS-1$//$NON-NLS-2$
+		}
+		this.invokeClassForName();
+		if (!accessedType.isArrayType()) { // extract the component type, which doesn't initialize the class
+			this.invokeJavaLangClassGetComponentType();
+		}	
+		*/
+		/* We need to protect the runtime code from binary inconsistencies
+		in case the accessedType is missing, the ClassNotFoundException has to be converted
+		into a NoClassDefError(old ex message), we thus need to build an exception handler for this one. */
+		anyExceptionHandler.placeEnd();
+	
+		if (syntheticFieldBinding != null) { // non interface case
+			this.dup();
+			this.putstatic(syntheticFieldBinding);
+		}
+		this.goto_(endLabel);
+	
+	
+		// Generate the body of the exception handler
+		saveStackSize = stackDepth;
+		stackDepth = 1;
+		/* ClassNotFoundException on stack -- the class literal could be doing more things
+		on the stack, which means that the stack may not be empty at this point in the
+		above code gen. So we save its state and restart it from 1. */
+	
+		anyExceptionHandler.place();
+	
+		// Transform the current exception, and repush and throw a 
+		// NoClassDefFoundError(ClassNotFound.getMessage())
+	
+		this.newNoClassDefFoundError();
+		this.dup_x1();
+		this.swap();
+	
+		// Retrieve the message from the old exception
+		this.invokeThrowableGetMessage();
+	
+		// Send the constructor taking a message string as an argument
+		this.invokeNoClassDefFoundErrorStringConstructor();
+		this.athrow();
+		stackDepth = saveStackSize;
+		endLabel.place();
+	}
+}
+/**
+ * This method generates the code attribute bytecode
+ */
+final public void generateCodeAttributeForProblemMethod(String problemMessage) {
+	newJavaLangError();
+	dup();
+	ldc(problemMessage);
+	invokeJavaLangErrorConstructor();
+	athrow();
+}
+public void generateConstant(Constant constant, int implicitConversionCode) {
+	int targetTypeID = (implicitConversionCode & TypeIds.IMPLICIT_CONVERSION_MASK) >> 4;
+	if (targetTypeID != 0) {
+		switch (targetTypeID) {
+			case TypeIds.T_boolean :
+				generateInlinedValue(constant.booleanValue());
+				break;
+			case TypeIds.T_char :
+				generateInlinedValue(constant.charValue());
+				break;
+			case TypeIds.T_byte :
+				generateInlinedValue(constant.byteValue());
+				break;
+			case TypeIds.T_short :
+				generateInlinedValue(constant.shortValue());
+				break;
+			case TypeIds.T_int :
+				generateInlinedValue(constant.intValue());
+				break;
+			case TypeIds.T_long :
+				generateInlinedValue(constant.longValue());
+				break;
+			case TypeIds.T_float :
+				generateInlinedValue(constant.floatValue());
+				break;
+			case TypeIds.T_double :
+				generateInlinedValue(constant.doubleValue());
+				break;
+			case TypeIds.T_JavaLangString :
+				ldc(constant.stringValue());
+		}
+	} else {
+		ldc(constant.stringValue());
+	}
+	if ((implicitConversionCode & TypeIds.BOXING) != 0) {
+		// need boxing
+		generateBoxingConversion(targetTypeID);
+	}
+}
+public void generateEmulatedReadAccessForField(FieldBinding fieldBinding) {
+	this.generateEmulationForField(fieldBinding);
+	// swap  the field with the receiver
+	this.swap();
+	this.invokeJavaLangReflectFieldGetter(fieldBinding.type.id);
+	if (!fieldBinding.type.isBaseType()) {
+		this.checkcast(fieldBinding.type);
+	}
+}
+public void generateEmulatedWriteAccessForField(FieldBinding fieldBinding) {
+	this.invokeJavaLangReflectFieldSetter(fieldBinding.type.id);
+}
+public void generateEmulationForConstructor(Scope scope, MethodBinding methodBinding) {
+	// leave a java.lang.reflect.Field object on the stack
+	this.ldc(String.valueOf(methodBinding.declaringClass.constantPoolName()).replace('/', '.'));
+	this.invokeClassForName();
+	int paramLength = methodBinding.parameters.length;
+	this.generateInlinedValue(paramLength);
+	this.newArray(scope.createArrayType(scope.getType(TypeConstants.JAVA_LANG_CLASS, 3), 1));
+	if (paramLength > 0) {
+		this.dup();
+		for (int i = 0; i < paramLength; i++) {
+			this.generateInlinedValue(i);	
+			TypeBinding parameter = methodBinding.parameters[i];
+			if (parameter.isBaseType()) {
+				this.getTYPE(parameter.id);
+			} else if (parameter.isArrayType()) {
+				ArrayBinding array = (ArrayBinding)parameter;
+				if (array.leafComponentType.isBaseType()) {
+					this.getTYPE(array.leafComponentType.id);
+				} else {
+					this.ldc(String.valueOf(array.leafComponentType.constantPoolName()).replace('/', '.'));
+					this.invokeClassForName();
+				}
+				int dimensions = array.dimensions;
+				this.generateInlinedValue(dimensions);
+				this.newarray(TypeIds.T_int);	
+				this.invokeArrayNewInstance();
+				this.invokeObjectGetClass();
+			} else {
+				// parameter is a reference binding
+				this.ldc(String.valueOf(methodBinding.declaringClass.constantPoolName()).replace('/', '.'));
+				this.invokeClassForName();
+			}
+			this.aastore();
+			if (i < paramLength - 1) {
+				this.dup();
+			}
+		}
+	}
+	this.invokeClassGetDeclaredConstructor();
+	this.dup();
+	this.iconst_1();
+	this.invokeAccessibleObjectSetAccessible();
+}
+public void generateEmulationForField(FieldBinding fieldBinding) {
+	// leave a java.lang.reflect.Field object on the stack
+	this.ldc(String.valueOf(fieldBinding.declaringClass.constantPoolName()).replace('/', '.'));
+	this.invokeClassForName();
+	this.ldc(String.valueOf(fieldBinding.name));
+	this.invokeClassGetDeclaredField();
+	this.dup();
+	this.iconst_1();
+	this.invokeAccessibleObjectSetAccessible();
+}
+public void generateEmulationForMethod(Scope scope, MethodBinding methodBinding) {
+	// leave a java.lang.reflect.Field object on the stack
+	this.ldc(String.valueOf(methodBinding.declaringClass.constantPoolName()).replace('/', '.'));
+	this.invokeClassForName();
+	this.ldc(String.valueOf(methodBinding.selector));
+	int paramLength = methodBinding.parameters.length;
+	this.generateInlinedValue(paramLength);
+	this.newArray(scope.createArrayType(scope.getType(TypeConstants.JAVA_LANG_CLASS, 3), 1));
+	if (paramLength > 0) {
+		this.dup();
+		for (int i = 0; i < paramLength; i++) {
+			this.generateInlinedValue(i);	
+			TypeBinding parameter = methodBinding.parameters[i];
+			if (parameter.isBaseType()) {
+				this.getTYPE(parameter.id);
+			} else if (parameter.isArrayType()) {
+				ArrayBinding array = (ArrayBinding)parameter;
+				if (array.leafComponentType.isBaseType()) {
+					this.getTYPE(array.leafComponentType.id);
+				} else {
+					this.ldc(String.valueOf(array.leafComponentType.constantPoolName()).replace('/', '.'));
+					this.invokeClassForName();
+				}
+				int dimensions = array.dimensions;
+				this.generateInlinedValue(dimensions);
+				this.newarray(TypeIds.T_int);	
+				this.invokeArrayNewInstance();
+				this.invokeObjectGetClass();
+			} else {
+				// parameter is a reference binding
+				this.ldc(String.valueOf(methodBinding.declaringClass.constantPoolName()).replace('/', '.'));
+				this.invokeClassForName();
+			}
+			this.aastore();
+			if (i < paramLength - 1) {
+				this.dup();
+			}
+		}
+	}
+	this.invokeClassGetDeclaredMethod();
+	this.dup();
+	this.iconst_1();
+	this.invokeAccessibleObjectSetAccessible();
+}
+private void generateFieldAccess(byte opcode, int returnTypeSize, char[] declaringClass, char[] name, char[] signature) {
+	countLabels = 0;
+	switch(opcode) {
+		case Opcodes.OPC_getfield :
+			if (returnTypeSize == 2) {
+				stackDepth++;
+			}
+			break;
+		case Opcodes.OPC_getstatic :
+			if (returnTypeSize == 2) {
+				stackDepth += 2;
+			} else {
+				stackDepth++;
+			}
+			break;
+		case Opcodes.OPC_putfield :
+			if (returnTypeSize == 2) {
+				stackDepth -= 3;
+			} else {
+				stackDepth -= 2;
+			}
+			break;
+		case Opcodes.OPC_putstatic :
+			if (returnTypeSize == 2) {
+				stackDepth -= 2;
+			} else {
+				stackDepth--;
+			}
+	}
+	if (stackDepth > stackMax) {
+		stackMax = stackDepth;
+	}
+	if (classFileOffset + 2 >= bCodeStream.length) {
+		resizeByteArray();
+	}
+	position++;
+	bCodeStream[classFileOffset++] = opcode;
+	writeUnsignedShort(constantPool.literalIndexForField(declaringClass, name, signature));
+}
+/**
+ * Generates the sequence of instructions which will perform the conversion of the expression
+ * on the stack into a different type (e.g. long l = someInt; --> i2l must be inserted).
+ * @param implicitConversionCode int
+ */
+public void generateImplicitConversion(int implicitConversionCode) {
+	if ((implicitConversionCode & TypeIds.UNBOXING) != 0) {
+		final int typeId = implicitConversionCode & TypeIds.COMPILE_TYPE_MASK;
+		generateUnboxingConversion(typeId);
+		// unboxing can further involve base type conversions
+	}
+	switch (implicitConversionCode & TypeIds.IMPLICIT_CONVERSION_MASK) {
+		case TypeIds.Float2Char :
+			this.f2i();
+			this.i2c();
+			break;
+		case TypeIds.Double2Char :
+			this.d2i();
+			this.i2c();
+			break;
+		case TypeIds.Int2Char :
+		case TypeIds.Short2Char :
+		case TypeIds.Byte2Char :
+			this.i2c();
+			break;
+		case TypeIds.Long2Char :
+			this.l2i();
+			this.i2c();
+			break;
+		case TypeIds.Char2Float :
+		case TypeIds.Short2Float :
+		case TypeIds.Int2Float :
+		case TypeIds.Byte2Float :
+			this.i2f();
+			break;
+		case TypeIds.Double2Float :
+			this.d2f();
+			break;
+		case TypeIds.Long2Float :
+			this.l2f();
+			break;
+		case TypeIds.Float2Byte :
 			this.f2i();
 			this.i2b();
 			break;
-		case Double2Byte :
+		case TypeIds.Double2Byte :
 			this.d2i();
 			this.i2b();
 			break;
-		case Int2Byte :
-		case Short2Byte :
-		case Char2Byte :
+		case TypeIds.Int2Byte :
+		case TypeIds.Short2Byte :
+		case TypeIds.Char2Byte :
 			this.i2b();
 			break;
-		case Long2Byte :
+		case TypeIds.Long2Byte :
 			this.l2i();
 			this.i2b();
 			break;
-		case Byte2Double :
-		case Char2Double :
-		case Short2Double :
-		case Int2Double :
+		case TypeIds.Byte2Double :
+		case TypeIds.Char2Double :
+		case TypeIds.Short2Double :
+		case TypeIds.Int2Double :
 			this.i2d();
 			break;
-		case Float2Double :
+		case TypeIds.Float2Double :
 			this.f2d();
 			break;
-		case Long2Double :
+		case TypeIds.Long2Double :
 			this.l2d();
 			break;
-		case Byte2Short :
-		case Char2Short :
-		case Int2Short :
+		case TypeIds.Byte2Short :
+		case TypeIds.Char2Short :
+		case TypeIds.Int2Short :
 			this.i2s();
 			break;
-		case Double2Short :
+		case TypeIds.Double2Short :
 			this.d2i();
 			this.i2s();
 			break;
-		case Long2Short :
+		case TypeIds.Long2Short :
 			this.l2i();
 			this.i2s();
 			break;
-		case Float2Short :
+		case TypeIds.Float2Short :
 			this.f2i();
 			this.i2s();
 			break;
-		case Double2Int :
+		case TypeIds.Double2Int :
 			this.d2i();
 			break;
-		case Float2Int :
+		case TypeIds.Float2Int :
 			this.f2i();
 			break;
-		case Long2Int :
+		case TypeIds.Long2Int :
 			this.l2i();
 			break;
-		case Int2Long :
-		case Char2Long :
-		case Byte2Long :
-		case Short2Long :
+		case TypeIds.Int2Long :
+		case TypeIds.Char2Long :
+		case TypeIds.Byte2Long :
+		case TypeIds.Short2Long :
 			this.i2l();
 			break;
-		case Double2Long :
+		case TypeIds.Double2Long :
 			this.d2l();
 			break;
-		case Float2Long :
+		case TypeIds.Float2Long :
 			this.f2l();
 	}
-	if ((implicitConversionCode & BOXING) != 0) {
+	if ((implicitConversionCode & TypeIds.BOXING) != 0) {
 		// need to unbox/box the constant
-		final int typeId = (implicitConversionCode & IMPLICIT_CONVERSION_MASK) >> 4;
+		final int typeId = (implicitConversionCode & TypeIds.IMPLICIT_CONVERSION_MASK) >> 4;
 		generateBoxingConversion(typeId);
 	}
 }
+public void generateInlinedValue(boolean inlinedValue) {
+	if (inlinedValue)
+		this.iconst_1();
+	else
+		this.iconst_0();
+}
+
 public void generateInlinedValue(byte inlinedValue) {
 	switch (inlinedValue) {
 		case -1 :
@@ -1544,6 +2040,7 @@ public void generateInlinedValue(byte inlinedValue) {
 			}
 	}
 }
+
 public void generateInlinedValue(char inlinedValue) {
 	switch (inlinedValue) {
 		case 0 :
@@ -1685,12 +2182,6 @@ public void generateInlinedValue(short inlinedValue) {
 			this.sipush(inlinedValue);
 	}
 }
-public void generateInlinedValue(boolean inlinedValue) {
-	if (inlinedValue)
-		this.iconst_1();
-	else
-		this.iconst_0();
-}
 public void generateOuterAccess(Object[] mappingSequence, ASTNode invocationSite, Binding target, Scope scope) {
 	if (mappingSequence == null) {
 		if (target instanceof LocalVariableBinding) {
@@ -1733,23 +2224,23 @@ public void generateReturnBytecode(Expression expression) {
 		this.return_();
 	} else {
 		final int implicitConversion = expression.implicitConversion;
-		if ((implicitConversion & BOXING) != 0) {
+		if ((implicitConversion & TypeIds.BOXING) != 0) {
 			this.areturn();
 			return;
 		}
-		int runtimeType = (implicitConversion & IMPLICIT_CONVERSION_MASK) >> 4;
+		int runtimeType = (implicitConversion & TypeIds.IMPLICIT_CONVERSION_MASK) >> 4;
 		switch (runtimeType) {
-			case T_boolean :
-			case T_int :
+			case TypeIds.T_boolean :
+			case TypeIds.T_int :
 				this.ireturn();
 				break;
-			case T_float :
+			case TypeIds.T_float :
 				this.freturn();
 				break;
-			case T_long :
+			case TypeIds.T_long :
 				this.lreturn();
 				break;
-			case T_double :
+			case TypeIds.T_double :
 				this.dreturn();
 				break;
 			default :
@@ -1774,103 +2265,19 @@ public void generateStringConcatenationAppend(BlockScope blockScope, Expression
 		this.swap();
 		// If argument is reference type, need to transform it 
 		// into a string (handles null case)
-		this.invokeStringValueOf(T_JavaLangObject);
+		this.invokeStringValueOf(TypeIds.T_JavaLangObject);
 		this.invokeStringConcatenationStringConstructor();
 	} else {
 		pc = position;
-		oper1.generateOptimizedStringConcatenationCreation(blockScope, this, oper1.implicitConversion & COMPILE_TYPE_MASK);
+		oper1.generateOptimizedStringConcatenationCreation(blockScope, this, oper1.implicitConversion & TypeIds.COMPILE_TYPE_MASK);
 		this.recordPositionsFrom(pc, oper1.sourceStart);
 	}
 	pc = position;
-	oper2.generateOptimizedStringConcatenation(blockScope, this, oper2.implicitConversion & COMPILE_TYPE_MASK);
+	oper2.generateOptimizedStringConcatenation(blockScope, this, oper2.implicitConversion & TypeIds.COMPILE_TYPE_MASK);
 	this.recordPositionsFrom(pc, oper2.sourceStart);
 	this.invokeStringConcatenationToString();
 }
 /**
- * Code responsible to generate the suitable code to supply values for the synthetic enclosing
- * instance arguments of a constructor invocation of a nested type.
- */
-public void generateSyntheticEnclosingInstanceValues(
-		BlockScope currentScope, 
-		ReferenceBinding targetType, 
-		Expression enclosingInstance, 
-		ASTNode invocationSite) {
-
-	// supplying enclosing instance for the anonymous type's superclass
-	ReferenceBinding checkedTargetType = targetType.isAnonymousType() ? (ReferenceBinding)targetType.superclass().erasure() : targetType;
-	boolean hasExtraEnclosingInstance = enclosingInstance != null;
-	if (hasExtraEnclosingInstance 
-			&& (!checkedTargetType.isNestedType() || checkedTargetType.isStatic())) {
-		currentScope.problemReporter().unnecessaryEnclosingInstanceSpecification(enclosingInstance, checkedTargetType);
-		return;
-	}
-
-	// perform some emulation work in case there is some and we are inside a local type only
-	ReferenceBinding[] syntheticArgumentTypes;
-	if ((syntheticArgumentTypes = targetType.syntheticEnclosingInstanceTypes()) != null) {
-
-		ReferenceBinding targetEnclosingType = checkedTargetType.enclosingType();
-		long compliance = currentScope.compilerOptions().complianceLevel;
-
-		// deny access to enclosing instance argument for allocation and super constructor call (if 1.4)
-		// always consider it if complying to 1.5
-		boolean denyEnclosingArgInConstructorCall;
-		if (compliance <= ClassFileConstants.JDK1_3) {
-			denyEnclosingArgInConstructorCall = invocationSite instanceof AllocationExpression;
-		} else if (compliance == ClassFileConstants.JDK1_4){
-			denyEnclosingArgInConstructorCall = invocationSite instanceof AllocationExpression
-				|| invocationSite instanceof ExplicitConstructorCall && ((ExplicitConstructorCall)invocationSite).isSuperAccess();
-		} else {
-			//compliance >= JDK1_5
-			denyEnclosingArgInConstructorCall = (invocationSite instanceof AllocationExpression
-					|| invocationSite instanceof ExplicitConstructorCall && ((ExplicitConstructorCall)invocationSite).isSuperAccess()) 
-				&& !targetType.isLocalType();
-		}
-		
-		boolean complyTo14 = compliance >= ClassFileConstants.JDK1_4;
-		for (int i = 0, max = syntheticArgumentTypes.length; i < max; i++) {
-			ReferenceBinding syntheticArgType = syntheticArgumentTypes[i];
-			if (hasExtraEnclosingInstance && syntheticArgType == targetEnclosingType) {
-				hasExtraEnclosingInstance = false;
-				enclosingInstance.generateCode(currentScope, this, true);
-				if (complyTo14){
-					dup();
-					invokeObjectGetClass(); // will perform null check
-					pop();
-				}
-			} else {
-				Object[] emulationPath = currentScope.getEmulationPath(
-						syntheticArgType, 
-						false /*not only exact match (that is, allow compatible)*/,
-						denyEnclosingArgInConstructorCall);
-				this.generateOuterAccess(emulationPath, invocationSite, syntheticArgType, currentScope);
-			}
-		}
-		if (hasExtraEnclosingInstance){
-			currentScope.problemReporter().unnecessaryEnclosingInstanceSpecification(enclosingInstance, checkedTargetType);
-		}
-	}
-}
-
-/**
- * Code responsible to generate the suitable code to supply values for the synthetic outer local
- * variable arguments of a constructor invocation of a nested type.
- * (bug 26122) - synthetic values for outer locals must be passed after user arguments, e.g. new X(i = 1){}
- */
-public void generateSyntheticOuterArgumentValues(BlockScope currentScope, ReferenceBinding targetType, ASTNode invocationSite) {
-
-	// generate the synthetic outer arguments then
-	SyntheticArgumentBinding syntheticArguments[];
-	if ((syntheticArguments = targetType.syntheticOuterLocalVariables()) != null) {
-		for (int i = 0, max = syntheticArguments.length; i < max; i++) {
-			LocalVariableBinding targetVariable = syntheticArguments[i].actualOuterLocalVariable;
-			VariableBinding[] emulationPath = currentScope.getEmulationPath(targetVariable);
-			this.generateOuterAccess(emulationPath, invocationSite, targetVariable, currentScope);
-		}
-	}
-}
-
-/**
  * @param accessBinding the access method binding to generate
  */
 public void generateSyntheticBodyForConstructorAccess(SyntheticMethodBinding accessBinding) {
@@ -1884,7 +2291,7 @@ public void generateSyntheticBodyForConstructorAccess(SyntheticMethodBinding acc
 	this.aload_0();
 	// special name&ordinal argument generation for enum constructors
 	TypeBinding declaringClass = constructorBinding.declaringClass;
-	if (declaringClass.erasure().id == T_JavaLangEnum || declaringClass.isEnum()) {
+	if (declaringClass.erasure().id == TypeIds.T_JavaLangEnum || declaringClass.isEnum()) {
 		this.aload_1(); // pass along name param as name arg
 		this.iload_2(); // pass along ordinal param as ordinal arg
         resolvedPosition += 2;
@@ -1924,36 +2331,6 @@ public void generateSyntheticBodyForConstructorAccess(SyntheticMethodBinding acc
 	this.invokespecial(constructorBinding);
 	this.return_();
 }
-//static X[] values() {
-// X[] values;
-// int length;
-// X[] result;
-// System.arraycopy(values = $VALUES, 0, result = new X[length= values.length], 0, length)
-// return result;
-//}
-public void generateSyntheticBodyForEnumValues(SyntheticMethodBinding methodBinding) {
-	ClassScope scope = ((SourceTypeBinding)methodBinding.declaringClass).scope;
-	FieldBinding enumValuesSyntheticfield = scope.referenceContext.enumValuesSyntheticfield;
-	initializeMaxLocals(methodBinding);
-	TypeBinding enumArray = methodBinding.returnType;
-	
-	this.getstatic(enumValuesSyntheticfield);
-	this.dup();
-	this.astore_0();
-	this.iconst_0();
-	this.aload_0();
-	this.arraylength();
-	this.dup();
-	this.istore_1();
-	this.newArray((ArrayBinding) enumArray);
-	this.dup();
-	this.astore_2();
-	this.iconst_0();
-	this.iload_1();
-	this.invokeSystemArraycopy();
-	this.aload_2();
-	this.areturn();
-}
 //static X valueOf(String name) {
 // X[] values;
 // for (int i = (values = $VALUES).length; --i >= 0;) {
@@ -1999,56 +2376,35 @@ public void generateSyntheticBodyForEnumValueOf(SyntheticMethodBinding methodBin
 	this.invokeJavaLangIllegalArgumentExceptionStringConstructor();
 	this.athrow();
 }
-public void generateSyntheticBodyForSwitchTable(SyntheticMethodBinding methodBinding) {
-	ClassScope scope = ((SourceTypeBinding)methodBinding.declaringClass).scope;
-	initializeMaxLocals(methodBinding);
-	final Label nullLabel = new Label(this);
-	FieldBinding syntheticFieldBinding = methodBinding.targetReadField;
-
-	this.getstatic(syntheticFieldBinding);
-	this.dup();
-	this.ifnull(nullLabel);
-	final int stackSizeForIf = this.stackDepth;
-	this.areturn();
-	nullLabel.place();
-	this.stackDepth = stackSizeForIf;
-	this.pop();
-	ReferenceBinding enumBinding = (ReferenceBinding) methodBinding.targetEnumType;
-	char[] signature = "()".toCharArray(); //$NON-NLS-1$
-	ArrayBinding arrayBinding = scope.createArrayType(enumBinding, 1);
-	signature = CharOperation.concat(signature, arrayBinding.constantPoolName());
-	this.invoke(OPC_invokestatic, 0, 1, enumBinding.constantPoolName(), TypeConstants.VALUES, signature);
-	this.arraylength();
-	this.newarray(ClassFileConstants.INT_ARRAY);
+//static X[] values() {
+// X[] values;
+// int length;
+// X[] result;
+// System.arraycopy(values = $VALUES, 0, result = new X[length= values.length], 0, length)
+// return result;
+//}
+public void generateSyntheticBodyForEnumValues(SyntheticMethodBinding methodBinding) {
+	ClassScope scope = ((SourceTypeBinding)methodBinding.declaringClass).scope;
+	FieldBinding enumValuesSyntheticfield = scope.referenceContext.enumValuesSyntheticfield;
+	initializeMaxLocals(methodBinding);
+	TypeBinding enumArray = methodBinding.returnType;
+	
+	this.getstatic(enumValuesSyntheticfield);
+	this.dup();
 	this.astore_0();
-	final FieldBinding[] fields = enumBinding.fields();
-	if (fields != null) {
-		for (int i = 0, max = fields.length; i < max; i++) {
-			FieldBinding fieldBinding = fields[i];
-			if ((fieldBinding.getAccessFlags() & ClassFileConstants.AccEnum) != 0) {
-				final Label endLabel = new Label(this);
-				final ExceptionLabel anyExceptionHandler = new ExceptionLabel(this, TypeBinding.LONG /* represents NoSuchFieldError*/);
-				this.aload_0();
-				this.getstatic(fieldBinding);
-				this.invokeEnumOrdinal(enumBinding.constantPoolName());
-				this.generateInlinedValue(fieldBinding.id);
-				this.iastore();
-				anyExceptionHandler.placeEnd();
-				this.goto_(endLabel);
-				// Generate the body of the exception handler
-				final int saveStackSize = stackDepth;
-				stackDepth = 1;
-				anyExceptionHandler.place();
-				this.pop(); // we don't use it so we can pop it
-				stackDepth = saveStackSize;
-				endLabel.place();				
-			}
-		}
-	}
+	this.iconst_0();
 	this.aload_0();
+	this.arraylength();
 	this.dup();
-	this.putstatic(syntheticFieldBinding);
-	areturn();
+	this.istore_1();
+	this.newArray((ArrayBinding) enumArray);
+	this.dup();
+	this.astore_2();
+	this.iconst_0();
+	this.iload_1();
+	this.invokeSystemArraycopy();
+	this.aload_2();
+	this.areturn();
 }
 public void generateSyntheticBodyForFieldReadAccess(SyntheticMethodBinding accessBinding) {
 	initializeMaxLocals(accessBinding);
@@ -2063,20 +2419,20 @@ public void generateSyntheticBodyForFieldReadAccess(SyntheticMethodBinding acces
 //		case T_void :
 //			this.return_();
 //			break;
-		case T_boolean :
-		case T_byte :
-		case T_char :
-		case T_short :
-		case T_int :
+		case TypeIds.T_boolean :
+		case TypeIds.T_byte :
+		case TypeIds.T_char :
+		case TypeIds.T_short :
+		case TypeIds.T_int :
 			this.ireturn();
 			break;
-		case T_long :
+		case TypeIds.T_long :
 			this.lreturn();
 			break;
-		case T_float :
+		case TypeIds.T_float :
 			this.freturn();
 			break;
-		case T_double :
+		case TypeIds.T_double :
 			this.dreturn();
 			break;
 		default :
@@ -2144,23 +2500,23 @@ public void generateSyntheticBodyForMethodAccess(SyntheticMethodBinding accessMe
 		}
 	}
 	switch (targetMethod.returnType.id) {
-		case T_void :
+		case TypeIds.T_void :
 			this.return_();
 			break;
-		case T_boolean :
-		case T_byte :
-		case T_char :
-		case T_short :
-		case T_int :
+		case TypeIds.T_boolean :
+		case TypeIds.T_byte :
+		case TypeIds.T_char :
+		case TypeIds.T_short :
+		case TypeIds.T_int :
 			this.ireturn();
 			break;
-		case T_long :
+		case TypeIds.T_long :
 			this.lreturn();
 			break;
-		case T_float :
+		case TypeIds.T_float :
 			this.freturn();
 			break;
-		case T_double :
+		case TypeIds.T_double :
 			this.dreturn();
 			break;
 		default :
@@ -2170,297 +2526,312 @@ public void generateSyntheticBodyForMethodAccess(SyntheticMethodBinding accessMe
 			this.areturn();
 	}
 }
-public void generateBoxingConversion(int unboxedTypeID) {
-    switch (unboxedTypeID) {
-        case T_byte :
-            if (this.targetLevel >= ClassFileConstants.JDK1_5) {
-    			if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Byte.valueOf(byte)"); //$NON-NLS-1$
-               // invokestatic: Byte.valueOf(byte)
-                this.invoke(
-                    OPC_invokestatic,
-                    1, // argCount
-                    1, // return type size
-                    ConstantPool.JavaLangByteConstantPoolName,
-                    ConstantPool.ValueOf,
-                    ConstantPool.byteByteSignature);
-            } else {
-               // new Byte( byte )
-    			if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Byte(byte)"); //$NON-NLS-1$
-                newWrapperFor(unboxedTypeID);
-                dup_x1();
-                swap();
-                this.invoke(
-                    OPC_invokespecial,
-                    1, // argCount
-                    0, // return type size
-                    ConstantPool.JavaLangByteConstantPoolName,
-                    ConstantPool.Init,
-                    ConstantPool.ByteConstrSignature);
-            }       
-            break;
-        case T_short :
-            if ( this.targetLevel >= ClassFileConstants.JDK1_5 ) {
-                // invokestatic: Short.valueOf(short)
-    			if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Short.valueOf(short)"); //$NON-NLS-1$
-                this.invoke(
-                    OPC_invokestatic,
-                    1, // argCount
-                    1, // return type size
-                    ConstantPool.JavaLangShortConstantPoolName,
-                    ConstantPool.ValueOf,
-                    ConstantPool.shortShortSignature);
-            } else {
-                // new Short(short)
-            	if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Short(short)"); //$NON-NLS-1$
-            	newWrapperFor(unboxedTypeID);                
-                dup_x1();
-                swap();             
-                this.invoke(
-                    OPC_invokespecial,
-                    1, // argCount
-                    0, // return type size
-                    ConstantPool.JavaLangShortConstantPoolName,
-                    ConstantPool.Init,
-                    ConstantPool.ShortConstrSignature);     
-            }
-            break;
-        case T_char :
-            if ( this.targetLevel >= ClassFileConstants.JDK1_5 ) {
-                // invokestatic: Character.valueOf(char)
-            	if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Character.valueOf(char)"); //$NON-NLS-1$
-                this.invoke(
-                    OPC_invokestatic,
-                    1, // argCount
-                    1, // return type size
-                    ConstantPool.JavaLangCharacterConstantPoolName,
-                    ConstantPool.ValueOf,
-                    ConstantPool.charCharacterSignature);
-            } else {
-                // new Char( char )
-            	if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Character(char)"); //$NON-NLS-1$
-                newWrapperFor(unboxedTypeID);
-                dup_x1();
-                swap();
-                this.invoke(
-                    OPC_invokespecial,
-                    1, // argCount
-                    0, // return type size
-                    ConstantPool.JavaLangCharacterConstantPoolName,
-                    ConstantPool.Init,
-                    ConstantPool.CharConstrSignature);
-            }       
-            break;
-        case T_int :             
-            if (this.targetLevel >= ClassFileConstants.JDK1_5) {
-                // invokestatic: Integer.valueOf(int)
-            	if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Integer.valueOf(int)"); //$NON-NLS-1$
-                this.invoke(
-                    OPC_invokestatic,
-                    1, // argCount
-                    1, // return type size
-                    ConstantPool.JavaLangIntegerConstantPoolName,
-                    ConstantPool.ValueOf,
-                    ConstantPool.IntIntegerSignature);
-            } else {
-                // new Integer(int)
-            	if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Integer(int)"); //$NON-NLS-1$
-                newWrapperFor(unboxedTypeID);
-                dup_x1();
-                swap();             
-                this.invoke(
-                    OPC_invokespecial,
-                    1, // argCount
-                    0, // return type size
-                    ConstantPool.JavaLangIntegerConstantPoolName,
-                    ConstantPool.Init,
-                    ConstantPool.IntConstrSignature);
-            }
-            break;
-        case T_long :
-            if (this.targetLevel >= ClassFileConstants.JDK1_5) { 
-                // invokestatic: Long.valueOf(long)
-            	if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Long.valueOf(long)"); //$NON-NLS-1$
-                this.invoke(
-                    OPC_invokestatic,
-                    2, // argCount
-                    1, // return type size
-                    ConstantPool.JavaLangLongConstantPoolName,
-                    ConstantPool.ValueOf,
-                    ConstantPool.longLongSignature);
-            } else {
-                // new Long( long )
-            	if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Long(long)"); //$NON-NLS-1$
-                newWrapperFor(unboxedTypeID);
-                dup_x2();
-                dup_x2();
-                pop();
-                this.invoke(
-                    OPC_invokespecial,
-                    2, // argCount
-                    0, // return type size
-                    ConstantPool.JavaLangLongConstantPoolName,
-                    ConstantPool.Init,
-                    ConstantPool.LongConstrSignature);
-            }                   
-            break;
-        case T_float :
-            if ( this.targetLevel >= ClassFileConstants.JDK1_5 ) {
-                // invokestatic: Float.valueOf(float)
-            	if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Float.valueOf(float)"); //$NON-NLS-1$
-                this.invoke(
-                    OPC_invokestatic,
-                    1, // argCount
-                    1, // return type size
-                    ConstantPool.JavaLangFloatConstantPoolName,
-                    ConstantPool.ValueOf,
-                    ConstantPool.floatFloatSignature);
-            } else {
-                // new Float(float)
-            	if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Float(float)"); //$NON-NLS-1$
-                newWrapperFor(unboxedTypeID);
-                dup_x1();
-                swap();             
-                this.invoke(
-                    OPC_invokespecial,
-                    1, // argCount
-                    0, // return type size
-                    ConstantPool.JavaLangFloatConstantPoolName,
-                    ConstantPool.Init,
-                    ConstantPool.FloatConstrSignature);
-            }       
-            break;
-        case T_double :
-            if ( this.targetLevel >= ClassFileConstants.JDK1_5 ) { 
-                // invokestatic: Double.valueOf(double)
-            	if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Double.valueOf(double)"); //$NON-NLS-1$
-                this.invoke(
-                    OPC_invokestatic,
-                    2, // argCount
-                    1, // return type size
-                    ConstantPool.JavaLangDoubleConstantPoolName,
-                    ConstantPool.ValueOf,
-                    ConstantPool.doubleDoubleSignature);
-            } else {
-                // new Double( double )
-            	if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Double(double)"); //$NON-NLS-1$
-            	newWrapperFor(unboxedTypeID);                
-                dup_x2();
-                dup_x2();
-                pop();
-                
-                this.invoke(
-                    OPC_invokespecial,
-                    2, // argCount
-                    0, // return type size
-                    ConstantPool.JavaLangDoubleConstantPoolName,
-                    ConstantPool.Init,
-                    ConstantPool.DoubleConstrSignature);
-            }       
-            
-            break;  
-        case T_boolean :
-            if ( this.targetLevel >= ClassFileConstants.JDK1_5 ) {
-                // invokestatic: Boolean.valueOf(boolean)
-            	if (DEBUG) System.out.println(position + "\t\tinvokestatic java.lang.Boolean.valueOf(boolean)"); //$NON-NLS-1$
-                this.invoke(
-                    OPC_invokestatic,
-                    1, // argCount
-                    1, // return type size
-                    ConstantPool.JavaLangBooleanConstantPoolName,
-                    ConstantPool.ValueOf,
-                    ConstantPool.booleanBooleanSignature);
-            } else {
-                // new Boolean(boolean)
-            	if (DEBUG) System.out.println(position + "\t\tinvokespecial java.lang.Boolean(boolean)"); //$NON-NLS-1$
-                newWrapperFor(unboxedTypeID);
-                dup_x1();
-                swap();             
-                this.invoke(
-                    OPC_invokespecial,
-                    1, // argCount
-                    0, // return type size
-                    ConstantPool.JavaLangBooleanConstantPoolName,
-                    ConstantPool.Init,
-                    ConstantPool.BooleanConstrSignature);
-            }
-    }
+public void generateSyntheticBodyForSwitchTable(SyntheticMethodBinding methodBinding) {
+	ClassScope scope = ((SourceTypeBinding)methodBinding.declaringClass).scope;
+	initializeMaxLocals(methodBinding);
+	final Label nullLabel = new Label(this);
+	FieldBinding syntheticFieldBinding = methodBinding.targetReadField;
+
+	this.getstatic(syntheticFieldBinding);
+	this.dup();
+	this.ifnull(nullLabel);
+	this.areturn();
+	this.pushOnStack(syntheticFieldBinding.type);
+	nullLabel.place();
+	this.pop();
+	ReferenceBinding enumBinding = (ReferenceBinding) methodBinding.targetEnumType;
+	ArrayBinding arrayBinding = scope.createArrayType(enumBinding, 1);
+	this.invokeJavaLangEnumValues(enumBinding, arrayBinding);
+	this.arraylength();
+	this.newarray(ClassFileConstants.INT_ARRAY);
+	this.astore_0();
+	final FieldBinding[] fields = enumBinding.fields();
+	if (fields != null) {
+		for (int i = 0, max = fields.length; i < max; i++) {
+			FieldBinding fieldBinding = fields[i];
+			if ((fieldBinding.getAccessFlags() & ClassFileConstants.AccEnum) != 0) {
+				final Label endLabel = new Label(this);
+				final ExceptionLabel anyExceptionHandler = new ExceptionLabel(this, TypeBinding.LONG /* represents NoSuchFieldError*/);
+				this.aload_0();
+				this.getstatic(fieldBinding);
+				this.invokeEnumOrdinal(enumBinding.constantPoolName());
+				this.generateInlinedValue(fieldBinding.id);
+				this.iastore();
+				anyExceptionHandler.placeEnd();
+				this.goto_(endLabel);
+				// Generate the body of the exception handler
+				this.pushOnStack(scope.getJavaLangThrowable());
+				anyExceptionHandler.place();
+				this.pop(); // we don't use it so we can pop it
+				endLabel.place();				
+			}
+		}
+	}
+	this.aload_0();
+	this.dup();
+	this.putstatic(syntheticFieldBinding);
+	areturn();
+}
+/**
+ * Code responsible to generate the suitable code to supply values for the synthetic enclosing
+ * instance arguments of a constructor invocation of a nested type.
+ */
+public void generateSyntheticEnclosingInstanceValues(
+		BlockScope currentScope, 
+		ReferenceBinding targetType, 
+		Expression enclosingInstance, 
+		ASTNode invocationSite) {
+
+	// supplying enclosing instance for the anonymous type's superclass
+	ReferenceBinding checkedTargetType = targetType.isAnonymousType() ? (ReferenceBinding)targetType.superclass().erasure() : targetType;
+	boolean hasExtraEnclosingInstance = enclosingInstance != null;
+	if (hasExtraEnclosingInstance 
+			&& (!checkedTargetType.isNestedType() || checkedTargetType.isStatic())) {
+		currentScope.problemReporter().unnecessaryEnclosingInstanceSpecification(enclosingInstance, checkedTargetType);
+		return;
+	}
+
+	// perform some emulation work in case there is some and we are inside a local type only
+	ReferenceBinding[] syntheticArgumentTypes;
+	if ((syntheticArgumentTypes = targetType.syntheticEnclosingInstanceTypes()) != null) {
+
+		ReferenceBinding targetEnclosingType = checkedTargetType.enclosingType();
+		long compliance = currentScope.compilerOptions().complianceLevel;
+
+		// deny access to enclosing instance argument for allocation and super constructor call (if 1.4)
+		// always consider it if complying to 1.5
+		boolean denyEnclosingArgInConstructorCall;
+		if (compliance <= ClassFileConstants.JDK1_3) {
+			denyEnclosingArgInConstructorCall = invocationSite instanceof AllocationExpression;
+		} else if (compliance == ClassFileConstants.JDK1_4){
+			denyEnclosingArgInConstructorCall = invocationSite instanceof AllocationExpression
+				|| invocationSite instanceof ExplicitConstructorCall && ((ExplicitConstructorCall)invocationSite).isSuperAccess();
+		} else {
+			//compliance >= JDK1_5
+			denyEnclosingArgInConstructorCall = (invocationSite instanceof AllocationExpression
+					|| invocationSite instanceof ExplicitConstructorCall && ((ExplicitConstructorCall)invocationSite).isSuperAccess()) 
+				&& !targetType.isLocalType();
+		}
+		
+		boolean complyTo14 = compliance >= ClassFileConstants.JDK1_4;
+		for (int i = 0, max = syntheticArgumentTypes.length; i < max; i++) {
+			ReferenceBinding syntheticArgType = syntheticArgumentTypes[i];
+			if (hasExtraEnclosingInstance && syntheticArgType == targetEnclosingType) {
+				hasExtraEnclosingInstance = false;
+				enclosingInstance.generateCode(currentScope, this, true);
+				if (complyTo14){
+					dup();
+					invokeObjectGetClass(); // will perform null check
+					pop();
+				}
+			} else {
+				Object[] emulationPath = currentScope.getEmulationPath(
+						syntheticArgType, 
+						false /*not only exact match (that is, allow compatible)*/,
+						denyEnclosingArgInConstructorCall);
+				this.generateOuterAccess(emulationPath, invocationSite, syntheticArgType, currentScope);
+			}
+		}
+		if (hasExtraEnclosingInstance){
+			currentScope.problemReporter().unnecessaryEnclosingInstanceSpecification(enclosingInstance, checkedTargetType);
+		}
+	}
+}
+/**
+ * Code responsible to generate the suitable code to supply values for the synthetic outer local
+ * variable arguments of a constructor invocation of a nested type.
+ * (bug 26122) - synthetic values for outer locals must be passed after user arguments, e.g. new X(i = 1){}
+ */
+public void generateSyntheticOuterArgumentValues(BlockScope currentScope, ReferenceBinding targetType, ASTNode invocationSite) {
+
+	// generate the synthetic outer arguments then
+	SyntheticArgumentBinding syntheticArguments[];
+	if ((syntheticArguments = targetType.syntheticOuterLocalVariables()) != null) {
+		for (int i = 0, max = syntheticArguments.length; i < max; i++) {
+			LocalVariableBinding targetVariable = syntheticArguments[i].actualOuterLocalVariable;
+			VariableBinding[] emulationPath = currentScope.getEmulationPath(targetVariable);
+			this.generateOuterAccess(emulationPath, invocationSite, targetVariable, currentScope);
+		}
+	}
 }
 public void generateUnboxingConversion(int unboxedTypeID) {
 	switch (unboxedTypeID) {
-		case T_byte :
+		case TypeIds.T_byte :
+			// invokevirtual: byteValue()
+			this.invoke(
+					Opcodes.OPC_invokevirtual,
+					0, // argCount
+					1, // return type size
+					ConstantPool.JavaLangByteConstantPoolName,
+					ConstantPool.BYTEVALUE_BYTE_METHOD_NAME,
+					ConstantPool.BYTEVALUE_BYTE_METHOD_SIGNATURE);
+			break;
+		case TypeIds.T_short :
+			// invokevirtual: shortValue()
+			this.invoke(
+					Opcodes.OPC_invokevirtual,
+					0, // argCount
+					1, // return type size
+					ConstantPool.JavaLangShortConstantPoolName,
+					ConstantPool.SHORTVALUE_SHORT_METHOD_NAME,
+					ConstantPool.SHORTVALUE_SHORT_METHOD_SIGNATURE);
+			break;
+		case TypeIds.T_char :
+			// invokevirtual: charValue()
+			this.invoke(
+					Opcodes.OPC_invokevirtual,
+					0, // argCount
+					1, // return type size
+					ConstantPool.JavaLangCharacterConstantPoolName,
+					ConstantPool.CHARVALUE_CHARACTER_METHOD_NAME,
+					ConstantPool.CHARVALUE_CHARACTER_METHOD_SIGNATURE);
+			break;
+		case TypeIds.T_int :
+			// invokevirtual: intValue()
+			this.invoke(
+					Opcodes.OPC_invokevirtual,
+					0, // argCount
+					1, // return type size
+					ConstantPool.JavaLangIntegerConstantPoolName,
+					ConstantPool.INTVALUE_INTEGER_METHOD_NAME,
+					ConstantPool.INTVALUE_INTEGER_METHOD_SIGNATURE);
+			break;
+		case TypeIds.T_long :
+			// invokevirtual: longValue()
+			this.invoke(
+					Opcodes.OPC_invokevirtual,
+					0, // argCount
+					2, // return type size
+					ConstantPool.JavaLangLongConstantPoolName,
+					ConstantPool.LONGVALUE_LONG_METHOD_NAME,
+					ConstantPool.LONGVALUE_LONG_METHOD_SIGNATURE);
+			break;
+		case TypeIds.T_float :
+			// invokevirtual: floatValue()
+			this.invoke(
+					Opcodes.OPC_invokevirtual,
+					0, // argCount
+					1, // return type size
+					ConstantPool.JavaLangFloatConstantPoolName,
+					ConstantPool.FLOATVALUE_FLOAT_METHOD_NAME,
+					ConstantPool.FLOATVALUE_FLOAT_METHOD_SIGNATURE);
+			break;
+		case TypeIds.T_double :
+			// invokevirtual: doubleValue()
+			this.invoke(
+					Opcodes.OPC_invokevirtual,
+					0, // argCount
+					2, // return type size
+					ConstantPool.JavaLangDoubleConstantPoolName,
+					ConstantPool.DOUBLEVALUE_DOUBLE_METHOD_NAME,
+					ConstantPool.DOUBLEVALUE_DOUBLE_METHOD_SIGNATURE);
+			break;
+		case TypeIds.T_boolean :
+			// invokevirtual: booleanValue()
+			this.invoke(
+					Opcodes.OPC_invokevirtual,
+					0, // argCount
+					1, // return type size
+					ConstantPool.JavaLangBooleanConstantPoolName,
+					ConstantPool.BOOLEANVALUE_BOOLEAN_METHOD_NAME,
+					ConstantPool.BOOLEANVALUE_BOOLEAN_METHOD_SIGNATURE);
+	}
+}
+/*
+ * Wide conditional branch compare, improved by swapping comparison opcode
+ *   ifeq WideTarget
+ * becomes
+ *    ifne Intermediate
+ *    gotow WideTarget
+ *    Intermediate:
+ */
+public void generateWideRevertedConditionalBranch(byte revertedOpcode, Label wideTarget) {
+		Label intermediate = new Label(this);
+		if (classFileOffset >= bCodeStream.length) {
+			resizeByteArray();
+		}
+		position++;
+		bCodeStream[classFileOffset++] = revertedOpcode;
+		intermediate.branch();
+		this.goto_w(wideTarget);
+		intermediate.place();
+}
+public void getBaseTypeValue(int baseTypeID) {
+	switch (baseTypeID) {
+		case TypeIds.T_byte :
 			// invokevirtual: byteValue()
 			this.invoke(
-					OPC_invokevirtual,
+					Opcodes.OPC_invokevirtual,
 					0, // argCount
 					1, // return type size
 					ConstantPool.JavaLangByteConstantPoolName,
 					ConstantPool.BYTEVALUE_BYTE_METHOD_NAME,
 					ConstantPool.BYTEVALUE_BYTE_METHOD_SIGNATURE);
 			break;
-		case T_short :
+		case TypeIds.T_short :
 			// invokevirtual: shortValue()
 			this.invoke(
-					OPC_invokevirtual,
+					Opcodes.OPC_invokevirtual,
 					0, // argCount
 					1, // return type size
 					ConstantPool.JavaLangShortConstantPoolName,
 					ConstantPool.SHORTVALUE_SHORT_METHOD_NAME,
 					ConstantPool.SHORTVALUE_SHORT_METHOD_SIGNATURE);
 			break;
-		case T_char :
+		case TypeIds.T_char :
 			// invokevirtual: charValue()
 			this.invoke(
-					OPC_invokevirtual,
+					Opcodes.OPC_invokevirtual,
 					0, // argCount
 					1, // return type size
 					ConstantPool.JavaLangCharacterConstantPoolName,
 					ConstantPool.CHARVALUE_CHARACTER_METHOD_NAME,
 					ConstantPool.CHARVALUE_CHARACTER_METHOD_SIGNATURE);
 			break;
-		case T_int :
+		case TypeIds.T_int :
 			// invokevirtual: intValue()
 			this.invoke(
-					OPC_invokevirtual,
+					Opcodes.OPC_invokevirtual,
 					0, // argCount
 					1, // return type size
 					ConstantPool.JavaLangIntegerConstantPoolName,
 					ConstantPool.INTVALUE_INTEGER_METHOD_NAME,
 					ConstantPool.INTVALUE_INTEGER_METHOD_SIGNATURE);
 			break;
-		case T_long :
+		case TypeIds.T_long :
 			// invokevirtual: longValue()
 			this.invoke(
-					OPC_invokevirtual,
+					Opcodes.OPC_invokevirtual,
 					0, // argCount
 					2, // return type size
 					ConstantPool.JavaLangLongConstantPoolName,
 					ConstantPool.LONGVALUE_LONG_METHOD_NAME,
 					ConstantPool.LONGVALUE_LONG_METHOD_SIGNATURE);
 			break;
-		case T_float :
+		case TypeIds.T_float :
 			// invokevirtual: floatValue()
 			this.invoke(
-					OPC_invokevirtual,
+					Opcodes.OPC_invokevirtual,
 					0, // argCount
 					1, // return type size
 					ConstantPool.JavaLangFloatConstantPoolName,
 					ConstantPool.FLOATVALUE_FLOAT_METHOD_NAME,
 					ConstantPool.FLOATVALUE_FLOAT_METHOD_SIGNATURE);
 			break;
-		case T_double :
+		case TypeIds.T_double :
 			// invokevirtual: doubleValue()
 			this.invoke(
-					OPC_invokevirtual,
+					Opcodes.OPC_invokevirtual,
 					0, // argCount
 					2, // return type size
 					ConstantPool.JavaLangDoubleConstantPoolName,
 					ConstantPool.DOUBLEVALUE_DOUBLE_METHOD_NAME,
 					ConstantPool.DOUBLEVALUE_DOUBLE_METHOD_SIGNATURE);
 			break;
-		case T_boolean :
+		case TypeIds.T_boolean :
 			// invokevirtual: booleanValue()
 			this.invoke(
-					OPC_invokevirtual,
+					Opcodes.OPC_invokevirtual,
 					0, // argCount
 					1, // return type size
 					ConstantPool.JavaLangBooleanConstantPoolName,
@@ -2473,66 +2844,30 @@ final public byte[] getContents() {
 	System.arraycopy(bCodeStream, 0, contents = new byte[position], 0, position);
 	return contents;
 }
-final public void getfield(FieldBinding fieldBinding) {
+public void getfield(FieldBinding fieldBinding) {
 	if (DEBUG) System.out.println(position + "\t\tgetfield:"+fieldBinding); //$NON-NLS-1$
 	int returnTypeSize = 1;
-	if ((fieldBinding.type.id == T_double) || (fieldBinding.type.id == T_long)) {
+	if ((fieldBinding.type.id == TypeIds.T_double) || (fieldBinding.type.id == TypeIds.T_long)) {
 		returnTypeSize = 2;
 	}
 	generateFieldAccess(
-			OPC_getfield,
+			Opcodes.OPC_getfield,
 			returnTypeSize,
-			fieldBinding.declaringClass.constantPoolName(),
-			fieldBinding.name,
-			fieldBinding.type.signature());
-}
-private void generateFieldAccess(byte opcode, int returnTypeSize, char[] declaringClass, char[] name, char[] signature) {
-	countLabels = 0;
-	switch(opcode) {
-		case OPC_getfield :
-			if (returnTypeSize == 2) {
-				stackDepth++;
-			}
-			break;
-		case OPC_getstatic :
-			if (returnTypeSize == 2) {
-				stackDepth += 2;
-			} else {
-				stackDepth++;
-			}
-			break;
-		case OPC_putfield :
-			if (returnTypeSize == 2) {
-				stackDepth -= 3;
-			} else {
-				stackDepth -= 2;
-			}
-			break;
-		case OPC_putstatic :
-			if (returnTypeSize == 2) {
-				stackDepth -= 2;
-			} else {
-				stackDepth--;
-			}
-	}
-	if (stackDepth > stackMax) {
-		stackMax = stackDepth;
-	}
-	if (classFileOffset + 2 >= bCodeStream.length) {
-		resizeByteArray();
-	}
-	position++;
-	bCodeStream[classFileOffset++] = opcode;
-	writeUnsignedShort(constantPool.literalIndexForField(declaringClass, name, signature));
+			fieldBinding.declaringClass.constantPoolName(),
+			fieldBinding.name,
+			fieldBinding.type.signature());
+}
+protected int getPosition() {
+	return this.position;
 }
-final public void getstatic(FieldBinding fieldBinding) {
+public void getstatic(FieldBinding fieldBinding) {
 	if (DEBUG) System.out.println(position + "\t\tgetstatic:"+fieldBinding); //$NON-NLS-1$
 	int returnTypeSize = 1;
-	if ((fieldBinding.type.id == T_double) || (fieldBinding.type.id == T_long)) {
+	if ((fieldBinding.type.id == TypeIds.T_double) || (fieldBinding.type.id == TypeIds.T_long)) {
 		returnTypeSize = 2;
 	}
 	generateFieldAccess(
-			OPC_getstatic,
+			Opcodes.OPC_getstatic,
 			returnTypeSize,
 			fieldBinding.declaringClass.constantPoolName(),
 			fieldBinding.name,
@@ -2541,91 +2876,91 @@ final public void getstatic(FieldBinding fieldBinding) {
 public void getTYPE(int baseTypeID) {
 	countLabels = 0;
 	switch (baseTypeID) {
-		case T_byte :
+		case TypeIds.T_byte :
 			// getstatic: java.lang.Byte.TYPE			
 			if (DEBUG) System.out.println(position + "\t\tgetstatic: java.lang.Byte.TYPE"); //$NON-NLS-1$
 			generateFieldAccess(
-					OPC_getstatic,
+					Opcodes.OPC_getstatic,
 					1,
 					ConstantPool.JavaLangByteConstantPoolName,
 					ConstantPool.TYPE,
 					ConstantPool.JavaLangClassSignature);
 			break;
-		case T_short :
+		case TypeIds.T_short :
 			// getstatic: java.lang.Short.TYPE			
 			if (DEBUG) System.out.println(position + "\t\tgetstatic: java.lang.Short.TYPE"); //$NON-NLS-1$
 			generateFieldAccess(
-					OPC_getstatic,
+					Opcodes.OPC_getstatic,
 					1,
 					ConstantPool.JavaLangShortConstantPoolName,
 					ConstantPool.TYPE,
 					ConstantPool.JavaLangClassSignature);
 			break;
-		case T_char :
+		case TypeIds.T_char :
 			// getstatic: java.lang.Character.TYPE			
 			if (DEBUG) System.out.println(position + "\t\tgetstatic: java.lang.Character.TYPE"); //$NON-NLS-1$
 			generateFieldAccess(
-					OPC_getstatic,
+					Opcodes.OPC_getstatic,
 					1,
 					ConstantPool.JavaLangCharacterConstantPoolName,
 					ConstantPool.TYPE,
 					ConstantPool.JavaLangClassSignature);
 			break;
-		case T_int :
+		case TypeIds.T_int :
 			// getstatic: java.lang.Integer.TYPE			
 			if (DEBUG) System.out.println(position + "\t\tgetstatic: java.lang.Integer.TYPE"); //$NON-NLS-1$
 			generateFieldAccess(
-					OPC_getstatic,
+					Opcodes.OPC_getstatic,
 					1,
 					ConstantPool.JavaLangIntegerConstantPoolName,
 					ConstantPool.TYPE,
 					ConstantPool.JavaLangClassSignature);
 			break;
-		case T_long :
+		case TypeIds.T_long :
 			// getstatic: java.lang.Long.TYPE			
 			if (DEBUG) System.out.println(position + "\t\tgetstatic: java.lang.Long.TYPE"); //$NON-NLS-1$
 			generateFieldAccess(
-					OPC_getstatic,
+					Opcodes.OPC_getstatic,
 					1,
 					ConstantPool.JavaLangLongConstantPoolName,
 					ConstantPool.TYPE,
 					ConstantPool.JavaLangClassSignature);
 			break;
-		case T_float :
+		case TypeIds.T_float :
 			// getstatic: java.lang.Float.TYPE			
 			if (DEBUG) System.out.println(position + "\t\tgetstatic: java.lang.Float.TYPE"); //$NON-NLS-1$
 			generateFieldAccess(
-					OPC_getstatic,
+					Opcodes.OPC_getstatic,
 					1,
 					ConstantPool.JavaLangFloatConstantPoolName,
 					ConstantPool.TYPE,
 					ConstantPool.JavaLangClassSignature);
 			break;
-		case T_double :
+		case TypeIds.T_double :
 			// getstatic: java.lang.Double.TYPE			
 			if (DEBUG) System.out.println(position + "\t\tgetstatic: java.lang.Double.TYPE"); //$NON-NLS-1$
 			generateFieldAccess(
-					OPC_getstatic,
+					Opcodes.OPC_getstatic,
 					1,
 					ConstantPool.JavaLangDoubleConstantPoolName,
 					ConstantPool.TYPE,
 					ConstantPool.JavaLangClassSignature);
 			break;
-		case T_boolean :
+		case TypeIds.T_boolean :
 			// getstatic: java.lang.Boolean.TYPE			
 			if (DEBUG) System.out.println(position + "\t\tgetstatic: java.lang.Boolean.TYPE"); //$NON-NLS-1$
 			generateFieldAccess(
-					OPC_getstatic,
+					Opcodes.OPC_getstatic,
 					1,
 					ConstantPool.JavaLangBooleanConstantPoolName,
 					ConstantPool.TYPE,
 					ConstantPool.JavaLangClassSignature);
 			break;
-		case T_void :
+		case TypeIds.T_void :
 			// getstatic: java.lang.Void.TYPE
 			if (DEBUG) System.out.println(position + "\t\tgetstatic: java.lang.Void.TYPE"); //$NON-NLS-1$
 			generateFieldAccess(
-					OPC_getstatic,
+					Opcodes.OPC_getstatic,
 					1,
 					ConstantPool.JavaLangVoidConstantPoolName,
 					ConstantPool.TYPE,
@@ -2645,7 +2980,7 @@ final public void goto_(Label label) {
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
-	label.inlineForwardReferencesFromLabelsTargeting(position);
+	this.inlineForwardReferencesFromLabelsTargeting(label, position);
 	/*
 	 Possible optimization for code such as:
 	 public Object foo() {
@@ -2668,44 +3003,43 @@ final public void goto_(Label label) {
 	optimization.
 	 if (!lbl.isBranchTarget(position)) {
 		switch(bCodeStream[classFileOffset-1]) {
-			case OPC_return :
-			case OPC_areturn:
+			case Opcodes.OPC_return :
+			case Opcodes.OPC_areturn:
 				return;
 		}
 	}*/
 	position++;
-	bCodeStream[classFileOffset++] = OPC_goto;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_goto;
 	label.branch();
 }
-
 final public void goto_w(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tgotow:"+lbl); //$NON-NLS-1$
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_goto_w;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_goto_w;
 	lbl.branchWide();
 }
-final public void i2b() {
+public void i2b() {
 	if (DEBUG) System.out.println(position + "\t\ti2b"); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_i2b;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_i2b;
 }
-final public void i2c() {
+public void i2c() {
 	if (DEBUG) System.out.println(position + "\t\ti2c"); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_i2c;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_i2c;
 }
-final public void i2d() {
+public void i2d() {
 	if (DEBUG) System.out.println(position + "\t\ti2d"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -2715,18 +3049,18 @@ final public void i2d() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_i2d;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_i2d;
 }
-final public void i2f() {
+public void i2f() {
 	if (DEBUG) System.out.println(position + "\t\ti2f"); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_i2f;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_i2f;
 }
-final public void i2l() {
+public void i2l() {
 	if (DEBUG) System.out.println(position + "\t\ti2l"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -2736,18 +3070,18 @@ final public void i2l() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_i2l;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_i2l;
 }
-final public void i2s() {
+public void i2s() {
 	if (DEBUG) System.out.println(position + "\t\ti2s"); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_i2s;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_i2s;
 }
-final public void iadd() {
+public void iadd() {
 	if (DEBUG) System.out.println(position + "\t\tiadd"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -2755,9 +3089,9 @@ final public void iadd() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iadd;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iadd;
 }
-final public void iaload() {
+public void iaload() {
 	if (DEBUG) System.out.println(position + "\t\tiaload"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -2765,9 +3099,9 @@ final public void iaload() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iaload;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iaload;
 }
-final public void iand() {
+public void iand() {
 	if (DEBUG) System.out.println(position + "\t\tiand"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -2775,9 +3109,9 @@ final public void iand() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iand;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iand;
 }
-final public void iastore() {
+public void iastore() {
 	if (DEBUG) System.out.println(position + "\t\tiastore"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 3;
@@ -2785,9 +3119,9 @@ final public void iastore() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iastore;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iastore;
 }
-final public void iconst_0() {
+public void iconst_0() {
 	if (DEBUG) System.out.println(position + "\t\ticonst_0"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -2797,9 +3131,9 @@ final public void iconst_0() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iconst_0;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iconst_0;
 }
-final public void iconst_1() {
+public void iconst_1() {
 	if (DEBUG) System.out.println(position + "\t\ticonst_1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -2809,9 +3143,9 @@ final public void iconst_1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iconst_1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iconst_1;
 }
-final public void iconst_2() {
+public void iconst_2() {
 	if (DEBUG) System.out.println(position + "\t\ticonst_2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -2821,9 +3155,9 @@ final public void iconst_2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iconst_2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iconst_2;
 }
-final public void iconst_3() {
+public void iconst_3() {
 	if (DEBUG) System.out.println(position + "\t\ticonst_3"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -2833,9 +3167,9 @@ final public void iconst_3() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iconst_3;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iconst_3;
 }
-final public void iconst_4() {
+public void iconst_4() {
 	if (DEBUG) System.out.println(position + "\t\ticonst_4"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -2845,9 +3179,9 @@ final public void iconst_4() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iconst_4;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iconst_4;
 }
-final public void iconst_5() {
+public void iconst_5() {
 	if (DEBUG) System.out.println(position + "\t\ticonst_5"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -2857,9 +3191,9 @@ final public void iconst_5() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iconst_5;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iconst_5;
 }
-final public void iconst_m1() {
+public void iconst_m1() {
 	if (DEBUG) System.out.println(position + "\t\ticonst_m1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -2869,9 +3203,9 @@ final public void iconst_m1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iconst_m1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iconst_m1;
 }
-final public void idiv() {
+public void idiv() {
 	if (DEBUG) System.out.println(position + "\t\tidiv"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -2879,245 +3213,245 @@ final public void idiv() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_idiv;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_idiv;
 }
-final public void if_acmpeq(Label lbl) {
+public void if_acmpeq(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tif_acmpeq:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth-=2;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_if_acmpne, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_if_acmpne, lbl);
 	} else {	
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_if_acmpeq;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_if_acmpeq;
 		lbl.branch();
 	}
 }
-final public void if_acmpne(Label lbl) {
+public void if_acmpne(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tif_acmpne:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth-=2;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_if_acmpeq, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_if_acmpeq, lbl);
 	} else {	
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_if_acmpne;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_if_acmpne;
 		lbl.branch();
 	}
 }
-final public void if_icmpeq(Label lbl) {
+public void if_icmpeq(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tif_cmpeq:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_if_icmpne, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_if_icmpne, lbl);
 	} else {	
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_if_icmpeq;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_if_icmpeq;
 		lbl.branch();
 	}
 }
-final public void if_icmpge(Label lbl) {
+public void if_icmpge(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tif_iacmpge:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_if_icmplt, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_if_icmplt, lbl);
 	} else {	
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_if_icmpge;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_if_icmpge;
 		lbl.branch();
 	}
 }
-final public void if_icmpgt(Label lbl) {
+public void if_icmpgt(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tif_iacmpgt:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_if_icmple, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_if_icmple, lbl);
 	} else {	
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_if_icmpgt;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_if_icmpgt;
 		lbl.branch();
 	}
 }
-final public void if_icmple(Label lbl) {
+public void if_icmple(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tif_iacmple:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_if_icmpgt, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_if_icmpgt, lbl);
 	} else {	
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_if_icmple;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_if_icmple;
 		lbl.branch();
 	}
 }
-final public void if_icmplt(Label lbl) {
+public void if_icmplt(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tif_iacmplt:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_if_icmpge, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_if_icmpge, lbl);
 	} else {
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_if_icmplt;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_if_icmplt;
 		lbl.branch();
 	}
 }
-final public void if_icmpne(Label lbl) {
+public void if_icmpne(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tif_iacmpne:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_if_icmpeq, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_if_icmpeq, lbl);
 	} else {
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_if_icmpne;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_if_icmpne;
 		lbl.branch();
 	}
 }
-final public void ifeq(Label lbl) {
+public void ifeq(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tifeq:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_ifne, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_ifne, lbl);
 	} else {
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_ifeq;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_ifeq;
 		lbl.branch();
 	}
 }
-final public void ifge(Label lbl) {
+public void ifge(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tifge:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_iflt, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_iflt, lbl);
 	} else {
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_ifge;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_ifge;
 		lbl.branch();
 	}
 }
-final public void ifgt(Label lbl) {
+public void ifgt(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tifgt:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_ifle, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_ifle, lbl);
 	} else {
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_ifgt;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_ifgt;
 		lbl.branch();
 	}
 }
-final public void ifle(Label lbl) {
+public void ifle(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tifle:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_ifgt, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_ifgt, lbl);
 	} else {
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_ifle;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_ifle;
 		lbl.branch();
 	}
 }
-final public void iflt(Label lbl) {
+public void iflt(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tiflt:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_ifge, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_ifge, lbl);
 	} else {
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_iflt;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_iflt;
 		lbl.branch();
 	}
 }
-final public void ifne(Label lbl) {
+public void ifne(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tifne:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_ifeq, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_ifeq, lbl);
 	} else {
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_ifne;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_ifne;
 		lbl.branch();
 	}
 }
-final public void ifnonnull(Label lbl) {
+public void ifnonnull(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tifnonnull:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_ifnull, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_ifnull, lbl);
 	} else {
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_ifnonnull;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_ifnonnull;
 		lbl.branch();
 	}
 }
-final public void ifnull(Label lbl) {
+public void ifnull(Label lbl) {
 	if (DEBUG) System.out.println(position + "\t\tifnull:"+lbl); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
 	if (this.wideMode) {
-		generateWideRevertedConditionalBranch(OPC_ifnonnull, lbl);
+		generateWideRevertedConditionalBranch(Opcodes.OPC_ifnonnull, lbl);
 	} else {
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_ifnull;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_ifnull;
 		lbl.branch();
 	}
 }
@@ -3129,8 +3463,8 @@ final public void iinc(int index, int value) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_wide;
-		bCodeStream[classFileOffset++] = OPC_iinc;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_wide;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_iinc;
 		writeUnsignedShort(index);
 		writeSignedShort(value);
 	} else {
@@ -3138,12 +3472,12 @@ final public void iinc(int index, int value) {
 			resizeByteArray();
 		}
 		position += 3;
-		bCodeStream[classFileOffset++] = OPC_iinc;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_iinc;
 		bCodeStream[classFileOffset++] = (byte) index;
 		bCodeStream[classFileOffset++] = (byte) value;
 	}
 }
-final public void iload(int iArg) {
+public void iload(int iArg) {
 	if (DEBUG) System.out.println(position + "\t\tiload:"+iArg); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -3157,19 +3491,19 @@ final public void iload(int iArg) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_wide;
-		bCodeStream[classFileOffset++] = OPC_iload;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_wide;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_iload;
 		writeUnsignedShort(iArg);
 	} else {
 		if (classFileOffset + 1 >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_iload;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_iload;
 		bCodeStream[classFileOffset++] = (byte) iArg;
 	}
 }
-final public void iload_0() {
+public void iload_0() {
 	if (DEBUG) System.out.println(position + "\t\tiload_0"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -3182,9 +3516,9 @@ final public void iload_0() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iload_0;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iload_0;
 }
-final public void iload_1() {
+public void iload_1() {
 	if (DEBUG) System.out.println(position + "\t\tiload_1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -3197,9 +3531,9 @@ final public void iload_1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iload_1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iload_1;
 }
-final public void iload_2() {
+public void iload_2() {
 	if (DEBUG) System.out.println(position + "\t\tiload_2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -3212,9 +3546,9 @@ final public void iload_2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iload_2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iload_2;
 }
-final public void iload_3() {
+public void iload_3() {
 	if (DEBUG) System.out.println(position + "\t\tiload_3"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -3227,9 +3561,9 @@ final public void iload_3() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iload_3;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iload_3;
 }
-final public void imul() {
+public void imul() {
 	if (DEBUG) System.out.println(position + "\t\timul"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -3237,21 +3571,7 @@ final public void imul() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_imul;
-}
-public void incrementTemp(LocalVariableBinding localBinding, int value) {
-	if (value == (short) value) {
-		this.iinc(localBinding.resolvedPosition, value);
-		return;
-	}
-	load(localBinding);
-	this.ldc(value);
-	this.iadd();
-	store(localBinding, false);
-}
-public void incrStackSize(int offset) {
-	if ((stackDepth += offset) > stackMax)
-		stackMax = stackDepth;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_imul;
 }
 public int indexOfSameLineEntrySincePC(int pc, int line) {
 	for (int index = pc, max = pcToSourceMapSize; index < max; index+=2) {
@@ -3260,14 +3580,46 @@ public int indexOfSameLineEntrySincePC(int pc, int line) {
 	}
 	return -1;
 }
-final public void ineg() {
+public void ineg() {
 	if (DEBUG) System.out.println(position + "\t\tineg"); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_ineg;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_ineg;
+}
+/*
+ * Some placed labels might be branching to a goto bytecode which we can optimize better.
+ */
+public void inlineForwardReferencesFromLabelsTargeting(Label label, int gotoLocation) {
+	
+/*
+ Code required to optimized unreachable gotos.
+	public boolean isBranchTarget(int location) {
+		Label[] labels = codeStream.labels;
+		for (int i = codeStream.countLabels - 1; i >= 0; i--){
+			Label label = labels[i];
+			if ((label.position == location) && label.isStandardLabel()){
+				return true;
+			}
+		}
+		return false;
+	}
+ */
+	
+	for (int i = this.countLabels - 1; i >= 0; i--) {
+		Label currentLabel = labels[i];
+		if ((currentLabel.position == gotoLocation) && currentLabel.isStandardLabel()){
+			label.appendForwardReferencesFrom(currentLabel);
+			/*
+			 Code required to optimized unreachable gotos.
+				label.position = POS_NOT_SET;
+			*/
+		} else {
+			break; // same target labels should be contiguous
+		}
+	}
 }
 public void init(ClassFile targetClassFile) {
 	this.classFile = targetClassFile;
@@ -3362,99 +3714,130 @@ public void initializeMaxLocals(MethodBinding methodBinding) {
 	}
 }
 /**
- * This methods searches for an existing entry inside the pcToSourceMap table with a pc equals to @pc.
- * If there is an existing entry it returns -1 (no insertion required).
- * Otherwise it returns the index where the entry for the pc has to be inserted.
- * This is based on the fact that the pcToSourceMap table is sorted according to the pc.
- *
- * @param pcToSourceMap the given pcToSourceMap array
- * @param length the given length
- * @param pc the given pc
- * @return int
- */
-public static int insertionIndex(int[] pcToSourceMap, int length, int pc) {
-	int g = 0;
-	int d = length - 2;
-	int m = 0;
-	while (g <= d) {
-		m = (g + d) / 2;
-		// we search only on even indexes
-		if ((m % 2) != 0)
-			m--;
-		int currentPC = pcToSourceMap[m];
-		if (pc < currentPC) {
-			d = m - 2;
-		} else
-			if (pc > currentPC) {
-				g = m + 2;
-			} else {
-				return -1;
-			}
-	}
-	if (pc < pcToSourceMap[m])
-		return m;
-	return m + 2;
-}
-/**
  * We didn't call it instanceof because there is a conflit with the
  * instanceof keyword
  */
-final public void instance_of(TypeBinding typeBinding) {
+public void instance_of(TypeBinding typeBinding) {
 	if (DEBUG) System.out.println(position + "\t\tinstance_of:"+typeBinding); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset + 2 >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_instanceof;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_instanceof;
 	writeUnsignedShort(constantPool.literalIndexForType(typeBinding.constantPoolName()));
 }
+protected void invoke(int opcode, int argsSize, int returnTypeSize, char[] declaringClass, char[] selector, char[] signature) {
+	countLabels = 0;
+	int argCount = argsSize;
+	switch(opcode) {
+		case Opcodes.OPC_invokeinterface :
+			if (classFileOffset + 4 >= bCodeStream.length) {
+				resizeByteArray();
+			}
+			position +=3;
+			bCodeStream[classFileOffset++] = Opcodes.OPC_invokeinterface;
+			writeUnsignedShort(constantPool.literalIndexForMethod(declaringClass, selector, signature, true));
+			argCount++;
+			bCodeStream[classFileOffset++] = (byte) argCount;
+			bCodeStream[classFileOffset++] = 0;
+			break;
+		case Opcodes.OPC_invokevirtual :
+		case Opcodes.OPC_invokespecial :
+			if (classFileOffset + 2 >= bCodeStream.length) {
+				resizeByteArray();
+			}
+			position++;
+			bCodeStream[classFileOffset++] = (byte) opcode;
+			writeUnsignedShort(constantPool.literalIndexForMethod(declaringClass, selector, signature, false));
+			argCount++;
+			break;
+		case Opcodes.OPC_invokestatic :
+			if (classFileOffset + 2 >= bCodeStream.length) {
+				resizeByteArray();
+			}
+			position++;
+			bCodeStream[classFileOffset++] = Opcodes.OPC_invokestatic;
+			writeUnsignedShort(constantPool.literalIndexForMethod(declaringClass, selector, signature, false));
+	}
+	stackDepth += returnTypeSize - argCount;
+	if (stackDepth > stackMax) {
+		stackMax = stackDepth;
+	}
+}
+protected void invokeAccessibleObjectSetAccessible() {
+	// invokevirtual: java.lang.reflect.AccessibleObject.setAccessible(Z)V;
+	this.invoke(
+			Opcodes.OPC_invokevirtual,
+			1, // argCount
+			0, // return type size
+			ConstantPool.JAVALANGREFLECTACCESSIBLEOBJECT_CONSTANTPOOLNAME,
+			ConstantPool.SETACCESSIBLE_NAME,
+			ConstantPool.SETACCESSIBLE_SIGNATURE);
+}
+protected void invokeArrayNewInstance() {
+	// invokestatic: java.lang.reflect.Array.newInstance(Ljava.lang.Class;int[])Ljava.lang.Object;
+	this.invoke(
+			Opcodes.OPC_invokestatic,
+			2, // argCount
+			1, // return type size
+			ConstantPool.JAVALANGREFLECTARRAY_CONSTANTPOOLNAME,
+			ConstantPool.NewInstance,
+			ConstantPool.NewInstanceSignature);
+}
 public void invokeClassForName() {
 	// invokestatic: java.lang.Class.forName(Ljava.lang.String;)Ljava.lang.Class;
 	if (DEBUG) System.out.println(position + "\t\tinvokestatic: java.lang.Class.forName(Ljava.lang.String;)Ljava.lang.Class;"); //$NON-NLS-1$
 	this.invoke(
-		OPC_invokestatic,
+		Opcodes.OPC_invokestatic,
 		1, // argCount
 		1, // return type size
 		ConstantPool.JavaLangClassConstantPoolName,
 		ConstantPool.ForName,
 		ConstantPool.ForNameSignature);
 }
-public void invokeJavaLangClassDesiredAssertionStatus() {
-	// invokevirtual: java.lang.Class.desiredAssertionStatus()Z;
-	if (DEBUG) System.out.println(position + "\t\tinvokevirtual: java.lang.Class.desiredAssertionStatus()Z;"); //$NON-NLS-1$
+protected void invokeClassGetDeclaredConstructor() {
+	// invokevirtual: java.lang.Class getDeclaredConstructor([Ljava.lang.Class)Ljava.lang.reflect.Constructor;
 	this.invoke(
-			OPC_invokevirtual,
-			0, // argCount
+			Opcodes.OPC_invokevirtual,
+			1, // argCount
 			1, // return type size
 			ConstantPool.JavaLangClassConstantPoolName,
-			ConstantPool.DesiredAssertionStatus,
-			ConstantPool.DesiredAssertionStatusSignature);
+			ConstantPool.GETDECLAREDCONSTRUCTOR_NAME,
+			ConstantPool.GETDECLAREDCONSTRUCTOR_SIGNATURE);
 }
-
-public void invokeJavaLangClassGetComponentType() {
-	// invokevirtual: java.lang.Class.getComponentType()java.lang.Class;
-	if (DEBUG) System.out.println(position + "\t\tinvokevirtual: java.lang.Class.getComponentType()java.lang.Class;"); //$NON-NLS-1$
+protected void invokeClassGetDeclaredField() {
+	// invokevirtual: java.lang.Class.getDeclaredField(Ljava.lang.String)Ljava.lang.reflect.Field;
 	this.invoke(
-			OPC_invokevirtual,
-			0, // argCount
+			Opcodes.OPC_invokevirtual,
+			1, // argCount
+			1, // return type size
+			ConstantPool.JavaLangClassConstantPoolName,
+			ConstantPool.GETDECLAREDFIELD_NAME,
+			ConstantPool.GETDECLAREDFIELD_SIGNATURE);
+}
+protected void invokeClassGetDeclaredMethod() {
+	// invokevirtual: java.lang.Class getDeclaredMethod(Ljava.lang.String, [Ljava.lang.Class)Ljava.lang.reflect.Method;
+	this.invoke(
+			Opcodes.OPC_invokevirtual,
+			2, // argCount
 			1, // return type size
 			ConstantPool.JavaLangClassConstantPoolName,
-			ConstantPool.GetComponentType,
-			ConstantPool.GetComponentTypeSignature);
+			ConstantPool.GETDECLAREDMETHOD_NAME,
+			ConstantPool.GETDECLAREDMETHOD_SIGNATURE);
 }
 public void invokeEnumOrdinal(char[] enumTypeConstantPoolName) {
 	// invokevirtual: <enumConstantPoolName>.ordinal()
 	if (DEBUG) System.out.println(position + "\t\tinvokevirtual: "+new String(enumTypeConstantPoolName)+".ordinal()"); //$NON-NLS-1$ //$NON-NLS-2$
 	this.invoke(
-			OPC_invokevirtual,
+			Opcodes.OPC_invokevirtual,
 			0, // argCount
 			1, // return type size
 			enumTypeConstantPoolName,
 			ConstantPool.Ordinal,
 			ConstantPool.OrdinalSignature);
 }
-final public void invokeinterface(MethodBinding methodBinding) {
+public void invokeinterface(MethodBinding methodBinding) {
 	// initialized to 1 to take into account this  immediately
 	if (DEBUG) System.out.println(position + "\t\tinvokeinterface: " + methodBinding); //$NON-NLS-1$
 	countLabels = 0;
@@ -3464,7 +3847,7 @@ final public void invokeinterface(MethodBinding methodBinding) {
 		resizeByteArray();
 	}
 	position += 3;
-	bCodeStream[classFileOffset++] = OPC_invokeinterface;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_invokeinterface;
 	writeUnsignedShort(
 		constantPool.literalIndexForMethod(
 			methodBinding.constantPoolDeclaringClass().constantPoolName(),
@@ -3472,7 +3855,7 @@ final public void invokeinterface(MethodBinding methodBinding) {
 			methodBinding.signature(),
 			true));
 	for (int i = methodBinding.parameters.length - 1; i >= 0; i--)
-		if (((id = methodBinding.parameters[i].id) == T_double) || (id == T_long))
+		if (((id = methodBinding.parameters[i].id) == TypeIds.T_double) || (id == TypeIds.T_long))
 			argCount += 2;
 		else
 			argCount += 1;
@@ -3480,10 +3863,10 @@ final public void invokeinterface(MethodBinding methodBinding) {
 	// Generate a  0 into the byte array. Like the array is already fill with 0, we just need to increment
 	// the number of bytes.
 	bCodeStream[classFileOffset++] = 0;
-	if (((id = methodBinding.returnType.id) == T_double) || (id == T_long)) {
+	if (((id = methodBinding.returnType.id) == TypeIds.T_double) || (id == TypeIds.T_long)) {
 		stackDepth += (2 - argCount);
 	} else {
-		if (id == T_void) {
+		if (id == TypeIds.T_void) {
 			stackDepth -= argCount;
 		} else {
 			stackDepth += (1 - argCount);
@@ -3493,22 +3876,259 @@ final public void invokeinterface(MethodBinding methodBinding) {
 		stackMax = stackDepth;
 	}
 }
+public void invokeJavaLangAssertionErrorConstructor(int typeBindingID) {
+	// invokespecial: java.lang.AssertionError.<init>(typeBindingID)V
+	if (DEBUG) System.out.println(position + "\t\tinvokespecial: java.lang.AssertionError.<init>(typeBindingID)V"); //$NON-NLS-1$
+	int argCount = 1;
+	char[] signature = null;
+	switch (typeBindingID) {
+		case TypeIds.T_int :
+		case TypeIds.T_byte :
+		case TypeIds.T_short :
+			signature = ConstantPool.IntConstrSignature;
+			break;
+		case TypeIds.T_long :
+			signature = ConstantPool.LongConstrSignature;
+			argCount = 2;
+			break;
+		case TypeIds.T_float :
+			signature = ConstantPool.FloatConstrSignature;
+			break;
+		case TypeIds.T_double :
+			signature = ConstantPool.DoubleConstrSignature;
+			argCount = 2;
+			break;
+		case TypeIds.T_char :
+			signature = ConstantPool.CharConstrSignature;
+			break;
+		case TypeIds.T_boolean :
+			signature = ConstantPool.BooleanConstrSignature;
+			break;
+		case TypeIds.T_JavaLangObject :
+		case TypeIds.T_JavaLangString :
+		case TypeIds.T_null :
+			signature = ConstantPool.ObjectConstrSignature;
+			break;
+	}
+	this.invoke(
+			Opcodes.OPC_invokespecial,
+			argCount, // argCount
+			0, // return type size
+			ConstantPool.JavaLangAssertionErrorConstantPoolName,
+			ConstantPool.Init,
+			signature);
+}
+public void invokeJavaLangAssertionErrorDefaultConstructor() {
+	// invokespecial: java.lang.AssertionError.<init>()V
+	if (DEBUG) System.out.println(position + "\t\tinvokespecial: java.lang.AssertionError.<init>()V"); //$NON-NLS-1$
+	this.invoke(
+			Opcodes.OPC_invokespecial,
+			0, // argCount
+			0, // return type size
+			ConstantPool.JavaLangAssertionErrorConstantPoolName,
+			ConstantPool.Init,
+			ConstantPool.DefaultConstructorSignature);
+}
+public void invokeJavaLangClassDesiredAssertionStatus() {
+	// invokevirtual: java.lang.Class.desiredAssertionStatus()Z;
+	if (DEBUG) System.out.println(position + "\t\tinvokevirtual: java.lang.Class.desiredAssertionStatus()Z;"); //$NON-NLS-1$
+	this.invoke(
+			Opcodes.OPC_invokevirtual,
+			0, // argCount
+			1, // return type size
+			ConstantPool.JavaLangClassConstantPoolName,
+			ConstantPool.DesiredAssertionStatus,
+			ConstantPool.DesiredAssertionStatusSignature);
+}
+public void invokeJavaLangEnumname(TypeBinding typeBinding) {
+	// invokevirtual: java.lang.Enum.name()String
+	if (DEBUG) System.out.println(position + "\t\tinvokevirtual: java.lang.Enum.name()Ljava/lang/String;"); //$NON-NLS-1$
+	this.invoke(
+			Opcodes.OPC_invokevirtual,
+			0,
+			1,
+			typeBinding.constantPoolName(),
+			ConstantPool.Name,
+			ConstantPool.NameSignature);
+}
+public void invokeJavaLangEnumValues(TypeBinding enumBinding, ArrayBinding arrayBinding) {
+	char[] signature = "()".toCharArray(); //$NON-NLS-1$
+	signature = CharOperation.concat(signature, arrayBinding.constantPoolName());
+	this.invoke(Opcodes.OPC_invokestatic, 0, 1, enumBinding.constantPoolName(), TypeConstants.VALUES, signature);
+}
 public void invokeJavaLangErrorConstructor() {
 	// invokespecial: java.lang.Error<init>(Ljava.lang.String;)V
 	if (DEBUG) System.out.println(position + "\t\tinvokespecial: java.lang.Error<init>(Ljava.lang.String;)V"); //$NON-NLS-1$
 	this.invoke(
-			OPC_invokespecial,
+			Opcodes.OPC_invokespecial,
 			1, // argCount
 			0, // return type size
 			ConstantPool.JavaLangErrorConstantPoolName,
 			ConstantPool.Init,
 			ConstantPool.StringConstructorSignature);
 }
+public void invokeJavaLangIllegalArgumentExceptionStringConstructor() {
+	// invokespecial: java.lang.IllegalArgumentException.<init>(String)V
+	if (DEBUG) System.out.println(position + "\t\tinvokespecial: java.lang.IllegalArgumentException.<init>(java.lang.String)V"); //$NON-NLS-1$
+	this.invoke(
+			Opcodes.OPC_invokespecial,
+			1, // argCount
+			0, // return type size
+			ConstantPool.JavaLangIllegalArgumentExceptionConstantPoolName,
+			ConstantPool.Init,
+			ConstantPool.StringConstructorSignature);
+}
+public void invokeJavaLangReflectConstructorNewInstance() {
+	// invokevirtual: java.lang.reflect.Constructor.newInstance([Ljava.lang.Object;)Ljava.lang.Object;
+	this.invoke(
+			Opcodes.OPC_invokevirtual,
+			1, // argCount
+			1, // return type size
+			ConstantPool.JavaLangReflectConstructorConstantPoolName,
+			ConstantPool.NewInstance,
+			ConstantPool.JavaLangReflectConstructorNewInstanceSignature);
+}
+protected void invokeJavaLangReflectFieldGetter(int typeID) {
+	int returnTypeSize = 1;
+	char[] signature = null;
+	char[] selector = null;
+	switch (typeID) {
+		case TypeIds.T_int :
+			selector = ConstantPool.GET_INT_METHOD_NAME;
+			signature = ConstantPool.GET_INT_METHOD_SIGNATURE;
+			break;
+		case TypeIds.T_byte :
+			selector = ConstantPool.GET_BYTE_METHOD_NAME;
+			signature = ConstantPool.GET_BYTE_METHOD_SIGNATURE;
+			break;
+		case TypeIds.T_short :
+			selector = ConstantPool.GET_SHORT_METHOD_NAME;
+			signature = ConstantPool.GET_SHORT_METHOD_SIGNATURE;
+			break;
+		case TypeIds.T_long :
+			selector = ConstantPool.GET_LONG_METHOD_NAME;
+			signature = ConstantPool.GET_LONG_METHOD_SIGNATURE;
+			returnTypeSize = 2;
+			break;
+		case TypeIds.T_float :
+			selector = ConstantPool.GET_FLOAT_METHOD_NAME;
+			signature = ConstantPool.GET_FLOAT_METHOD_SIGNATURE;
+			break;
+		case TypeIds.T_double :
+			selector = ConstantPool.GET_DOUBLE_METHOD_NAME;
+			signature = ConstantPool.GET_DOUBLE_METHOD_SIGNATURE;
+			returnTypeSize = 2;
+			break;
+		case TypeIds.T_char :
+			selector = ConstantPool.GET_CHAR_METHOD_NAME;
+			signature = ConstantPool.GET_CHAR_METHOD_SIGNATURE;
+			break;
+		case TypeIds.T_boolean :
+			selector = ConstantPool.GET_BOOLEAN_METHOD_NAME;
+			signature = ConstantPool.GET_BOOLEAN_METHOD_SIGNATURE;
+			break;
+		default :
+			selector = ConstantPool.GET_OBJECT_METHOD_NAME;
+			signature = ConstantPool.GET_OBJECT_METHOD_SIGNATURE;
+			break;
+	}
+	this.invoke(
+			Opcodes.OPC_invokevirtual,
+			1, // argCount
+			returnTypeSize, // return type size
+			ConstantPool.JAVALANGREFLECTFIELD_CONSTANTPOOLNAME,
+			selector,
+			signature);
+}
+protected void invokeJavaLangReflectFieldSetter(int typeID) {
+	int argCount = 2;
+	char[] signature = null;
+	char[] selector = null;
+	switch (typeID) {
+		case TypeIds.T_int :
+			selector = ConstantPool.SET_INT_METHOD_NAME;
+			signature = ConstantPool.SET_INT_METHOD_SIGNATURE;
+			break;
+		case TypeIds.T_byte :
+			selector = ConstantPool.SET_BYTE_METHOD_NAME;
+			signature = ConstantPool.SET_BYTE_METHOD_SIGNATURE;
+			break;
+		case TypeIds.T_short :
+			selector = ConstantPool.SET_SHORT_METHOD_NAME;
+			signature = ConstantPool.SET_SHORT_METHOD_SIGNATURE;
+			break;
+		case TypeIds.T_long :
+			selector = ConstantPool.SET_LONG_METHOD_NAME;
+			signature = ConstantPool.SET_LONG_METHOD_SIGNATURE;
+			argCount = 3;
+			break;
+		case TypeIds.T_float :
+			selector = ConstantPool.SET_FLOAT_METHOD_NAME;
+			signature = ConstantPool.SET_FLOAT_METHOD_SIGNATURE;
+			break;
+		case TypeIds.T_double :
+			selector = ConstantPool.SET_DOUBLE_METHOD_NAME;
+			signature = ConstantPool.SET_DOUBLE_METHOD_SIGNATURE;
+			argCount = 3;
+			break;
+		case TypeIds.T_char :
+			selector = ConstantPool.SET_CHAR_METHOD_NAME;
+			signature = ConstantPool.SET_CHAR_METHOD_SIGNATURE;
+			break;
+		case TypeIds.T_boolean :
+			selector = ConstantPool.SET_BOOLEAN_METHOD_NAME;
+			signature = ConstantPool.SET_BOOLEAN_METHOD_SIGNATURE;
+			break;
+		default :
+			selector = ConstantPool.SET_OBJECT_METHOD_NAME;
+			signature = ConstantPool.SET_OBJECT_METHOD_SIGNATURE;
+			break;
+	}
+	this.invoke(
+			Opcodes.OPC_invokevirtual,
+			argCount, // argCount
+			0, // return type size
+			ConstantPool.JAVALANGREFLECTFIELD_CONSTANTPOOLNAME,
+			selector,
+			signature);
+}
+public void invokeJavaLangReflectMethodInvoke() {
+	// invokevirtual: java.lang.reflect.Method.invoke(Ljava.lang.Object;[Ljava.lang.Object;)Ljava.lang.Object;
+	this.invoke(
+			Opcodes.OPC_invokevirtual,
+			2, // argCount
+			1, // return type size
+			ConstantPool.JAVALANGREFLECTMETHOD_CONSTANTPOOLNAME,
+			ConstantPool.INVOKE_METHOD_METHOD_NAME,
+			ConstantPool.INVOKE_METHOD_METHOD_SIGNATURE);
+}
+public void invokeJavaUtilIteratorHasNext() {
+	// invokeinterface java.util.Iterator.hasNext()Z
+	if (DEBUG) System.out.println(position + "\t\tinvokeinterface: java.util.Iterator.hasNext()Z"); //$NON-NLS-1$
+	this.invoke(
+			Opcodes.OPC_invokeinterface,
+			0, // argCount
+			1, // return type size
+			ConstantPool.JavaUtilIteratorConstantPoolName,
+			ConstantPool.HasNext,
+			ConstantPool.HasNextSignature);
+}
+public void invokeJavaUtilIteratorNext() {
+	// invokeinterface java.util.Iterator.next()java.lang.Object
+	if (DEBUG) System.out.println(position + "\t\tinvokeinterface: java.util.Iterator.next()java.lang.Object"); //$NON-NLS-1$
+	this.invoke(
+			Opcodes.OPC_invokeinterface,
+			0, // argCount
+			1, // return type size
+			ConstantPool.JavaUtilIteratorConstantPoolName,
+			ConstantPool.Next,
+			ConstantPool.NextSignature);
+}
 public void invokeNoClassDefFoundErrorStringConstructor() {
 	// invokespecial: java.lang.NoClassDefFoundError.<init>(Ljava.lang.String;)V
 	if (DEBUG) System.out.println(position + "\t\tinvokespecial: java.lang.NoClassDefFoundError.<init>(Ljava.lang.String;)V"); //$NON-NLS-1$
 	this.invoke(
-			OPC_invokespecial,
+			Opcodes.OPC_invokespecial,
 			1, // argCount
 			0, // return type size
 			ConstantPool.JavaLangNoClassDefFoundErrorConstantPoolName,
@@ -3519,15 +4139,14 @@ public void invokeObjectGetClass() {
 	// invokevirtual: java.lang.Object.getClass()Ljava.lang.Class;
 	if (DEBUG) System.out.println(position + "\t\tinvokevirtual: java.lang.Object.getClass()Ljava.lang.Class;"); //$NON-NLS-1$
 	this.invoke(
-			OPC_invokevirtual,
+			Opcodes.OPC_invokevirtual,
 			0, // argCount
 			1, // return type size
 			ConstantPool.JavaLangObjectConstantPoolName,
 			ConstantPool.GetClass,
 			ConstantPool.GetClassSignature);
 }
-
-final public void invokespecial(MethodBinding methodBinding) {
+public void invokespecial(MethodBinding methodBinding) {
 	if (DEBUG) System.out.println(position + "\t\tinvokespecial:"+methodBinding); //$NON-NLS-1$
 	// initialized to 1 to take into account this  immediately
 	countLabels = 0;
@@ -3537,7 +4156,7 @@ final public void invokespecial(MethodBinding methodBinding) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_invokespecial;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_invokespecial;
 	writeUnsignedShort(
 		constantPool.literalIndexForMethod(
 			methodBinding.constantPoolDeclaringClass().constantPoolName(),
@@ -3549,7 +4168,7 @@ final public void invokespecial(MethodBinding methodBinding) {
 		TypeBinding[] syntheticArgumentTypes = methodBinding.declaringClass.syntheticEnclosingInstanceTypes();
 		if (syntheticArgumentTypes != null) {
 			for (int i = 0, max = syntheticArgumentTypes.length; i < max; i++) {
-				if (((id = syntheticArgumentTypes[i].id) == T_double) || (id == T_long)) {
+				if (((id = syntheticArgumentTypes[i].id) == TypeIds.T_double) || (id == TypeIds.T_long)) {
 					argCount += 2;
 				} else {
 					argCount++;
@@ -3560,7 +4179,7 @@ final public void invokespecial(MethodBinding methodBinding) {
 		SyntheticArgumentBinding[] syntheticArguments = methodBinding.declaringClass.syntheticOuterLocalVariables();
 		if (syntheticArguments != null) {
 			for (int i = 0, max = syntheticArguments.length; i < max; i++) {
-				if (((id = syntheticArguments[i].type.id) == T_double) || (id == T_long)) {
+				if (((id = syntheticArguments[i].type.id) == TypeIds.T_double) || (id == TypeIds.T_long)) {
 					argCount += 2;
 				} else {
 					argCount++;
@@ -3569,21 +4188,21 @@ final public void invokespecial(MethodBinding methodBinding) {
 		}
 	}
 	for (int i = methodBinding.parameters.length - 1; i >= 0; i--)
-		if (((id = methodBinding.parameters[i].id) == T_double) || (id == T_long))
+		if (((id = methodBinding.parameters[i].id) == TypeIds.T_double) || (id == TypeIds.T_long))
 			argCount += 2;
 		else
 			argCount++;
-	if (((id = methodBinding.returnType.id) == T_double) || (id == T_long))
+	if (((id = methodBinding.returnType.id) == TypeIds.T_double) || (id == TypeIds.T_long))
 		stackDepth += (2 - argCount);
 	else
-		if (id == T_void)
+		if (id == TypeIds.T_void)
 			stackDepth -= argCount;
 		else
 			stackDepth += (1 - argCount);
 	if (stackDepth > stackMax)
 		stackMax = stackDepth;
 }
-final public void invokestatic(MethodBinding methodBinding) {
+public void invokestatic(MethodBinding methodBinding) {
 	if (DEBUG) System.out.println(position + "\t\tinvokestatic:"+methodBinding); //$NON-NLS-1$
 	// initialized to 0 to take into account that there is no this for
 	// a static method
@@ -3594,7 +4213,7 @@ final public void invokestatic(MethodBinding methodBinding) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_invokestatic;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_invokestatic;
 	writeUnsignedShort(
 		constantPool.literalIndexForMethod(
 			methodBinding.constantPoolDeclaringClass().constantPoolName(),
@@ -3602,14 +4221,14 @@ final public void invokestatic(MethodBinding methodBinding) {
 			methodBinding.signature(),
 			false));
 	for (int i = methodBinding.parameters.length - 1; i >= 0; i--)
-		if (((id = methodBinding.parameters[i].id) == T_double) || (id == T_long))
+		if (((id = methodBinding.parameters[i].id) == TypeIds.T_double) || (id == TypeIds.T_long))
 			argCount += 2;
 		else
 			argCount += 1;
-	if (((id = methodBinding.returnType.id) == T_double) || (id == T_long))
+	if (((id = methodBinding.returnType.id) == TypeIds.T_double) || (id == TypeIds.T_long))
 		stackDepth += (2 - argCount);
 	else
-		if (id == T_void)
+		if (id == TypeIds.T_void)
 			stackDepth -= argCount;
 		else
 			stackDepth += (1 - argCount);
@@ -3630,197 +4249,97 @@ public void invokeStringConcatenationAppendForType(int typeID) {
 	}
 	int argCount = 1;
 	int returnType = 1;
-	char[] declarinClass = null;
+	char[] declaringClass = null;
 	char[] selector = ConstantPool.Append;
 	char[] signature = null;
 	switch (typeID) {
-		case T_int :
-		case T_byte :
-		case T_short :
+		case TypeIds.T_int :
+		case TypeIds.T_byte :
+		case TypeIds.T_short :
 			if (this.targetLevel >= ClassFileConstants.JDK1_5) {
-				declarinClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
 				signature = ConstantPool.StringBuilderAppendIntSignature;
 			} else {
-				declarinClass = ConstantPool.JavaLangStringBufferConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBufferConstantPoolName;
 				signature = ConstantPool.StringBufferAppendIntSignature;
 			}
 			break;
-		case T_long :
+		case TypeIds.T_long :
 			if (this.targetLevel >= ClassFileConstants.JDK1_5) {
-				declarinClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
 				signature = ConstantPool.StringBuilderAppendLongSignature;
 			} else {
-				declarinClass = ConstantPool.JavaLangStringBufferConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBufferConstantPoolName;
 				signature = ConstantPool.StringBufferAppendLongSignature;
 			}
 			argCount = 2;
 			break;
-		case T_float :
+		case TypeIds.T_float :
 			if (this.targetLevel >= ClassFileConstants.JDK1_5) {
-				declarinClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
 				signature = ConstantPool.StringBuilderAppendFloatSignature;
 			} else {
-				declarinClass = ConstantPool.JavaLangStringBufferConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBufferConstantPoolName;
 				signature = ConstantPool.StringBufferAppendFloatSignature;
 			}
 			break;
-		case T_double :
+		case TypeIds.T_double :
 			if (this.targetLevel >= ClassFileConstants.JDK1_5) {
-				declarinClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
 				signature = ConstantPool.StringBuilderAppendDoubleSignature;
 			} else {
-				declarinClass = ConstantPool.JavaLangStringBufferConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBufferConstantPoolName;
 				signature = ConstantPool.StringBufferAppendDoubleSignature;
 			}
 			argCount = 2;
 			break;
-		case T_char :
+		case TypeIds.T_char :
 			if (this.targetLevel >= ClassFileConstants.JDK1_5) {
-				declarinClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
 				signature = ConstantPool.StringBuilderAppendCharSignature;
 			} else {
-				declarinClass = ConstantPool.JavaLangStringBufferConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBufferConstantPoolName;
 				signature = ConstantPool.StringBufferAppendCharSignature;
 			}
 			break;
-		case T_boolean :
+		case TypeIds.T_boolean :
 			if (this.targetLevel >= ClassFileConstants.JDK1_5) {
-				declarinClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
 				signature = ConstantPool.StringBuilderAppendBooleanSignature;
 			} else {
-				declarinClass = ConstantPool.JavaLangStringBufferConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBufferConstantPoolName;
 				signature = ConstantPool.StringBufferAppendBooleanSignature;
 			}
 			break;
-		case T_undefined :
-		case T_JavaLangObject :
-		case T_null :
+		case TypeIds.T_undefined :
+		case TypeIds.T_JavaLangObject :
+		case TypeIds.T_null :
 			if (this.targetLevel >= ClassFileConstants.JDK1_5) {
-				declarinClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
 				signature = ConstantPool.StringBuilderAppendObjectSignature;
 			} else {
-				declarinClass = ConstantPool.JavaLangStringBufferConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBufferConstantPoolName;
 				signature = ConstantPool.StringBufferAppendObjectSignature;
 			}
 			break;
-		case T_JavaLangString :
+		case TypeIds.T_JavaLangString :
 			if (this.targetLevel >= ClassFileConstants.JDK1_5) {
-				declarinClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
 				signature = ConstantPool.StringBuilderAppendStringSignature;
 			} else {
-				declarinClass = ConstantPool.JavaLangStringBufferConstantPoolName;
+				declaringClass = ConstantPool.JavaLangStringBufferConstantPoolName;
 				signature = ConstantPool.StringBufferAppendStringSignature;
 			}
 			break;
 	}
 	this.invoke(
-			OPC_invokevirtual,
+			Opcodes.OPC_invokevirtual,
 			argCount, // argCount
 			returnType, // return type size
-			declarinClass,
+			declaringClass,
 			selector,
 			signature);
 }
-
-public void invokeJavaLangAssertionErrorConstructor(int typeBindingID) {
-	// invokespecial: java.lang.AssertionError.<init>(typeBindingID)V
-	if (DEBUG) System.out.println(position + "\t\tinvokespecial: java.lang.AssertionError.<init>(typeBindingID)V"); //$NON-NLS-1$
-	int argCount = 1;
-	char[] signature = null;
-	switch (typeBindingID) {
-		case T_int :
-		case T_byte :
-		case T_short :
-			signature = ConstantPool.IntConstrSignature;
-			break;
-		case T_long :
-			signature = ConstantPool.LongConstrSignature;
-			argCount = 2;
-			break;
-		case T_float :
-			signature = ConstantPool.FloatConstrSignature;
-			break;
-		case T_double :
-			signature = ConstantPool.DoubleConstrSignature;
-			argCount = 2;
-			break;
-		case T_char :
-			signature = ConstantPool.CharConstrSignature;
-			break;
-		case T_boolean :
-			signature = ConstantPool.BooleanConstrSignature;
-			break;
-		case T_JavaLangObject :
-		case T_JavaLangString :
-		case T_null :
-			signature = ConstantPool.ObjectConstrSignature;
-			break;
-	}
-	this.invoke(
-			OPC_invokespecial,
-			argCount, // argCount
-			0, // return type size
-			ConstantPool.JavaLangAssertionErrorConstantPoolName,
-			ConstantPool.Init,
-			signature);
-}
-
-public void invokeJavaLangAssertionErrorDefaultConstructor() {
-	// invokespecial: java.lang.AssertionError.<init>()V
-	if (DEBUG) System.out.println(position + "\t\tinvokespecial: java.lang.AssertionError.<init>()V"); //$NON-NLS-1$
-	this.invoke(
-			OPC_invokespecial,
-			0, // argCount
-			0, // return type size
-			ConstantPool.JavaLangAssertionErrorConstantPoolName,
-			ConstantPool.Init,
-			ConstantPool.DefaultConstructorSignature);
-}
-public void invokeJavaLangEnumname(TypeBinding typeBinding) {
-	// invokevirtual: java.lang.Enum.name()String
-	if (DEBUG) System.out.println(position + "\t\tinvokevirtual: java.lang.Enum.name()Ljava/lang/String;"); //$NON-NLS-1$
-	this.invoke(
-			OPC_invokevirtual,
-			0,
-			1,
-			typeBinding.constantPoolName(),
-			ConstantPool.Name,
-			ConstantPool.NameSignature);
-}
-public void invokeJavaLangIllegalArgumentExceptionStringConstructor() {
-	// invokespecial: java.lang.IllegalArgumentException.<init>(String)V
-	if (DEBUG) System.out.println(position + "\t\tinvokespecial: java.lang.IllegalArgumentException.<init>(java.lang.String)V"); //$NON-NLS-1$
-	this.invoke(
-			OPC_invokespecial,
-			1, // argCount
-			0, // return type size
-			ConstantPool.JavaLangIllegalArgumentExceptionConstantPoolName,
-			ConstantPool.Init,
-			ConstantPool.StringConstructorSignature);
-}
-
-public void invokeJavaUtilIteratorHasNext() {
-	// invokeinterface java.util.Iterator.hasNext()Z
-	if (DEBUG) System.out.println(position + "\t\tinvokeinterface: java.util.Iterator.hasNext()Z"); //$NON-NLS-1$
-	this.invoke(
-			OPC_invokeinterface,
-			0, // argCount
-			1, // return type size
-			ConstantPool.JavaUtilIteratorConstantPoolName,
-			ConstantPool.HasNext,
-			ConstantPool.HasNextSignature);
-}
-public void invokeJavaUtilIteratorNext() {
-	// invokeinterface java.util.Iterator.next()java.lang.Object
-	if (DEBUG) System.out.println(position + "\t\tinvokeinterface: java.util.Iterator.next()java.lang.Object"); //$NON-NLS-1$
-	this.invoke(
-			OPC_invokeinterface,
-			0, // argCount
-			1, // return type size
-			ConstantPool.JavaUtilIteratorConstantPoolName,
-			ConstantPool.Next,
-			ConstantPool.NextSignature);
-}
 public void invokeStringConcatenationDefaultConstructor() {
 	// invokespecial: java.lang.StringBuffer.<init>()V
 	if (DEBUG) {
@@ -3835,7 +4354,7 @@ public void invokeStringConcatenationDefaultConstructor() {
 		declaringClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
 	}
 	this.invoke(
-			OPC_invokespecial,
+			Opcodes.OPC_invokespecial,
 			0, // argCount
 			0, // return type size
 			declaringClass,
@@ -3855,14 +4374,13 @@ public void invokeStringConcatenationStringConstructor() {
 		declaringClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
 	}
 	this.invoke(
-			OPC_invokespecial,
+			Opcodes.OPC_invokespecial,
 			1, // argCount
 			0, // return type size
 			declaringClass,
 			ConstantPool.Init,
 			ConstantPool.StringConstructorSignature);
 }
-
 public void invokeStringConcatenationToString() {
 	if (DEBUG) {
 		if (this.targetLevel >= ClassFileConstants.JDK1_5) {
@@ -3876,7 +4394,7 @@ public void invokeStringConcatenationToString() {
 		declaringClass = ConstantPool.JavaLangStringBuilderConstantPoolName;
 	}
 	this.invoke(
-			OPC_invokevirtual,
+			Opcodes.OPC_invokevirtual,
 			0, // argCount
 			1, // return type size
 			declaringClass,
@@ -3887,7 +4405,7 @@ public void invokeStringEquals() {
 	// invokevirtual: java.lang.String.equals(java.lang.Object)
 	if (DEBUG) System.out.println(position + "\t\tinvokevirtual: java.lang.String.equals(...)"); //$NON-NLS-1$
 	this.invoke(
-			OPC_invokevirtual,
+			Opcodes.OPC_invokevirtual,
 			1, // argCount
 			1, // return type size
 			ConstantPool.JavaLangStringConstantPoolName,
@@ -3898,7 +4416,7 @@ public void invokeStringIntern() {
 	// invokevirtual: java.lang.String.intern()
 	if (DEBUG) System.out.println(position + "\t\tinvokevirtual: java.lang.String.intern()"); //$NON-NLS-1$
 	this.invoke(
-			OPC_invokevirtual,
+			Opcodes.OPC_invokevirtual,
 			0, // argCount
 			1, // return type size
 			ConstantPool.JavaLangStringConstantPoolName,
@@ -3911,37 +4429,37 @@ public void invokeStringValueOf(int typeID) {
 	int argCount = 1;
 	char[] signature = null;
 	switch (typeID) {
-		case T_int :
-		case T_byte :
-		case T_short :
+		case TypeIds.T_int :
+		case TypeIds.T_byte :
+		case TypeIds.T_short :
 			signature = ConstantPool.ValueOfIntSignature;
 			break;
-		case T_long :
+		case TypeIds.T_long :
 			signature = ConstantPool.ValueOfLongSignature;
 			argCount = 2;
 			break;
-		case T_float :
+		case TypeIds.T_float :
 			signature = ConstantPool.ValueOfFloatSignature;
 			break;
-		case T_double :
+		case TypeIds.T_double :
 			signature = ConstantPool.ValueOfDoubleSignature;
 			argCount = 2;
 			break;
-		case T_char :
+		case TypeIds.T_char :
 			signature = ConstantPool.ValueOfCharSignature;
 			break;
-		case T_boolean :
+		case TypeIds.T_boolean :
 			signature = ConstantPool.ValueOfBooleanSignature;
 			break;
-		case T_JavaLangObject :
-		case T_JavaLangString :
-		case T_null :
-		case T_undefined :
+		case TypeIds.T_JavaLangObject :
+		case TypeIds.T_JavaLangString :
+		case TypeIds.T_null :
+		case TypeIds.T_undefined :
 			signature = ConstantPool.ValueOfObjectSignature;
 			break;
 	}
 	this.invoke(
-			OPC_invokestatic,
+			Opcodes.OPC_invokestatic,
 			argCount, // argCount
 			1, // return type size
 			ConstantPool.JavaLangStringConstantPoolName,
@@ -3952,7 +4470,7 @@ public void invokeSystemArraycopy() {
 	// invokestatic #21 <Method java/lang/System.arraycopy(Ljava/lang/Object;ILjava/lang/Object;II)V>
 	if (DEBUG) System.out.println(position + "\t\tinvokevirtual: java.lang.System.arraycopy(Ljava/lang/Object;ILjava/lang/Object;II)V"); //$NON-NLS-1$
 	this.invoke(
-			OPC_invokestatic,
+			Opcodes.OPC_invokestatic,
 			5, // argCount
 			0, // return type size
 			ConstantPool.JavaLangSystemConstantPoolName,
@@ -3963,52 +4481,14 @@ public void invokeThrowableGetMessage() {
 	// invokevirtual: java.lang.Throwable.getMessage()Ljava.lang.String;
 	if (DEBUG) System.out.println(position + "\t\tinvokevirtual: java.lang.Throwable.getMessage()Ljava.lang.String;"); //$NON-NLS-1$
 	this.invoke(
-			OPC_invokevirtual,
+			Opcodes.OPC_invokevirtual,
 			0, // argCount
 			1, // return type size
 			ConstantPool.JavaLangThrowableConstantPoolName,
 			ConstantPool.GetMessage,
 			ConstantPool.GetMessageSignature);
 }
-final public void invoke(int opcode, int argsSize, int returnTypeSize, char[] declaringClass, char[] selector, char[] signature) {
-	countLabels = 0;
-	int argCount = argsSize;
-	switch(opcode) {
-		case OPC_invokeinterface :
-			if (classFileOffset + 4 >= bCodeStream.length) {
-				resizeByteArray();
-			}
-			position +=3;
-			bCodeStream[classFileOffset++] = OPC_invokeinterface;
-			writeUnsignedShort(constantPool.literalIndexForMethod(declaringClass, selector, signature, true));
-			argCount++;
-			bCodeStream[classFileOffset++] = (byte) argCount;
-			bCodeStream[classFileOffset++] = 0;
-			break;
-		case OPC_invokevirtual :
-		case OPC_invokespecial :
-			if (classFileOffset + 2 >= bCodeStream.length) {
-				resizeByteArray();
-			}
-			position++;
-			bCodeStream[classFileOffset++] = (byte) opcode;
-			writeUnsignedShort(constantPool.literalIndexForMethod(declaringClass, selector, signature, false));
-			argCount++;
-			break;
-		case OPC_invokestatic :
-			if (classFileOffset + 2 >= bCodeStream.length) {
-				resizeByteArray();
-			}
-			position++;
-			bCodeStream[classFileOffset++] = OPC_invokestatic;
-			writeUnsignedShort(constantPool.literalIndexForMethod(declaringClass, selector, signature, false));
-	}
-	stackDepth += returnTypeSize - argCount;
-	if (stackDepth > stackMax) {
-		stackMax = stackDepth;
-	}
-}
-final public void invokevirtual(MethodBinding methodBinding) {
+public void invokevirtual(MethodBinding methodBinding) {
 	if (DEBUG) System.out.println(position + "\t\tinvokevirtual:"+methodBinding); //$NON-NLS-1$
 	// initialized to 1 to take into account this  immediately
 	countLabels = 0;
@@ -4018,7 +4498,7 @@ final public void invokevirtual(MethodBinding methodBinding) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_invokevirtual;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_invokevirtual;
 	writeUnsignedShort(
 		constantPool.literalIndexForMethod(
 			methodBinding.constantPoolDeclaringClass().constantPoolName(),
@@ -4026,21 +4506,21 @@ final public void invokevirtual(MethodBinding methodBinding) {
 			methodBinding.signature(),
 			false));
 	for (int i = methodBinding.parameters.length - 1; i >= 0; i--)
-		if (((id = methodBinding.parameters[i].id) == T_double) || (id == T_long))
+		if (((id = methodBinding.parameters[i].id) == TypeIds.T_double) || (id == TypeIds.T_long))
 			argCount += 2;
 		else
 			argCount++;
-	if (((id = methodBinding.returnType.id) == T_double) || (id == T_long))
+	if (((id = methodBinding.returnType.id) == TypeIds.T_double) || (id == TypeIds.T_long))
 		stackDepth += (2 - argCount);
 	else
-		if (id == T_void)
+		if (id == TypeIds.T_void)
 			stackDepth -= argCount;
 		else
 			stackDepth += (1 - argCount);
 	if (stackDepth > stackMax)
 		stackMax = stackDepth;
 }
-final public void ior() {
+public void ior() {
 	if (DEBUG) System.out.println(position + "\t\tior"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -4048,9 +4528,9 @@ final public void ior() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_ior;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_ior;
 }
-final public void irem() {
+public void irem() {
 	if (DEBUG) System.out.println(position + "\t\tirem"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -4058,9 +4538,9 @@ final public void irem() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_irem;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_irem;
 }
-final public void ireturn() {
+public void ireturn() {
 	if (DEBUG) System.out.println(position + "\t\tireturn"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -4069,7 +4549,7 @@ final public void ireturn() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_ireturn;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_ireturn;
 }
 public boolean isDefinitelyAssigned(Scope scope, int initStateIndex, LocalVariableBinding local) {
 	// Dependant of UnconditionalFlowInfo.isDefinitelyAssigned(..)
@@ -4093,7 +4573,7 @@ public boolean isDefinitelyAssigned(Scope scope, int initStateIndex, LocalVariab
 		return false; // if not enough room in vector, then not initialized 
 	return ((extraInits[vectorIndex]) & (1L << (localPosition % UnconditionalFlowInfo.BitCacheSize))) != 0;
 }
-final public void ishl() {
+public void ishl() {
 	if (DEBUG) System.out.println(position + "\t\tishl"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -4101,9 +4581,9 @@ final public void ishl() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_ishl;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_ishl;
 }
-final public void ishr() {
+public void ishr() {
 	if (DEBUG) System.out.println(position + "\t\tishr"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -4111,9 +4591,9 @@ final public void ishr() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_ishr;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_ishr;
 }
-final public void istore(int iArg) {
+public void istore(int iArg) {
 	if (DEBUG) System.out.println(position + "\t\tistore:"+iArg); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -4125,19 +4605,19 @@ final public void istore(int iArg) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_wide;
-		bCodeStream[classFileOffset++] = OPC_istore;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_wide;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_istore;
 		writeUnsignedShort(iArg);
 	} else {
 		if (classFileOffset + 1 >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_istore;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_istore;
 		bCodeStream[classFileOffset++] = (byte) iArg;
 	}
 }
-final public void istore_0() {
+public void istore_0() {
 	if (DEBUG) System.out.println(position + "\t\tistore_0"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -4148,9 +4628,9 @@ final public void istore_0() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_istore_0;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_istore_0;
 }
-final public void istore_1() {
+public void istore_1() {
 	if (DEBUG) System.out.println(position + "\t\tistore_1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -4161,9 +4641,9 @@ final public void istore_1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_istore_1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_istore_1;
 }
-final public void istore_2() {
+public void istore_2() {
 	if (DEBUG) System.out.println(position + "\t\tistore_2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -4174,9 +4654,9 @@ final public void istore_2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_istore_2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_istore_2;
 }
-final public void istore_3() {
+public void istore_3() {
 	if (DEBUG) System.out.println(position + "\t\tistore_3"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -4187,9 +4667,9 @@ final public void istore_3() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_istore_3;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_istore_3;
 }
-final public void isub() {
+public void isub() {
 	if (DEBUG) System.out.println(position + "\t\tisub"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -4197,9 +4677,9 @@ final public void isub() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_isub;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_isub;
 }
-final public void iushr() {
+public void iushr() {
 	if (DEBUG) System.out.println(position + "\t\tiushr"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -4207,9 +4687,9 @@ final public void iushr() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_iushr;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_iushr;
 }
-final public void ixor() {
+public void ixor() {
 	if (DEBUG) System.out.println(position + "\t\tixor"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -4217,7 +4697,7 @@ final public void ixor() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_ixor;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_ixor;
 }
 final public void jsr(Label lbl) {
 	if (this.wideMode) {
@@ -4230,7 +4710,7 @@ final public void jsr(Label lbl) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_jsr;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_jsr;
 	lbl.branch();
 }
 final public void jsr_w(Label lbl) {
@@ -4240,19 +4720,19 @@ final public void jsr_w(Label lbl) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_jsr_w;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_jsr_w;
 	lbl.branchWide();
 }
-final public void l2d() {
+public void l2d() {
 	if (DEBUG) System.out.println(position + "\t\tl2d"); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_l2d;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_l2d;
 }
-final public void l2f() {
+public void l2f() {
 	if (DEBUG) System.out.println(position + "\t\tl2f"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -4260,9 +4740,9 @@ final public void l2f() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_l2f;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_l2f;
 }
-final public void l2i() {
+public void l2i() {
 	if (DEBUG) System.out.println(position + "\t\tl2i"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -4270,9 +4750,9 @@ final public void l2i() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_l2i;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_l2i;
 }
-final public void ladd() {
+public void ladd() {
 	if (DEBUG) System.out.println(position + "\t\tladd"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -4280,18 +4760,18 @@ final public void ladd() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_ladd;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_ladd;
 }
-final public void laload() {
+public void laload() {
 	if (DEBUG) System.out.println(position + "\t\tlaload"); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_laload;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_laload;
 }
-final public void land() {
+public void land() {
 	if (DEBUG) System.out.println(position + "\t\tland"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -4299,9 +4779,9 @@ final public void land() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_land;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_land;
 }
-final public void lastore() {
+public void lastore() {
 	if (DEBUG) System.out.println(position + "\t\tlastore"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 4;
@@ -4309,9 +4789,9 @@ final public void lastore() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lastore;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lastore;
 }
-final public void lcmp() {
+public void lcmp() {
 	if (DEBUG) System.out.println(position + "\t\tlcmp"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 3;
@@ -4319,9 +4799,9 @@ final public void lcmp() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lcmp;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lcmp;
 }
-final public void lconst_0() {
+public void lconst_0() {
 	if (DEBUG) System.out.println(position + "\t\tlconst_0"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -4331,9 +4811,9 @@ final public void lconst_0() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lconst_0;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lconst_0;
 }
-final public void lconst_1() {
+public void lconst_1() {
 	if (DEBUG) System.out.println(position + "\t\tlconst_1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -4343,9 +4823,9 @@ final public void lconst_1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lconst_1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lconst_1;
 }
-final public void ldc(float constant) {
+public void ldc(float constant) {
 	countLabels = 0;
 	int index = constantPool.literalIndex(constant);
 	stackDepth++;
@@ -4358,7 +4838,7 @@ final public void ldc(float constant) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_ldc_w;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_ldc_w;
 		writeUnsignedShort(index);
 	} else {
 		if (DEBUG) System.out.println(position + "\t\tldc:"+constant); //$NON-NLS-1$
@@ -4367,11 +4847,11 @@ final public void ldc(float constant) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_ldc;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_ldc;
 		bCodeStream[classFileOffset++] = (byte) index;
 	}
 }
-final public void ldc(int constant) {
+public void ldc(int constant) {
 	countLabels = 0;
 	int index = constantPool.literalIndex(constant);
 	stackDepth++;
@@ -4384,7 +4864,7 @@ final public void ldc(int constant) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_ldc_w;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_ldc_w;
 		writeUnsignedShort(index);
 	} else {
 		if (DEBUG) System.out.println(position + "\t\tldc:"+constant); //$NON-NLS-1$
@@ -4393,11 +4873,11 @@ final public void ldc(int constant) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_ldc;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_ldc;
 		bCodeStream[classFileOffset++] = (byte) index;
 	}
 }
-final public void ldc(String constant) {
+public void ldc(String constant) {
 	countLabels = 0;
 	int currentConstantPoolIndex = constantPool.currentIndex;
 	int currentConstantPoolOffset = constantPool.currentOffset;
@@ -4416,7 +4896,7 @@ final public void ldc(String constant) {
 				resizeByteArray();
 			}
 			position++;
-			bCodeStream[classFileOffset++] = OPC_ldc_w;
+			bCodeStream[classFileOffset++] = Opcodes.OPC_ldc_w;
 			writeUnsignedShort(index);
 		} else {
 			if (DEBUG) System.out.println(position + "\t\tldc:"+constant); //$NON-NLS-1$
@@ -4425,7 +4905,7 @@ final public void ldc(String constant) {
 				resizeByteArray();
 			}
 			position += 2;
-			bCodeStream[classFileOffset++] = OPC_ldc;
+			bCodeStream[classFileOffset++] = Opcodes.OPC_ldc;
 			bCodeStream[classFileOffset++] = (byte) index;
 		}
 	} else {
@@ -4486,7 +4966,7 @@ final public void ldc(String constant) {
 				resizeByteArray();
 			}
 			position++;
-			bCodeStream[classFileOffset++] = OPC_ldc_w;
+			bCodeStream[classFileOffset++] = Opcodes.OPC_ldc_w;
 			writeUnsignedShort(index);
 		} else {
 			// Generate a ldc
@@ -4494,7 +4974,7 @@ final public void ldc(String constant) {
 				resizeByteArray();
 			}
 			position += 2;
-			bCodeStream[classFileOffset++] = OPC_ldc;
+			bCodeStream[classFileOffset++] = Opcodes.OPC_ldc;
 			bCodeStream[classFileOffset++] = (byte) index;
 		}
 		// write the remaining part
@@ -4541,7 +5021,7 @@ final public void ldc(String constant) {
 					resizeByteArray();
 				}
 				position++;
-				bCodeStream[classFileOffset++] = OPC_ldc_w;
+				bCodeStream[classFileOffset++] = Opcodes.OPC_ldc_w;
 				writeUnsignedShort(index);
 			} else {
 				// Generate a ldc
@@ -4549,17 +5029,17 @@ final public void ldc(String constant) {
 					resizeByteArray();
 				}
 				position += 2;
-				bCodeStream[classFileOffset++] = OPC_ldc;
+				bCodeStream[classFileOffset++] = Opcodes.OPC_ldc;
 				bCodeStream[classFileOffset++] = (byte) index;
 			}
 			// now on the stack it should be a StringBuffer and a string.
-			invokeStringConcatenationAppendForType(T_JavaLangString);
+			invokeStringConcatenationAppendForType(TypeIds.T_JavaLangString);
 		}
 		invokeStringConcatenationToString();
 		invokeStringIntern();
 	}
 }
-final public void ldc(TypeBinding typeBinding) {
+public void ldc(TypeBinding typeBinding) {
 	countLabels = 0;
 	int index = constantPool.literalIndexForType(typeBinding.constantPoolName());
 	stackDepth++;
@@ -4572,7 +5052,7 @@ final public void ldc(TypeBinding typeBinding) {
 			resizeByteArray();
 		}
 		position++;
-		bCodeStream[classFileOffset++] = OPC_ldc_w;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_ldc_w;
 		writeUnsignedShort(index);
 	} else {
 		if (DEBUG) System.out.println(position + "\t\tldw:"+ typeBinding); //$NON-NLS-1$
@@ -4581,11 +5061,11 @@ final public void ldc(TypeBinding typeBinding) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_ldc;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_ldc;
 		bCodeStream[classFileOffset++] = (byte) index;
 	}
 }
-final public void ldc2_w(double constant) {
+public void ldc2_w(double constant) {
 	if (DEBUG) System.out.println(position + "\t\tldc2_w:"+constant); //$NON-NLS-1$
 	countLabels = 0;
 	int index = constantPool.literalIndex(constant);
@@ -4597,10 +5077,10 @@ final public void ldc2_w(double constant) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_ldc2_w;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_ldc2_w;
 	writeUnsignedShort(index);
 }
-final public void ldc2_w(long constant) {
+public void ldc2_w(long constant) {
 	if (DEBUG) System.out.println(position + "\t\tldc2_w:"+constant); //$NON-NLS-1$
 	countLabels = 0;
 	int index = constantPool.literalIndex(constant);
@@ -4612,10 +5092,10 @@ final public void ldc2_w(long constant) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_ldc2_w;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_ldc2_w;
 	writeUnsignedShort(index);
 }
-final public void ldiv() {
+public void ldiv() {
 	if (DEBUG) System.out.println(position + "\t\tldiv"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -4623,9 +5103,9 @@ final public void ldiv() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_ldiv;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_ldiv;
 }
-final public void lload(int iArg) {
+public void lload(int iArg) {
 	if (DEBUG) System.out.println(position + "\t\tlload:"+iArg); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -4639,19 +5119,19 @@ final public void lload(int iArg) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_wide;
-		bCodeStream[classFileOffset++] = OPC_lload;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_wide;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_lload;
 		writeUnsignedShort(iArg);
 	} else {
 		if (classFileOffset + 1 >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_lload;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_lload;
 		bCodeStream[classFileOffset++] = (byte) iArg;
 	}
 }
-final public void lload_0() {
+public void lload_0() {
 	if (DEBUG) System.out.println(position + "\t\tlload_0"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -4664,9 +5144,9 @@ final public void lload_0() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lload_0;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lload_0;
 }
-final public void lload_1() {
+public void lload_1() {
 	if (DEBUG) System.out.println(position + "\t\tlload_1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -4679,9 +5159,9 @@ final public void lload_1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lload_1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lload_1;
 }
-final public void lload_2() {
+public void lload_2() {
 	if (DEBUG) System.out.println(position + "\t\tlload_2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -4694,9 +5174,9 @@ final public void lload_2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lload_2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lload_2;
 }
-final public void lload_3() {
+public void lload_3() {
 	if (DEBUG) System.out.println(position + "\t\tlload_3"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth += 2;
@@ -4708,313 +5188,134 @@ final public void lload_3() {
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
-	position++;
-	bCodeStream[classFileOffset++] = OPC_lload_3;
-}
-final public void lmul() {
-	if (DEBUG) System.out.println(position + "\t\tlmul"); //$NON-NLS-1$
-	countLabels = 0;
-	stackDepth -= 2;
-	if (classFileOffset >= bCodeStream.length) {
-		resizeByteArray();
-	}
-	position++;
-	bCodeStream[classFileOffset++] = OPC_lmul;
-}
-final public void lneg() {
-	if (DEBUG) System.out.println(position + "\t\tlneg"); //$NON-NLS-1$
-	countLabels = 0;
-	if (classFileOffset >= bCodeStream.length) {
-		resizeByteArray();
-	}
-	position++;
-	bCodeStream[classFileOffset++] = OPC_lneg;
-}
-public final void load(LocalVariableBinding localBinding) {
-	countLabels = 0;
-	TypeBinding typeBinding = localBinding.type;
-	int resolvedPosition = localBinding.resolvedPosition;
-	// Using dedicated int bytecode
-	if (typeBinding == TypeBinding.INT) {
-		switch (resolvedPosition) {
-			case 0 :
-				this.iload_0();
-				break;
-			case 1 :
-				this.iload_1();
-				break;
-			case 2 :
-				this.iload_2();
-				break;
-			case 3 :
-				this.iload_3();
-				break;
-			//case -1 :
-			// internal failure: trying to load variable not supposed to be generated
-			//	break;
-			default :
-				this.iload(resolvedPosition);
-		}
-		return;
-	}
-	// Using dedicated float bytecode
-	if (typeBinding == TypeBinding.FLOAT) {
-		switch (resolvedPosition) {
-			case 0 :
-				this.fload_0();
-				break;
-			case 1 :
-				this.fload_1();
-				break;
-			case 2 :
-				this.fload_2();
-				break;
-			case 3 :
-				this.fload_3();
-				break;
-			default :
-				this.fload(resolvedPosition);
-		}
-		return;
-	}
-	// Using dedicated long bytecode
-	if (typeBinding == TypeBinding.LONG) {
-		switch (resolvedPosition) {
-			case 0 :
-				this.lload_0();
-				break;
-			case 1 :
-				this.lload_1();
-				break;
-			case 2 :
-				this.lload_2();
-				break;
-			case 3 :
-				this.lload_3();
-				break;
-			default :
-				this.lload(resolvedPosition);
-		}
-		return;
-	}
-	// Using dedicated double bytecode
-	if (typeBinding == TypeBinding.DOUBLE) {
-		switch (resolvedPosition) {
-			case 0 :
-				this.dload_0();
-				break;
-			case 1 :
-				this.dload_1();
-				break;
-			case 2 :
-				this.dload_2();
-				break;
-			case 3 :
-				this.dload_3();
-				break;
-			default :
-				this.dload(resolvedPosition);
-		}
-		return;
-	}
-	// boolean, byte, char and short are handled as int
-	if ((typeBinding == TypeBinding.BYTE) || (typeBinding == TypeBinding.CHAR) || (typeBinding == TypeBinding.BOOLEAN) || (typeBinding == TypeBinding.SHORT)) {
-		switch (resolvedPosition) {
-			case 0 :
-				this.iload_0();
-				break;
-			case 1 :
-				this.iload_1();
-				break;
-			case 2 :
-				this.iload_2();
-				break;
-			case 3 :
-				this.iload_3();
-				break;
-			default :
-				this.iload(resolvedPosition);
-		}
-		return;
-	}
-
-	// Reference object
-	switch (resolvedPosition) {
-		case 0 :
-			this.aload_0();
-			break;
-		case 1 :
-			this.aload_1();
-			break;
-		case 2 :
-			this.aload_2();
-			break;
-		case 3 :
-			this.aload_3();
-			break;
-		default :
-			this.aload(resolvedPosition);
-	}
-}
-public final void load(TypeBinding typeBinding, int resolvedPosition) {
-	countLabels = 0;
-	// Using dedicated int bytecode
-	if (typeBinding == TypeBinding.INT) {
-		switch (resolvedPosition) {
-			case 0 :
-				this.iload_0();
-				break;
-			case 1 :
-				this.iload_1();
-				break;
-			case 2 :
-				this.iload_2();
-				break;
-			case 3 :
-				this.iload_3();
-				break;
-			default :
-				this.iload(resolvedPosition);
-		}
-		return;
-	}
-	// Using dedicated float bytecode
-	if (typeBinding == TypeBinding.FLOAT) {
-		switch (resolvedPosition) {
-			case 0 :
-				this.fload_0();
-				break;
-			case 1 :
-				this.fload_1();
-				break;
-			case 2 :
-				this.fload_2();
-				break;
-			case 3 :
-				this.fload_3();
-				break;
-			default :
-				this.fload(resolvedPosition);
-		}
-		return;
-	}
-	// Using dedicated long bytecode
-	if (typeBinding == TypeBinding.LONG) {
-		switch (resolvedPosition) {
-			case 0 :
-				this.lload_0();
-				break;
-			case 1 :
-				this.lload_1();
-				break;
-			case 2 :
-				this.lload_2();
-				break;
-			case 3 :
-				this.lload_3();
-				break;
-			default :
-				this.lload(resolvedPosition);
-		}
-		return;
-	}
-	// Using dedicated double bytecode
-	if (typeBinding == TypeBinding.DOUBLE) {
-		switch (resolvedPosition) {
-			case 0 :
-				this.dload_0();
-				break;
-			case 1 :
-				this.dload_1();
-				break;
-			case 2 :
-				this.dload_2();
-				break;
-			case 3 :
-				this.dload_3();
-				break;
-			default :
-				this.dload(resolvedPosition);
-		}
-		return;
-	}
-	// boolean, byte, char and short are handled as int
-	if ((typeBinding == TypeBinding.BYTE) || (typeBinding == TypeBinding.CHAR) || (typeBinding == TypeBinding.BOOLEAN) || (typeBinding == TypeBinding.SHORT)) {
-		switch (resolvedPosition) {
-			case 0 :
-				this.iload_0();
-				break;
-			case 1 :
-				this.iload_1();
-				break;
-			case 2 :
-				this.iload_2();
-				break;
-			case 3 :
-				this.iload_3();
-				break;
-			default :
-				this.iload(resolvedPosition);
-		}
-		return;
-	}
-
-	// Reference object
-	switch (resolvedPosition) {
-		case 0 :
-			this.aload_0();
-			break;
-		case 1 :
-			this.aload_1();
-			break;
-		case 2 :
-			this.aload_2();
-			break;
-		case 3 :
-			this.aload_3();
-			break;
-		default :
-			this.aload(resolvedPosition);
-	}
+	position++;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lload_3;
 }
-public final void loadInt(int resolvedPosition) {
-	// Using dedicated int bytecode
-	switch (resolvedPosition) {
-		case 0 :
-			this.iload_0();
-			break;
-		case 1 :
-			this.iload_1();
-			break;
-		case 2 :
-			this.iload_2();
-			break;
-		case 3 :
-			this.iload_3();
-			break;
-		default :
-			this.iload(resolvedPosition);
+public void lmul() {
+	if (DEBUG) System.out.println(position + "\t\tlmul"); //$NON-NLS-1$
+	countLabels = 0;
+	stackDepth -= 2;
+	if (classFileOffset >= bCodeStream.length) {
+		resizeByteArray();
 	}
+	position++;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lmul;
 }
-public final void loadObject(int resolvedPosition) {
-	switch (resolvedPosition) {
-		case 0 :
-			this.aload_0();
+public void lneg() {
+	if (DEBUG) System.out.println(position + "\t\tlneg"); //$NON-NLS-1$
+	countLabels = 0;
+	if (classFileOffset >= bCodeStream.length) {
+		resizeByteArray();
+	}
+	position++;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lneg;
+}
+public final void load(LocalVariableBinding localBinding) {
+	load(localBinding.type, localBinding.resolvedPosition);
+}
+public final void load(TypeBinding typeBinding, int resolvedPosition) {
+	countLabels = 0;
+	// Using dedicated int bytecode
+	switch(typeBinding.id) {
+		case TypeIds.T_int :
+		case TypeIds.T_byte :
+		case TypeIds.T_char :
+		case TypeIds.T_boolean :
+		case TypeIds.T_short :
+			switch (resolvedPosition) {
+				case 0 :
+					this.iload_0();
+					break;
+				case 1 :
+					this.iload_1();
+					break;
+				case 2 :
+					this.iload_2();
+					break;
+				case 3 :
+					this.iload_3();
+					break;
+				//case -1 :
+				// internal failure: trying to load variable not supposed to be generated
+				//	break;
+				default :
+					this.iload(resolvedPosition);
+			}
 			break;
-		case 1 :
-			this.aload_1();
+		case TypeIds.T_float :
+			switch (resolvedPosition) {
+				case 0 :
+					this.fload_0();
+					break;
+				case 1 :
+					this.fload_1();
+					break;
+				case 2 :
+					this.fload_2();
+					break;
+				case 3 :
+					this.fload_3();
+					break;
+				default :
+					this.fload(resolvedPosition);
+			}
 			break;
-		case 2 :
-			this.aload_2();
+		case TypeIds.T_long :
+			switch (resolvedPosition) {
+				case 0 :
+					this.lload_0();
+					break;
+				case 1 :
+					this.lload_1();
+					break;
+				case 2 :
+					this.lload_2();
+					break;
+				case 3 :
+					this.lload_3();
+					break;
+				default :
+					this.lload(resolvedPosition);
+			}
 			break;
-		case 3 :
-			this.aload_3();
+		case TypeIds.T_double :
+			switch (resolvedPosition) {
+				case 0 :
+					this.dload_0();
+					break;
+				case 1 :
+					this.dload_1();
+					break;
+				case 2 :
+					this.dload_2();
+					break;
+				case 3 :
+					this.dload_3();
+					break;
+				default :
+					this.dload(resolvedPosition);
+			}
 			break;
 		default :
-			this.aload(resolvedPosition);
+			switch (resolvedPosition) {
+				case 0 :
+					this.aload_0();
+					break;
+				case 1 :
+					this.aload_1();
+					break;
+				case 2 :
+					this.aload_2();
+					break;
+				case 3 :
+					this.aload_3();
+					break;
+				default :
+					this.aload(resolvedPosition);
+			}
 	}
 }
-final public void lookupswitch(CaseLabel defaultLabel, int[] keys, int[] sortedIndexes, CaseLabel[] casesLabel) {
+public void lookupswitch(CaseLabel defaultLabel, int[] keys, int[] sortedIndexes, CaseLabel[] casesLabel) {
 	if (DEBUG) System.out.println(position + "\t\tlookupswitch"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -5028,7 +5329,7 @@ final public void lookupswitch(CaseLabel defaultLabel, int[] keys, int[] sortedI
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lookupswitch;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lookupswitch;
 	for (int i = (3 - (pos % 4)); i > 0; i--) {
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
@@ -5043,7 +5344,7 @@ final public void lookupswitch(CaseLabel defaultLabel, int[] keys, int[] sortedI
 		casesLabel[sortedIndexes[i]].branch();
 	}
 }
-final public void lor() {
+public void lor() {
 	if (DEBUG) System.out.println(position + "\t\tlor"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -5051,9 +5352,9 @@ final public void lor() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lor;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lor;
 }
-final public void lrem() {
+public void lrem() {
 	if (DEBUG) System.out.println(position + "\t\tlrem"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -5061,9 +5362,9 @@ final public void lrem() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lrem;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lrem;
 }
-final public void lreturn() {
+public void lreturn() {
 	if (DEBUG) System.out.println(position + "\t\tlreturn"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -5072,9 +5373,9 @@ final public void lreturn() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lreturn;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lreturn;
 }
-final public void lshl() {
+public void lshl() {
 	if (DEBUG) System.out.println(position + "\t\tlshl"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -5082,9 +5383,9 @@ final public void lshl() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lshl;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lshl;
 }
-final public void lshr() {
+public void lshr() {
 	if (DEBUG) System.out.println(position + "\t\tlshr"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -5092,9 +5393,9 @@ final public void lshr() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lshr;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lshr;
 }
-final public void lstore(int iArg) {
+public void lstore(int iArg) {
 	if (DEBUG) System.out.println(position + "\t\tlstore:"+iArg); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -5106,19 +5407,19 @@ final public void lstore(int iArg) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_wide;
-		bCodeStream[classFileOffset++] = OPC_lstore;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_wide;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_lstore;
 		writeUnsignedShort(iArg);
 	} else {
 		if (classFileOffset + 1 >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_lstore;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_lstore;
 		bCodeStream[classFileOffset++] = (byte) iArg;
 	}
 }
-final public void lstore_0() {
+public void lstore_0() {
 	if (DEBUG) System.out.println(position + "\t\tlstore_0"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -5129,9 +5430,9 @@ final public void lstore_0() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lstore_0;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lstore_0;
 }
-final public void lstore_1() {
+public void lstore_1() {
 	if (DEBUG) System.out.println(position + "\t\tlstore_1"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -5142,9 +5443,9 @@ final public void lstore_1() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lstore_1;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lstore_1;
 }
-final public void lstore_2() {
+public void lstore_2() {
 	if (DEBUG) System.out.println(position + "\t\tlstore_2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -5155,9 +5456,9 @@ final public void lstore_2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lstore_2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lstore_2;
 }
-final public void lstore_3() {
+public void lstore_3() {
 	if (DEBUG) System.out.println(position + "\t\tlstore_3"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -5168,9 +5469,9 @@ final public void lstore_3() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lstore_3;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lstore_3;
 }
-final public void lsub() {
+public void lsub() {
 	if (DEBUG) System.out.println(position + "\t\tlsub"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -5178,9 +5479,9 @@ final public void lsub() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lsub;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lsub;
 }
-final public void lushr() {
+public void lushr() {
 	if (DEBUG) System.out.println(position + "\t\tlushr"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -5188,9 +5489,9 @@ final public void lushr() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lushr;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lushr;
 }
-final public void lxor() {
+public void lxor() {
 	if (DEBUG) System.out.println(position + "\t\tlxor"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -5198,9 +5499,9 @@ final public void lxor() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_lxor;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_lxor;
 }
-final public void monitorenter() {
+public void monitorenter() {
 	if (DEBUG) System.out.println(position + "\t\tmonitorenter"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -5208,9 +5509,9 @@ final public void monitorenter() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_monitorenter;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_monitorenter;
 }
-final public void monitorexit() {
+public void monitorexit() {
 	if (DEBUG) System.out.println(position + "\t\tmonitorexit"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -5218,9 +5519,9 @@ final public void monitorexit() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_monitorexit;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_monitorexit;
 }
-final public void multianewarray(TypeBinding typeBinding, int dimensions) {
+public void multianewarray(TypeBinding typeBinding, int dimensions) {
 	if (DEBUG) System.out.println(position + "\t\tmultinewarray:"+typeBinding+","+dimensions); //$NON-NLS-1$ //$NON-NLS-2$
 	countLabels = 0;
 	stackDepth += (1 - dimensions);
@@ -5228,14 +5529,12 @@ final public void multianewarray(TypeBinding typeBinding, int dimensions) {
 		resizeByteArray();
 	}
 	position += 2;
-	bCodeStream[classFileOffset++] = OPC_multianewarray;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_multianewarray;
 	writeUnsignedShort(constantPool.literalIndexForType(typeBinding.constantPoolName()));
 	bCodeStream[classFileOffset++] = (byte) dimensions;
 }
-/**
- * We didn't call it new, because there is a conflit with the new keyword
- */
-final public void new_(TypeBinding typeBinding) {
+// We didn't call it new, because there is a conflit with the new keyword
+public void new_(TypeBinding typeBinding) {
 	if (DEBUG) System.out.println(position + "\t\tnew:"+typeBinding.debugName()); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -5245,53 +5544,53 @@ final public void new_(TypeBinding typeBinding) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_new;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_new;
 	writeUnsignedShort(constantPool.literalIndexForType(typeBinding.constantPoolName()));
 }
-final public void newarray(int array_Type) {
+public void newarray(int array_Type) {
 	if (DEBUG) System.out.println(position + "\t\tnewarray:"+array_Type); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset + 1 >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position += 2;
-	bCodeStream[classFileOffset++] = OPC_newarray;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_newarray;
 	bCodeStream[classFileOffset++] = (byte) array_Type;
 }
 public void newArray(ArrayBinding arrayBinding) {
 	TypeBinding component = arrayBinding.elementsType();
 	switch (component.id) {
-		case T_int :
+		case TypeIds.T_int :
 			this.newarray(ClassFileConstants.INT_ARRAY);
 			break;
-		case T_byte :
+		case TypeIds.T_byte :
 			this.newarray(ClassFileConstants.BYTE_ARRAY);
 			break;
-		case T_boolean :
+		case TypeIds.T_boolean :
 			this.newarray(ClassFileConstants.BOOLEAN_ARRAY);
 			break;
-		case T_short :
+		case TypeIds.T_short :
 			this.newarray(ClassFileConstants.SHORT_ARRAY);
 			break;
-		case T_char :
+		case TypeIds.T_char :
 			this.newarray(ClassFileConstants.CHAR_ARRAY);
 			break;
-		case T_long :
+		case TypeIds.T_long :
 			this.newarray(ClassFileConstants.LONG_ARRAY);
 			break;
-		case T_float :
+		case TypeIds.T_float :
 			this.newarray(ClassFileConstants.FLOAT_ARRAY);
 			break;
-		case T_double :
+		case TypeIds.T_double :
 			this.newarray(ClassFileConstants.DOUBLE_ARRAY);
 			break;
 		default :
 			this.anewarray(component);
 	}
 }
-public void newJavaLangError() {
-	// new: java.lang.Error
-	if (DEBUG) System.out.println(position + "\t\tnew: java.lang.Error"); //$NON-NLS-1$
+public void newJavaLangAssertionError() {
+	// new: java.lang.AssertionError
+	if (DEBUG) System.out.println(position + "\t\tnew: java.lang.AssertionError"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
 	if (stackDepth > stackMax)
@@ -5300,13 +5599,12 @@ public void newJavaLangError() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_new;
-	writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangErrorConstantPoolName));
+	bCodeStream[classFileOffset++] = Opcodes.OPC_new;
+	writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangAssertionErrorConstantPoolName));
 }
-
-public void newJavaLangAssertionError() {
-	// new: java.lang.AssertionError
-	if (DEBUG) System.out.println(position + "\t\tnew: java.lang.AssertionError"); //$NON-NLS-1$
+public void newJavaLangError() {
+	// new: java.lang.Error
+	if (DEBUG) System.out.println(position + "\t\tnew: java.lang.Error"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
 	if (stackDepth > stackMax)
@@ -5315,8 +5613,8 @@ public void newJavaLangAssertionError() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_new;
-	writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangAssertionErrorConstantPoolName));
+	bCodeStream[classFileOffset++] = Opcodes.OPC_new;
+	writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangErrorConstantPoolName));
 }
 public void newJavaLangIllegalArgumentException() {
 	// new: java.lang.IllegalArgumentException
@@ -5329,7 +5627,7 @@ public void newJavaLangIllegalArgumentException() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_new;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_new;
 	writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangIllegalArgumentExceptionConstantPoolName));
 }
 public void newNoClassDefFoundError() {
@@ -5343,7 +5641,7 @@ public void newNoClassDefFoundError() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_new;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_new;
 	writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangNoClassDefFoundErrorConstantPoolName));
 }
 public void newStringContatenation() {
@@ -5365,7 +5663,7 @@ public void newStringContatenation() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_new;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_new;
 	if (this.targetLevel >= ClassFileConstants.JDK1_5) {
 		writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangStringBuilderConstantPoolName));
 	} else {
@@ -5381,55 +5679,75 @@ public void newWrapperFor(int typeID) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_new;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_new;
 	switch (typeID) {
-		case T_int : // new: java.lang.Integer
+		case TypeIds.T_int : // new: java.lang.Integer
 			if (DEBUG) System.out.println(position + "\t\tnew: java.lang.Integer"); //$NON-NLS-1$
 			writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangIntegerConstantPoolName));
 			break;
-		case T_boolean : // new: java.lang.Boolean
+		case TypeIds.T_boolean : // new: java.lang.Boolean
 			if (DEBUG) System.out.println(position + "\t\tnew: java.lang.Boolean"); //$NON-NLS-1$
 			writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangBooleanConstantPoolName));
 			break;
-		case T_byte : // new: java.lang.Byte
+		case TypeIds.T_byte : // new: java.lang.Byte
 			if (DEBUG) System.out.println(position + "\t\tnew: java.lang.Byte"); //$NON-NLS-1$
 			writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangByteConstantPoolName));
 			break;
-		case T_char : // new: java.lang.Character
+		case TypeIds.T_char : // new: java.lang.Character
 			if (DEBUG) System.out.println(position + "\t\tnew: java.lang.Character"); //$NON-NLS-1$
 			writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangCharacterConstantPoolName));
 			break;
-		case T_float : // new: java.lang.Float
+		case TypeIds.T_float : // new: java.lang.Float
 			if (DEBUG) System.out.println(position + "\t\tnew: java.lang.Float"); //$NON-NLS-1$
 			writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangFloatConstantPoolName));
 			break;
-		case T_double : // new: java.lang.Double
+		case TypeIds.T_double : // new: java.lang.Double
 			if (DEBUG) System.out.println(position + "\t\tnew: java.lang.Double"); //$NON-NLS-1$
 			writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangDoubleConstantPoolName));
 			break;
-		case T_short : // new: java.lang.Short
+		case TypeIds.T_short : // new: java.lang.Short
 			if (DEBUG) System.out.println(position + "\t\tnew: java.lang.Short"); //$NON-NLS-1$
 			writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangShortConstantPoolName));
 			break;
-		case T_long : // new: java.lang.Long
+		case TypeIds.T_long : // new: java.lang.Long
 			if (DEBUG) System.out.println(position + "\t\tnew: java.lang.Long"); //$NON-NLS-1$
 			writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangLongConstantPoolName));
 			break;
-		case T_void : // new: java.lang.Void
+		case TypeIds.T_void : // new: java.lang.Void
 			if (DEBUG) System.out.println(position + "\t\tnew: java.lang.Void"); //$NON-NLS-1$
 			writeUnsignedShort(constantPool.literalIndexForType(ConstantPool.JavaLangVoidConstantPoolName));
 	}
 }
-final public void nop() {
+public void nop() {
 	if (DEBUG) System.out.println(position + "\t\tnop"); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_nop;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_nop;
 }
-final public void pop() {
+public void optimizeBranch(int oldPosition, Label lbl) {
+	for (int i = 0; i < this.countLabels; i++) {
+		Label label = this.labels[i];
+		if (oldPosition == label.position) {
+			label.position = position;
+			if (label instanceof CaseLabel) {
+				int offset = position - ((CaseLabel) label).instructionPosition;
+				for (int j = 0; j < label.forwardReferenceCount; j++) {
+					int forwardPosition = label.forwardReferences[j];
+					this.writeWidePosition(forwardPosition, offset);
+				}
+			} else {
+				for (int j = 0; j < label.forwardReferenceCount; j++) {
+					final int forwardReference = label.forwardReferences[j];
+					this.writePosition(lbl, forwardReference);
+				}
+			}
+		}
+	}
+}
+public void pop() {
 	if (DEBUG) System.out.println(position + "\t\tpop"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -5437,9 +5755,9 @@ final public void pop() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_pop;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_pop;
 }
-final public void pop2() {
+public void pop2() {
 	if (DEBUG) System.out.println(position + "\t\tpop2"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 2;
@@ -5447,44 +5765,54 @@ final public void pop2() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_pop2;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_pop2;
+}
+public void pushOnStack(TypeBinding binding) {
+	if (++stackDepth > stackMax)
+		stackMax = stackDepth;
 }
-final public void putfield(FieldBinding fieldBinding) {
+public void putfield(FieldBinding fieldBinding) {
 	if (DEBUG) System.out.println(position + "\t\tputfield:"+fieldBinding); //$NON-NLS-1$
 	int returnTypeSize = 1;
-	if ((fieldBinding.type.id == T_double) || (fieldBinding.type.id == T_long)) {
+	if ((fieldBinding.type.id == TypeIds.T_double) || (fieldBinding.type.id == TypeIds.T_long)) {
 		returnTypeSize = 2;
 	}
 	generateFieldAccess(
-			OPC_putfield,
+			Opcodes.OPC_putfield,
 			returnTypeSize,
 			fieldBinding.declaringClass.constantPoolName(),
 			fieldBinding.name,
 			fieldBinding.type.signature());
 }
-final public void putstatic(FieldBinding fieldBinding) {
+public void putstatic(FieldBinding fieldBinding) {
 	if (DEBUG) System.out.println(position + "\t\tputstatic:"+fieldBinding); //$NON-NLS-1$
 	int returnTypeSize = 1;
-	if ((fieldBinding.type.id == T_double) || (fieldBinding.type.id == T_long)) {
+	if ((fieldBinding.type.id == TypeIds.T_double) || (fieldBinding.type.id == TypeIds.T_long)) {
 		returnTypeSize = 2;
 	}
 	generateFieldAccess(
-			OPC_putstatic,
+			Opcodes.OPC_putstatic,
 			returnTypeSize,
 			fieldBinding.declaringClass.constantPoolName(),
 			fieldBinding.name,
 			fieldBinding.type.signature());
 }
 public void record(LocalVariableBinding local) {
-	if (!generateLocalVariableTableAttributes)
+	if (!manageLocalVariables)
 		return;
 	if (allLocalsCounter == locals.length) {
 		// resize the collection
 		System.arraycopy(locals, 0, locals = new LocalVariableBinding[allLocalsCounter + LOCALS_INCREMENT], 0, allLocalsCounter);
 	}
 	locals[allLocalsCounter++] = local;
-	local.initializationPCs = new int[4];
-	local.initializationCount = 0;
+	if (this.generateLocalVariableTableAttributes) {
+		local.initializationPCs = new int[4];
+		local.initializationCount = 0;
+	}
+}
+
+public void recordExpressionType(TypeBinding typeBinding) {
+	// nothing to do
 }
 public void recordPositionsFrom(int startPC, int sourcePos) {
 
@@ -5605,7 +5933,7 @@ public void removeExceptionHandler(ExceptionLabel exceptionLabel) {
 		}
 	}
 }
-public final void removeNotDefinitelyAssignedVariables(Scope scope, int initStateIndex) {
+public void removeNotDefinitelyAssignedVariables(Scope scope, int initStateIndex) {
 	// given some flow info, make sure we did not loose some variables initialization
 	// if this happens, then we must update their pc entries to reflect it in debug attributes
 	if (!generateLocalVariableTableAttributes)
@@ -5621,12 +5949,8 @@ public final void removeNotDefinitelyAssignedVariables(Scope scope, int initStat
 	}*/
 	for (int i = 0; i < visibleLocalsCount; i++) {
 		LocalVariableBinding localBinding = visibleLocals[i];
-		if (localBinding != null) {
-			if (initStateIndex == -1 || !isDefinitelyAssigned(scope, initStateIndex, localBinding)) {
-				if (localBinding.initializationCount > 0) {
-					localBinding.recordInitializationEndPC(position);
-				}
-			}
+		if (localBinding != null && !isDefinitelyAssigned(scope, initStateIndex, localBinding) && localBinding.initializationCount > 0) {
+			localBinding.recordInitializationEndPC(position);
 		}
 	}
 }
@@ -5640,12 +5964,13 @@ public void reset(AbstractMethodDeclaration referenceMethod, ClassFile targetCla
 	this.preserveUnusedLocals = referenceMethod.scope.compilerOptions().preserveAllLocalVariables;
 	initializeMaxLocals(referenceMethod.binding);
 }
+
 /**
  * @param targetClassFile The given classfile to reset the code stream
  */
 public void resetForProblemClinit(ClassFile targetClassFile) {
 	init(targetClassFile);
-	maxLocals = 0;
+	initializeMaxLocals(null);
 }
 private final void resizeByteArray() {
 	int length = bCodeStream.length;
@@ -5664,19 +5989,19 @@ final public void ret(int index) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_wide;
-		bCodeStream[classFileOffset++] = OPC_ret;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_wide;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_ret;
 		writeUnsignedShort(index);
 	} else { // Don't Widen
 		if (classFileOffset + 1 >= bCodeStream.length) {
 			resizeByteArray();
 		}
 		position += 2;
-		bCodeStream[classFileOffset++] = OPC_ret;
+		bCodeStream[classFileOffset++] = Opcodes.OPC_ret;
 		bCodeStream[classFileOffset++] = (byte) index;
 	}
 }
-final public void return_() {
+public void return_() {
 	if (DEBUG) System.out.println(position + "\t\treturn"); //$NON-NLS-1$
 	countLabels = 0;
 	// the stackDepth should be equal to 0 
@@ -5684,9 +6009,9 @@ final public void return_() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_return;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_return;
 }
-final public void saload() {
+public void saload() {
 	if (DEBUG) System.out.println(position + "\t\tsaload"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -5694,9 +6019,9 @@ final public void saload() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_saload;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_saload;
 }
-final public void sastore() {
+public void sastore() {
 	if (DEBUG) System.out.println(position + "\t\tsastore"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth -= 3;
@@ -5704,7 +6029,7 @@ final public void sastore() {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_sastore;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_sastore;
 }
 /**
  * @param operatorConstant int
@@ -5712,122 +6037,123 @@ final public void sastore() {
  */
 public void sendOperator(int operatorConstant, int type_ID) {
 	switch (type_ID) {
-		case T_int :
-		case T_boolean :
-		case T_char :
-		case T_byte :
-		case T_short :
+		case TypeIds.T_int :
+		case TypeIds.T_boolean :
+		case TypeIds.T_char :
+		case TypeIds.T_byte :
+		case TypeIds.T_short :
 			switch (operatorConstant) {
-				case PLUS :
+				case OperatorIds.PLUS :
 					this.iadd();
 					break;
-				case MINUS :
+				case OperatorIds.MINUS :
 					this.isub();
 					break;
-				case MULTIPLY :
+				case OperatorIds.MULTIPLY :
 					this.imul();
 					break;
-				case DIVIDE :
+				case OperatorIds.DIVIDE :
 					this.idiv();
 					break;
-				case REMAINDER :
+				case OperatorIds.REMAINDER :
 					this.irem();
 					break;
-				case LEFT_SHIFT :
+				case OperatorIds.LEFT_SHIFT :
 					this.ishl();
 					break;
-				case RIGHT_SHIFT :
+				case OperatorIds.RIGHT_SHIFT :
 					this.ishr();
 					break;
-				case UNSIGNED_RIGHT_SHIFT :
+				case OperatorIds.UNSIGNED_RIGHT_SHIFT :
 					this.iushr();
 					break;
-				case AND :
+				case OperatorIds.AND :
 					this.iand();
 					break;
-				case OR :
+				case OperatorIds.OR :
 					this.ior();
 					break;
-				case XOR :
+				case OperatorIds.XOR :
 					this.ixor();
 					break;
 			}
 			break;
-		case T_long :
+		case TypeIds.T_long :
 			switch (operatorConstant) {
-				case PLUS :
+				case OperatorIds.PLUS :
 					this.ladd();
 					break;
-				case MINUS :
+				case OperatorIds.MINUS :
 					this.lsub();
 					break;
-				case MULTIPLY :
+				case OperatorIds.MULTIPLY :
 					this.lmul();
 					break;
-				case DIVIDE :
+				case OperatorIds.DIVIDE :
 					this.ldiv();
 					break;
-				case REMAINDER :
+				case OperatorIds.REMAINDER :
 					this.lrem();
 					break;
-				case LEFT_SHIFT :
+				case OperatorIds.LEFT_SHIFT :
 					this.lshl();
 					break;
-				case RIGHT_SHIFT :
+				case OperatorIds.RIGHT_SHIFT :
 					this.lshr();
 					break;
-				case UNSIGNED_RIGHT_SHIFT :
+				case OperatorIds.UNSIGNED_RIGHT_SHIFT :
 					this.lushr();
 					break;
-				case AND :
+				case OperatorIds.AND :
 					this.land();
 					break;
-				case OR :
+				case OperatorIds.OR :
 					this.lor();
 					break;
-				case XOR :
+				case OperatorIds.XOR :
 					this.lxor();
 					break;
 			}
 			break;
-		case T_float :
+		case TypeIds.T_float :
 			switch (operatorConstant) {
-				case PLUS :
+				case OperatorIds.PLUS :
 					this.fadd();
 					break;
-				case MINUS :
+				case OperatorIds.MINUS :
 					this.fsub();
 					break;
-				case MULTIPLY :
+				case OperatorIds.MULTIPLY :
 					this.fmul();
 					break;
-				case DIVIDE :
+				case OperatorIds.DIVIDE :
 					this.fdiv();
 					break;
-				case REMAINDER :
+				case OperatorIds.REMAINDER :
 					this.frem();
 			}
 			break;
-		case T_double :
+		case TypeIds.T_double :
 			switch (operatorConstant) {
-				case PLUS :
+				case OperatorIds.PLUS :
 					this.dadd();
 					break;
-				case MINUS :
+				case OperatorIds.MINUS :
 					this.dsub();
 					break;
-				case MULTIPLY :
+				case OperatorIds.MULTIPLY :
 					this.dmul();
 					break;
-				case DIVIDE :
+				case OperatorIds.DIVIDE :
 					this.ddiv();
 					break;
-				case REMAINDER :
+				case OperatorIds.REMAINDER :
 					this.drem();
 			}
 	}
 }
-final public void sipush(int s) {
+
+public void sipush(int s) {
 	if (DEBUG) System.out.println(position + "\t\tsipush:"+s); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth++;
@@ -5837,51 +6163,10 @@ final public void sipush(int s) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_sipush;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_sipush;
 	writeSignedShort(s);
 }
-public static final void sort(int[] tab, int lo0, int hi0, int[] result) {
-	int lo = lo0;
-	int hi = hi0;
-	int mid;
-	if (hi0 > lo0) {
-		/* Arbitrarily establishing partition element as the midpoint of
-		  * the array.
-		  */
-		mid = tab[ (lo0 + hi0) / 2];
-		// loop through the array until indices cross
-		while (lo <= hi) {
-			/* find the first element that is greater than or equal to 
-			 * the partition element starting from the left Index.
-			 */
-			while ((lo < hi0) && (tab[lo] < mid))
-				++lo;
-			/* find an element that is smaller than or equal to 
-			 * the partition element starting from the right Index.
-			 */
-			while ((hi > lo0) && (tab[hi] > mid))
-				--hi;
-			// if the indexes have not crossed, swap
-			if (lo <= hi) {
-				swap(tab, lo, hi, result);
-				++lo;
-				--hi;
-			}
-		}
-		/* If the right index has not reached the left side of array
-		  * must now sort the left partition.
-		  */
-		if (lo0 < hi)
-			sort(tab, lo0, hi, result);
-		/* If the left index has not reached the right side of array
-		  * must now sort the right partition.
-		  */
-		if (lo < hi0)
-			sort(tab, lo, hi0, result);
-	}
-}
-
-public final void store(LocalVariableBinding localBinding, boolean valueRequired) {
+public void store(LocalVariableBinding localBinding, boolean valueRequired) {
 	int localPosition = localBinding.resolvedPosition;
 	// Using dedicated int bytecode
 	switch(localBinding.type.id) {
@@ -5994,160 +6279,16 @@ public final void store(LocalVariableBinding localBinding, boolean valueRequired
 			}
 	}
 }
-public final void store(TypeBinding type, int localPosition) {
-	// Using dedicated int bytecode
-	if ((type == TypeBinding.INT) || (type == TypeBinding.CHAR) || (type == TypeBinding.BYTE) || (type == TypeBinding.SHORT) || (type == TypeBinding.BOOLEAN)) {
-		switch (localPosition) {
-			case 0 :
-				this.istore_0();
-				break;
-			case 1 :
-				this.istore_1();
-				break;
-			case 2 :
-				this.istore_2();
-				break;
-			case 3 :
-				this.istore_3();
-				break;
-			default :
-				this.istore(localPosition);
-		}
-		return;
-	}
-	// Using dedicated float bytecode
-	if (type == TypeBinding.FLOAT) {
-		switch (localPosition) {
-			case 0 :
-				this.fstore_0();
-				break;
-			case 1 :
-				this.fstore_1();
-				break;
-			case 2 :
-				this.fstore_2();
-				break;
-			case 3 :
-				this.fstore_3();
-				break;
-			default :
-				this.fstore(localPosition);
-		}
-		return;
-	}
-	// Using dedicated long bytecode
-	if (type == TypeBinding.LONG) {
-		switch (localPosition) {
-			case 0 :
-				this.lstore_0();
-				break;
-			case 1 :
-				this.lstore_1();
-				break;
-			case 2 :
-				this.lstore_2();
-				break;
-			case 3 :
-				this.lstore_3();
-				break;
-			default :
-				this.lstore(localPosition);
-		}
-		return;
-	}
-	// Using dedicated double bytecode
-	if (type == TypeBinding.DOUBLE) {
-		switch (localPosition) {
-			case 0 :
-				this.dstore_0();
-				break;
-			case 1 :
-				this.dstore_1();
-				break;
-			case 2 :
-				this.dstore_2();
-				break;
-			case 3 :
-				this.dstore_3();
-				break;
-			default :
-				this.dstore(localPosition);
-		}
-		return;
-	}
-	// Reference object
-	switch (localPosition) {
-		case 0 :
-			this.astore_0();
-			break;
-		case 1 :
-			this.astore_1();
-			break;
-		case 2 :
-			this.astore_2();
-			break;
-		case 3 :
-			this.astore_3();
-			break;
-		default :
-			this.astore(localPosition);
-	}
-}
-public final void storeInt(int localPosition) {
-	switch (localPosition) {
-		case 0 :
-			this.istore_0();
-			break;
-		case 1 :
-			this.istore_1();
-			break;
-		case 2 :
-			this.istore_2();
-			break;
-		case 3 :
-			this.istore_3();
-			break;
-		default :
-			this.istore(localPosition);
-	}
-}
-public final void storeObject(int localPosition) {
-	switch (localPosition) {
-		case 0 :
-			this.astore_0();
-			break;
-		case 1 :
-			this.astore_1();
-			break;
-		case 2 :
-			this.astore_2();
-			break;
-		case 3 :
-			this.astore_3();
-			break;
-		default :
-			this.astore(localPosition);
-	}
-}
-final public void swap() {
+public void swap() {
 	if (DEBUG) System.out.println(position + "\t\tswap"); //$NON-NLS-1$
 	countLabels = 0;
 	if (classFileOffset >= bCodeStream.length) {
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_swap;
-}
-private static final void swap(int a[], int i, int j, int result[]) {
-	int T;
-	T = a[i];
-	a[i] = a[j];
-	a[j] = T;
-	T = result[j];
-	result[j] = result[i];
-	result[i] = T;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_swap;
 }
-final public void tableswitch(CaseLabel defaultLabel, int low, int high, int[] keys, int[] sortedIndexes, CaseLabel[] casesLabel) {
+public void tableswitch(CaseLabel defaultLabel, int low, int high, int[] keys, int[] sortedIndexes, CaseLabel[] casesLabel) {
 	if (DEBUG) System.out.println(position + "\t\ttableswitch"); //$NON-NLS-1$
 	countLabels = 0;
 	stackDepth--;
@@ -6160,7 +6301,7 @@ final public void tableswitch(CaseLabel defaultLabel, int low, int high, int[] k
 		resizeByteArray();
 	}
 	position++;
-	bCodeStream[classFileOffset++] = OPC_tableswitch;
+	bCodeStream[classFileOffset++] = Opcodes.OPC_tableswitch;
 	for (int i = (3 - (pos % 4)); i > 0; i--) {
 		if (classFileOffset >= bCodeStream.length) {
 			resizeByteArray();
@@ -6187,6 +6328,10 @@ final public void tableswitch(CaseLabel defaultLabel, int low, int high, int[] k
 		i++;
 	}
 }
+public void throwAnyException(LocalVariableBinding anyExceptionVariable) {
+	this.load(anyExceptionVariable);
+	this.athrow();
+}
 public String toString() {
 	StringBuffer buffer = new StringBuffer("( position:"); //$NON-NLS-1$
 	buffer.append(position);
@@ -6220,9 +6365,9 @@ public void updateLastRecordedEndPC(Scope scope, int pos) {
 		updateLocalVariablesAttribute(pos);	
 	*/	
 
-	if (!generateLineNumberAttributes)
-		return;
-	this.lastEntryPC = pos;
+	if (this.generateLineNumberAttributes) {
+		this.lastEntryPC = pos;
+	}
 	// need to update the initialization endPC in case of generation of local variable attributes.
 	if (this.generateLocalVariableTableAttributes) {
 		for (int i = 0, max = this.locals.length; i < max; i++) {
@@ -6235,12 +6380,36 @@ public void updateLastRecordedEndPC(Scope scope, int pos) {
 		}
 	}
 }
-
+protected void writePosition(Label label) {
+	int offset = label.position - this.position + 1;
+	if (Math.abs(offset) > 0x7FFF && !this.wideMode) {
+		throw new AbortMethod(CodeStream.RESTART_IN_WIDE_MODE, null);
+	}
+	this.writeSignedShort(offset);
+	for (int i = 0, max = label.forwardReferenceCount; i < max; i++) {
+		this.writePosition(label, label.forwardReferences[i]);
+	}	
+}
+protected void writePosition(Label label, int forwardReference) {
+	final int offset = label.position - forwardReference + 1;
+	if (Math.abs(offset) > 0x7FFF && !this.wideMode) {
+		throw new AbortMethod(CodeStream.RESTART_IN_WIDE_MODE, null);
+	}
+	if (this.wideMode) {
+		if ((label.tagBits & Label.WIDE) != 0) {
+			this.writeSignedWord(forwardReference, offset);
+		} else {
+			this.writeSignedShort(forwardReference, offset);
+		}
+	} else {
+		this.writeSignedShort(forwardReference, offset);
+	}
+}
 /**
  * Write a signed 16 bits value into the byte array
  * @param value the signed short
  */
-public final void writeSignedShort(int value) {
+private final void writeSignedShort(int value) {
 	// we keep the resize in here because it is used outside the code stream
 	if (classFileOffset + 1 >= bCodeStream.length) {
 		resizeByteArray();
@@ -6249,7 +6418,7 @@ public final void writeSignedShort(int value) {
 	bCodeStream[classFileOffset++] = (byte) (value >> 8);
 	bCodeStream[classFileOffset++] = (byte) value;
 }
-public final void writeSignedShort(int pos, int value) {
+private final void writeSignedShort(int pos, int value) {
 	int currentOffset = startingClassFileOffset + pos;
 	if (currentOffset + 1 >= bCodeStream.length) {
 		resizeByteArray();
@@ -6257,7 +6426,7 @@ public final void writeSignedShort(int pos, int value) {
 	bCodeStream[currentOffset] = (byte) (value >> 8);
 	bCodeStream[currentOffset + 1] = (byte) value;
 }
-public final void writeSignedWord(int value) {
+private final void writeSignedWord(int value) {
 	// we keep the resize in here because it is used outside the code stream
 	if (classFileOffset + 3 >= bCodeStream.length) {
 		resizeByteArray();
@@ -6268,7 +6437,7 @@ public final void writeSignedWord(int value) {
 	bCodeStream[classFileOffset++] = (byte) ((value & 0xFF00) >> 8);
 	bCodeStream[classFileOffset++] = (byte) (value & 0xFF);
 }
-public final void writeSignedWord(int pos, int value) {
+private final void writeSignedWord(int pos, int value) {
 	int currentOffset = startingClassFileOffset + pos;
 	if (currentOffset + 4 >= bCodeStream.length) {
 		resizeByteArray();
@@ -6287,23 +6456,10 @@ protected final void writeUnsignedShort(int value) {
 	bCodeStream[classFileOffset++] = (byte) (value >>> 8);
 	bCodeStream[classFileOffset++] = (byte) value;
 }
-/*
- * Wide conditional branch compare, improved by swapping comparison opcode
- *   ifeq WideTarget
- * becomes
- *    ifne Intermediate
- *    gotow WideTarget
- *    Intermediate:
- */
-public void generateWideRevertedConditionalBranch(byte revertedOpcode, Label wideTarget) {
-		Label intermediate = new Label(this);
-		if (classFileOffset >= bCodeStream.length) {
-			resizeByteArray();
-		}
-		position++;
-		bCodeStream[classFileOffset++] = revertedOpcode;
-		intermediate.branch();
-		this.goto_w(wideTarget);
-		intermediate.place();
+protected void writeWidePosition(int offset) {
+	this.writeSignedWord(offset);
+}
+protected void writeWidePosition(int forwardReference, int offset) {
+	this.writeSignedWord(forwardReference, offset);
 }
 }
