diff --git a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
index 9714694..6a6ae74 100644
--- a/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
+++ b/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java
@@ -38,6 +38,7 @@ import org.eclipse.jdt.internal.compiler.env.*;
 import org.eclipse.jdt.internal.compiler.lookup.*;
 import org.eclipse.jdt.internal.compiler.parser.Scanner;
 import org.eclipse.jdt.internal.compiler.parser.SourceTypeConverter;
+import org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants;
 import org.eclipse.jdt.internal.compiler.parser.TerminalTokens;
 import org.eclipse.jdt.internal.compiler.problem.AbortCompilation;
 import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;
@@ -91,7 +92,7 @@ public final class CompletionEngine
 	private final static int FIELD = 0;
 	private final static int LOCAL = 1;
 	private final static int ARGUMENT = 2;
-	
+
 	int expectedTypesPtr = -1;
 	TypeBinding[] expectedTypes = new TypeBinding[1];
 	int expectedTypesFilter;
@@ -106,6 +107,7 @@ public final class CompletionEngine
 	boolean assistNodeIsInterface;
 	boolean assistNodeIsAnnotation;
 	boolean assistNodeIsConstructor;
+	int  assistNodeInJavadoc = 0;
 	
 	IJavaProject javaProject;
 	CompletionParser parser;
@@ -121,6 +123,7 @@ public final class CompletionEngine
 	IProblem problem = null;
 	char[] fileName = null;
 	int startPosition, actualCompletionPosition, endPosition, offset;
+	int javadocTagPosition; // Position of previous tag while completing in javadoc
 	HashtableOfObject knownPkgs = new HashtableOfObject(10);
 	HashtableOfObject knownTypes = new HashtableOfObject(10);
 	Scanner nameScanner;
@@ -150,17 +153,24 @@ public final class CompletionEngine
 				"transient".toCharArray(),
 				"volatile".toCharArray()};
 	*/
-	static final char[][] baseTypes = new char[][] { 
-		"boolean".toCharArray(), //$NON-NLS-1$
-		"byte".toCharArray(), //$NON-NLS-1$
-		"char".toCharArray(), //$NON-NLS-1$
-		"double".toCharArray(), //$NON-NLS-1$
-		"float".toCharArray(), //$NON-NLS-1$
-		"int".toCharArray(), //$NON-NLS-1$
-		"long".toCharArray(), //$NON-NLS-1$
-		"short".toCharArray(), //$NON-NLS-1$
-		"void".toCharArray(), //$NON-NLS-1$
+	static final BaseTypeBinding[] BASE_TYPES = {
+		BaseTypes.BooleanBinding,
+		BaseTypes.ByteBinding,
+		BaseTypes.CharBinding,
+		BaseTypes.DoubleBinding,
+		BaseTypes.FloatBinding,
+		BaseTypes.IntBinding,
+		BaseTypes.LongBinding,
+		BaseTypes.ShortBinding,
+		BaseTypes.VoidBinding
 	};
+	static final int BASE_TYPES_LENGTH = BASE_TYPES.length;
+	static final char[][] BASE_TYPE_NAMES = new char[BASE_TYPES_LENGTH][];
+	static { 
+		for (int i=0; i<BASE_TYPES_LENGTH; i++) {
+			BASE_TYPE_NAMES[i] = BASE_TYPES[i].simpleName;
+		}
+	}
 		
 	static final char[] classField = "class".toCharArray();  //$NON-NLS-1$
 	static final char[] lengthField = "length".toCharArray();  //$NON-NLS-1$
@@ -405,20 +415,7 @@ public final class CompletionEngine
 				
 				this.noProposal = false;
 				if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
-					CompletionProposal proposal = this.createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
-					proposal.setDeclarationSignature(packageName);
-					proposal.setSignature(createNonGenericTypeSignature(packageName, typeName));
-					proposal.setPackageName(packageName);
-					proposal.setTypeName(typeName);
-					proposal.setCompletion(completionName);
-					proposal.setFlags(modifiers);
-					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-					proposal.setRelevance(relevance);
-					proposal.setAccessibility(accessibility);
-					this.requestor.accept(proposal);
-					if(DEBUG) {
-						this.printDebug(proposal);
-					}
+					createTypeProposal(packageName, typeName, modifiers, accessibility, completionName, relevance);
 				}
 			} else {
 				if(!this.importCachesInitialized) {
@@ -577,7 +574,7 @@ public final class CompletionEngine
 		} else {
 			completionName = simpleTypeName;
 		}
-		
+
 		int relevance = computeBaseRelevance();
 		relevance += computeRelevanceForInterestingProposal();
 		relevance += computeRelevanceForRestrictions(accessibility);
@@ -606,20 +603,7 @@ public final class CompletionEngine
 		
 		this.noProposal = false;
 		if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
-			CompletionProposal proposal = this.createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
-			proposal.setDeclarationSignature(packageName);
-			proposal.setSignature(createNonGenericTypeSignature(packageName, typeName));
-			proposal.setPackageName(packageName);
-			proposal.setTypeName(typeName);
-			proposal.setCompletion(completionName);
-			proposal.setFlags(modifiers);
-			proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-			proposal.setRelevance(relevance);
-			proposal.setAccessibility(accessibility);
-			this.requestor.accept(proposal);
-			if(DEBUG) {
-				this.printDebug(proposal);
-			}
+			createTypeProposal(packageName, typeName, modifiers, accessibility, completionName, relevance);
 		}
 	}
 
@@ -662,7 +646,7 @@ public final class CompletionEngine
 		}
 	}
 		
-	private void buildContext() {
+	private void buildContext(int astNodeBits) {
 		CompletionContext context = new CompletionContext();
 		
 		// build expected types context
@@ -678,22 +662,24 @@ public final class CompletionEngine
 			context.setExpectedTypesKeys(expKeys);
 		}
 		
+		// Set javadoc info
+		context.setInJavadoc((astNodeBits & ASTNode.InsideJavadoc) != 0);
 		this.requestor.acceptContext(context);
 	}
 	
 	private boolean complete(ASTNode astNode, ASTNode astNodeParent, Binding qualifiedBinding, Scope scope, boolean insideTypeAnnotation) {
 
 		setSourceRange(astNode.sourceStart, astNode.sourceEnd);
-		
+
 		scope = computeForbiddenBindings(astNode, astNodeParent, scope);
 		computeUninterestingBindings(astNodeParent, scope);
 		if(astNodeParent != null) {
 			if(!isValidParent(astNodeParent, astNode, scope)) return false;
 			computeExpectedTypes(astNodeParent, astNode, scope);
 		}
-		
-		buildContext();
-		
+
+		buildContext(astNode.bits);
+
 		if (astNode instanceof CompletionOnFieldType) {
 
 			CompletionOnFieldType field = (CompletionOnFieldType) astNode;
@@ -702,556 +688,676 @@ public final class CompletionEngine
 			setSourceRange(type.sourceStart, type.sourceEnd);
 			
 			findTypesAndPackages(this.completionToken, scope);
-			if(!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
+			if (!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
 				findKeywordsForMember(this.completionToken, field.modifiers);
 			}
 			
-			if(!field.isLocalVariable && field.modifiers == CompilerModifiers.AccDefault) {
+			if (!field.isLocalVariable && field.modifiers == CompilerModifiers.AccDefault) {
 				SourceTypeBinding enclosingType = scope.enclosingSourceType();
-				if(!enclosingType.isAnnotationType()) {
-					if(!this.requestor.isIgnored(CompletionProposal.METHOD_DECLARATION)) {
+				if (!enclosingType.isAnnotationType()) {
+					if (!this.requestor.isIgnored(CompletionProposal.METHOD_DECLARATION)) {
 						findMethods(this.completionToken,null,enclosingType,scope,new ObjectVector(),false,false,true,null,null,false,false,true);
 					}
-					if(!this.requestor.isIgnored(CompletionProposal.POTENTIAL_METHOD_DECLARATION)) {
+					if (!this.requestor.isIgnored(CompletionProposal.POTENTIAL_METHOD_DECLARATION)) {
 						proposeNewMethod(this.completionToken, enclosingType);
 					}
 				}
 			}
-		} else {
-			if(astNode instanceof CompletionOnMethodReturnType) {
-				
-				CompletionOnMethodReturnType method = (CompletionOnMethodReturnType) astNode;
-				SingleTypeReference type = (CompletionOnSingleTypeReference) method.returnType;
-				this.completionToken = type.token;
-				setSourceRange(type.sourceStart, type.sourceEnd);
-				findTypesAndPackages(this.completionToken, scope.parent);
-				if(!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
-					findKeywordsForMember(this.completionToken, method.modifiers);
-				}
-			
-				if(method.modifiers == CompilerModifiers.AccDefault) {
-					SourceTypeBinding enclosingType = scope.enclosingSourceType();
-					if(!enclosingType.isAnnotationType()) {
-						if(!this.requestor.isIgnored(CompletionProposal.METHOD_DECLARATION)) {
-							findMethods(this.completionToken,null,scope.enclosingSourceType(),scope,new ObjectVector(),false,false,true,null,null,false,false,true);
-						}
-						if(!this.requestor.isIgnored(CompletionProposal.POTENTIAL_METHOD_DECLARATION)) {
-							proposeNewMethod(this.completionToken, scope.enclosingSourceType());
-						}
+		} else if (astNode instanceof CompletionOnMethodReturnType) {
+
+			CompletionOnMethodReturnType method = (CompletionOnMethodReturnType) astNode;
+			SingleTypeReference type = (CompletionOnSingleTypeReference) method.returnType;
+			this.completionToken = type.token;
+			setSourceRange(type.sourceStart, type.sourceEnd);
+			findTypesAndPackages(this.completionToken, scope.parent);
+			if (!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
+				findKeywordsForMember(this.completionToken, method.modifiers);
+			}
+
+			if (method.modifiers == CompilerModifiers.AccDefault) {
+				SourceTypeBinding enclosingType = scope.enclosingSourceType();
+				if (!enclosingType.isAnnotationType()) {
+					if (!this.requestor.isIgnored(CompletionProposal.METHOD_DECLARATION)) {
+						findMethods(this.completionToken,null,scope.enclosingSourceType(),scope,new ObjectVector(),false,false,true,null,null,false,false,true);
 					}
+					if (!this.requestor.isIgnored(CompletionProposal.POTENTIAL_METHOD_DECLARATION)) {
+						proposeNewMethod(this.completionToken, scope.enclosingSourceType());
+					}
+				}
+			}
+		} else if (astNode instanceof CompletionOnSingleNameReference) {
+
+			CompletionOnSingleNameReference singleNameReference = (CompletionOnSingleNameReference) astNode;
+			this.completionToken = singleNameReference.token;
+			SwitchStatement switchStatement = astNodeParent instanceof SwitchStatement ? (SwitchStatement) astNodeParent : null;
+			if (switchStatement != null
+					&& switchStatement.expression.resolvedType != null
+					&& switchStatement.expression.resolvedType.isEnum()) {
+				if (!this.requestor.isIgnored(CompletionProposal.FIELD_REF)) {
+					this.assistNodeIsEnum = true;
+					this.findEnumConstant(this.completionToken, (SwitchStatement) astNodeParent);
 				}
+			} else if (this.expectedTypesPtr > -1 && this.expectedTypes[0].isAnnotationType()) {
+				findTypesAndPackages(this.completionToken, scope);
 			} else {
+				findVariablesAndMethods(
+					this.completionToken,
+					scope,
+					singleNameReference,
+					scope,
+					insideTypeAnnotation,
+					singleNameReference.isInsideAnnotationAttribute);
+				// can be the start of a qualified type name
+				findTypesAndPackages(this.completionToken, scope);
+				if (!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
+					if (this.completionToken != null && this.completionToken.length != 0) {
+						findKeywords(this.completionToken, singleNameReference.possibleKeywords, false);
+					} else {
+						findTrueOrFalseKeywords(singleNameReference.possibleKeywords);
+					}
+				}
+				if (singleNameReference.canBeExplicitConstructor && !this.requestor.isIgnored(CompletionProposal.METHOD_REF)){
+					if (CharOperation.prefixEquals(this.completionToken, Keywords.THIS, false)) {
+						ReferenceBinding ref = scope.enclosingSourceType();
+						findExplicitConstructors(Keywords.THIS, ref, (MethodScope)scope, singleNameReference);
+					} else if (CharOperation.prefixEquals(this.completionToken, Keywords.SUPER, false)) {
+						ReferenceBinding ref = scope.enclosingSourceType();
+						findExplicitConstructors(Keywords.SUPER, ref.superclass(), (MethodScope)scope, singleNameReference);
+					}
+				}
+			}
+
+		} else if (astNode instanceof CompletionOnSingleTypeReference) {
+
+			this.completionToken = ((CompletionOnSingleTypeReference) astNode).token;
+
+			this.assistNodeIsClass = astNode instanceof CompletionOnClassReference;
+			this.assistNodeIsException = astNode instanceof CompletionOnExceptionReference;
+			this.assistNodeIsInterface = astNode instanceof CompletionOnInterfaceReference;
+			this.assistNodeIsConstructor = ((CompletionOnSingleTypeReference) astNode).isConstructorType;
+
+			// can be the start of a qualified type name
+			if (qualifiedBinding == null) {
+				if (this.completionToken.length == 0 &&
+						(astNodeParent instanceof ParameterizedSingleTypeReference ||
+								astNodeParent instanceof ParameterizedQualifiedTypeReference)) {
+					this.setSourceRange(astNode.sourceStart, astNode.sourceStart - 1, false);
+					
+					findParameterizedType((TypeReference)astNodeParent);
+				} else { 
+					findTypesAndPackages(this.completionToken, scope);
+				}
+			} else if (!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
+				findMemberTypes(
+					this.completionToken,
+					(ReferenceBinding) qualifiedBinding,
+					scope,
+					scope.enclosingSourceType(),
+					false,
+					false,
+					false,
+					!this.assistNodeIsConstructor,
+					null,
+					new ObjectVector());
+			}
+		} else if (astNode instanceof CompletionOnQualifiedNameReference) {
+
+			this.insideQualifiedReference = true;
+			CompletionOnQualifiedNameReference ref =
+				(CompletionOnQualifiedNameReference) astNode;
+			this.completionToken = ref.completionIdentifier;
+			long completionPosition = ref.sourcePositions[ref.sourcePositions.length - 1];
+
+			if (qualifiedBinding instanceof VariableBinding) {
+
+				setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
+				TypeBinding receiverType = ((VariableBinding) qualifiedBinding).type;
+				if (receiverType != null) {
+					findFieldsAndMethods(this.completionToken, receiverType.capture(scope, ref.sourceEnd), scope, ref, scope,false,false);
+				}
+
+			} else if (qualifiedBinding instanceof ReferenceBinding && !(qualifiedBinding instanceof TypeVariableBinding)) {
+				boolean isInsideAnnotationAttribute = ref.isInsideAnnotationAttribute;
+				ReferenceBinding receiverType = (ReferenceBinding) qualifiedBinding;
+				setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
+
+				if (!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
+					findMemberTypes(
+							this.completionToken,
+							receiverType,
+							scope,
+							scope.enclosingSourceType(),
+							false,
+							new ObjectVector());
+				}
+				if (!this.requestor.isIgnored(CompletionProposal.FIELD_REF)) {
+					findClassField(this.completionToken, (TypeBinding) qualifiedBinding, scope);
+				}
 				
-				if (astNode instanceof CompletionOnSingleNameReference) {
-					CompletionOnSingleNameReference singleNameReference = (CompletionOnSingleNameReference) astNode;
-					this.completionToken = singleNameReference.token;
-					SwitchStatement switchStatement = astNodeParent instanceof SwitchStatement ? (SwitchStatement) astNodeParent : null;
-					if(switchStatement != null
-							&& switchStatement.expression.resolvedType != null
-							&& switchStatement.expression.resolvedType.isEnum()) {
-						if(!this.requestor.isIgnored(CompletionProposal.FIELD_REF)) {
-							this.assistNodeIsEnum = true;
-							this.findEnumConstant(this.completionToken, (SwitchStatement) astNodeParent);
-						}
+				MethodScope methodScope = null;
+				if (!isInsideAnnotationAttribute &&
+						!this.requestor.isIgnored(CompletionProposal.KEYWORD) &&
+						((scope instanceof MethodScope && !((MethodScope)scope).isStatic)
+						|| ((methodScope = scope.enclosingMethodScope()) != null && !methodScope.isStatic))) {
+					if (this.completionToken.length > 0) {
+						findKeywords(this.completionToken, new char[][]{Keywords.THIS}, false);
 					} else {
-						if(this.expectedTypesPtr > -1 && this.expectedTypes[0].isAnnotationType()) {
-							findTypesAndPackages(this.completionToken, scope);
-						} else {
-							findVariablesAndMethods(
-								this.completionToken,
-								scope,
-								singleNameReference,
-								scope,
-								insideTypeAnnotation,
-								singleNameReference.isInsideAnnotationAttribute);
-							// can be the start of a qualified type name
-							findTypesAndPackages(this.completionToken, scope);
-							if(!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
-								if(this.completionToken != null && this.completionToken.length != 0) {
-									findKeywords(this.completionToken, singleNameReference.possibleKeywords, false);
-								} else {
-									findTrueOrFalseKeywords(singleNameReference.possibleKeywords);
-								}
-							}
-							if(singleNameReference.canBeExplicitConstructor && !this.requestor.isIgnored(CompletionProposal.METHOD_REF)){
-								if(CharOperation.prefixEquals(this.completionToken, Keywords.THIS, false)) {
-									ReferenceBinding ref = scope.enclosingSourceType();
-									findExplicitConstructors(Keywords.THIS, ref, (MethodScope)scope, singleNameReference);
-								} else if(CharOperation.prefixEquals(this.completionToken, Keywords.SUPER, false)) {
-									ReferenceBinding ref = scope.enclosingSourceType();
-									findExplicitConstructors(Keywords.SUPER, ref.superclass(), (MethodScope)scope, singleNameReference);
-								}
+						int relevance = computeBaseRelevance();
+						relevance += computeRelevanceForInterestingProposal();
+						relevance += computeRelevanceForCaseMatching(this.completionToken, Keywords.THIS);
+						relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE); // no access restriction for keywords
+						this.noProposal = false;
+						if (!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
+							CompletionProposal proposal = this.createProposal(CompletionProposal.KEYWORD, this.actualCompletionPosition);
+							proposal.setName(Keywords.THIS);
+							proposal.setCompletion(Keywords.THIS);
+							proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+							proposal.setRelevance(relevance);
+							this.requestor.accept(proposal);
+							if (DEBUG) {
+								this.printDebug(proposal);
 							}
 						}
 					}
-				} else {
-	
-					if (astNode instanceof CompletionOnSingleTypeReference) {
-	
-						this.completionToken = ((CompletionOnSingleTypeReference) astNode).token;
-						
-						this.assistNodeIsClass = astNode instanceof CompletionOnClassReference;
-						this.assistNodeIsException = astNode instanceof CompletionOnExceptionReference;
-						this.assistNodeIsInterface = astNode instanceof CompletionOnInterfaceReference;
-						this.assistNodeIsConstructor = ((CompletionOnSingleTypeReference) astNode).isConstructorType;
-						
-						// can be the start of a qualified type name
-						if (qualifiedBinding == null) {
-							if(this.completionToken.length == 0 &&
-									(astNodeParent instanceof ParameterizedSingleTypeReference ||
-											astNodeParent instanceof ParameterizedQualifiedTypeReference)) {
-								this.setSourceRange(astNode.sourceStart, astNode.sourceStart - 1, false);
-								
-								findParameterizedType((TypeReference)astNodeParent);
-							} else { 
-								findTypesAndPackages(this.completionToken, scope);
-							}
-						} else {
-							if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
-								findMemberTypes(
-								this.completionToken,
-								(ReferenceBinding) qualifiedBinding,
-								scope,
-								scope.enclosingSourceType(),
-								false,
-								false,
-								false,
-								!this.assistNodeIsConstructor,
-								null,
-								new ObjectVector());
-							}
-						}
-					} else {
-						
-						if (astNode instanceof CompletionOnQualifiedNameReference) {
-	
-							this.insideQualifiedReference = true;
-							CompletionOnQualifiedNameReference ref =
-								(CompletionOnQualifiedNameReference) astNode;
-							this.completionToken = ref.completionIdentifier;
-							long completionPosition = ref.sourcePositions[ref.sourcePositions.length - 1];
-	
-							if (qualifiedBinding instanceof VariableBinding) {
-	
-								setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
-								TypeBinding receiverType = ((VariableBinding) qualifiedBinding).type;
-								if (receiverType != null) {
-									findFieldsAndMethods(this.completionToken, receiverType.capture(scope, ref.sourceEnd), scope, ref, scope,false,false);
-								}
-	
-							} else {
-	
-								if (qualifiedBinding instanceof ReferenceBinding &&
-										!(qualifiedBinding instanceof TypeVariableBinding)) {
-									boolean isInsideAnnotationAttribute = ref.isInsideAnnotationAttribute;
-									ReferenceBinding receiverType = (ReferenceBinding) qualifiedBinding;
-									setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
-	
-									if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
-										findMemberTypes(
-												this.completionToken,
-												receiverType,
-												scope,
-												scope.enclosingSourceType(),
-												false,
-												new ObjectVector());
-									}
-									if(!this.requestor.isIgnored(CompletionProposal.FIELD_REF)) {
-										findClassField(this.completionToken, (TypeBinding) qualifiedBinding, scope);
-									}
-									
-									MethodScope methodScope = null;
-									if(!isInsideAnnotationAttribute &&
-											!this.requestor.isIgnored(CompletionProposal.KEYWORD) &&
-											((scope instanceof MethodScope && !((MethodScope)scope).isStatic)
-											|| ((methodScope = scope.enclosingMethodScope()) != null && !methodScope.isStatic))) {
-										if(this.completionToken.length > 0) {
-											findKeywords(this.completionToken, new char[][]{Keywords.THIS}, false);
-										} else {
-											int relevance = computeBaseRelevance();
-											relevance += computeRelevanceForInterestingProposal();
-											relevance += computeRelevanceForCaseMatching(this.completionToken, Keywords.THIS);
-											relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE); // no access restriction for keywords
-											this.noProposal = false;
-											if(!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
-												CompletionProposal proposal = this.createProposal(CompletionProposal.KEYWORD, this.actualCompletionPosition);
-												proposal.setName(Keywords.THIS);
-												proposal.setCompletion(Keywords.THIS);
-												proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-												proposal.setRelevance(relevance);
-												this.requestor.accept(proposal);
-												if(DEBUG) {
-													this.printDebug(proposal);
-												}
-											}
-										}
-									}
-	
-									if(!this.requestor.isIgnored(CompletionProposal.FIELD_REF)) {
-										findFields(
-											this.completionToken,
-											receiverType,
-											scope,
-											new ObjectVector(),
-											new ObjectVector(),
-											true,
-											ref,
-											scope,
-											false,
-											true);
-									}
-	
-									if(!isInsideAnnotationAttribute && !this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
-										findMethods(
-											this.completionToken,
-											null,
-											receiverType,
-											scope,
-											new ObjectVector(),
-											true,
-											false,
-											false,
-											ref,
-											scope,
-											false,
-											false,
-											true);
-									}
-	
-								} else {
-	
-									if (qualifiedBinding instanceof PackageBinding) {
-	
-										setSourceRange(astNode.sourceStart, (int) completionPosition);
-										// replace to the end of the completion identifier
-										findTypesAndSubpackages(this.completionToken, (PackageBinding) qualifiedBinding);
-									}
-								}
-							}
-	
-						} else {
-	
-								if (astNode instanceof CompletionOnQualifiedTypeReference) {
-	
-								this.insideQualifiedReference = true;
-								
-								this.assistNodeIsClass = astNode instanceof CompletionOnQualifiedClassReference;
-								this.assistNodeIsException = astNode instanceof CompletionOnQualifiedExceptionReference;
-								this.assistNodeIsInterface = astNode instanceof CompletionOnQualifiedInterfaceReference;
-								
-								CompletionOnQualifiedTypeReference ref =
-									(CompletionOnQualifiedTypeReference) astNode;
-								this.completionToken = ref.completionIdentifier;
-								long completionPosition = ref.sourcePositions[ref.tokens.length];
-	
-								// get the source positions of the completion identifier
-								if (qualifiedBinding instanceof ReferenceBinding &&
-										!(qualifiedBinding instanceof TypeVariableBinding)) {
-									if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
-										setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
-										findMemberTypes(
-											this.completionToken,
-											(ReferenceBinding) qualifiedBinding,
-											scope,
-											scope.enclosingSourceType(),
-											false,
-											new ObjectVector());
-									}
-	
-								} else {
-	
-									if (qualifiedBinding instanceof PackageBinding) {
-	
-										setSourceRange(astNode.sourceStart, (int) completionPosition);
-										// replace to the end of the completion identifier
-										findTypesAndSubpackages(this.completionToken, (PackageBinding) qualifiedBinding);
+				}
+
+				if (!this.requestor.isIgnored(CompletionProposal.FIELD_REF)) {
+					findFields(
+						this.completionToken,
+						receiverType,
+						scope,
+						new ObjectVector(),
+						new ObjectVector(),
+						true,
+						ref,
+						scope,
+						false,
+						true);
+				}
+
+				if (!isInsideAnnotationAttribute && !this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
+					findMethods(
+						this.completionToken,
+						null,
+						receiverType,
+						scope,
+						new ObjectVector(),
+						true,
+						false,
+						false,
+						ref,
+						scope,
+						false,
+						false,
+						true);
+				}
+
+			} else if (qualifiedBinding instanceof PackageBinding) {
+
+				setSourceRange(astNode.sourceStart, (int) completionPosition);
+				// replace to the end of the completion identifier
+				findTypesAndSubpackages(this.completionToken, (PackageBinding) qualifiedBinding);
+			}
+		} else if (astNode instanceof CompletionOnQualifiedTypeReference) {
+
+			this.insideQualifiedReference = true;
+			
+			this.assistNodeIsClass = astNode instanceof CompletionOnQualifiedClassReference;
+			this.assistNodeIsException = astNode instanceof CompletionOnQualifiedExceptionReference;
+			this.assistNodeIsInterface = astNode instanceof CompletionOnQualifiedInterfaceReference;
+			
+			CompletionOnQualifiedTypeReference ref =
+				(CompletionOnQualifiedTypeReference) astNode;
+			this.completionToken = ref.completionIdentifier;
+			long completionPosition = ref.sourcePositions[ref.tokens.length];
+
+			// get the source positions of the completion identifier
+			if (qualifiedBinding instanceof ReferenceBinding && !(qualifiedBinding instanceof TypeVariableBinding)) {
+				if (!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
+					setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
+					findMemberTypes(
+						this.completionToken,
+						(ReferenceBinding) qualifiedBinding,
+						scope,
+						scope.enclosingSourceType(),
+						false,
+						new ObjectVector());
+				}
+			} else if (qualifiedBinding instanceof PackageBinding) {
+
+				setSourceRange(astNode.sourceStart, (int) completionPosition);
+				// replace to the end of the completion identifier
+				findTypesAndSubpackages(this.completionToken, (PackageBinding) qualifiedBinding);
+			}
+		} else if (astNode instanceof CompletionOnMemberAccess) {
+			this.insideQualifiedReference = true;
+			CompletionOnMemberAccess access = (CompletionOnMemberAccess) astNode;
+			long completionPosition = access.nameSourcePosition;
+			setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
+
+			this.completionToken = access.token;
+			
+			if (!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
+				findKeywords(this.completionToken, new char[][]{Keywords.NEW}, false);
+			}
+			
+			findFieldsAndMethods(
+				this.completionToken,
+				((TypeBinding) qualifiedBinding).capture(scope, access.receiver.sourceEnd),
+				scope,
+				access,
+				scope,
+				false,
+				access.receiver instanceof SuperReference);
+
+		} else if (astNode instanceof CompletionOnMessageSend) {
+			setSourceRange(astNode.sourceStart, astNode.sourceEnd, false);
+			
+			CompletionOnMessageSend messageSend = (CompletionOnMessageSend) astNode;
+			TypeBinding[] argTypes = computeTypes(messageSend.arguments);
+			this.completionToken = messageSend.selector;
+			if (qualifiedBinding == null) {
+				if (!this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
+					findImplicitMessageSends(this.completionToken, argTypes, scope, messageSend, scope);
+				}
+			} else  if (!this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
+				findMethods(
+					this.completionToken,
+					argTypes,
+					(ReferenceBinding)((ReferenceBinding) qualifiedBinding).capture(scope, messageSend.receiver.sourceEnd),
+					scope,
+					new ObjectVector(),
+					false,
+					true,
+					false,
+					messageSend,
+					scope,
+					false,
+					messageSend.receiver instanceof SuperReference,
+					true);
+			}
+		} else if (astNode instanceof CompletionOnExplicitConstructorCall) {
+			if (!this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
+				setSourceRange(astNode.sourceStart, astNode.sourceEnd, false);
+				
+				CompletionOnExplicitConstructorCall constructorCall =
+					(CompletionOnExplicitConstructorCall) astNode;
+				TypeBinding[] argTypes = computeTypes(constructorCall.arguments);
+				findConstructors(
+					(ReferenceBinding) qualifiedBinding,
+					argTypes,
+					scope,
+					constructorCall,
+					false);
 									}
-								}
-	
-							} else {
-	
-								if (astNode instanceof CompletionOnMemberAccess) {
-									this.insideQualifiedReference = true;
-									CompletionOnMemberAccess access = (CompletionOnMemberAccess) astNode;
-									long completionPosition = access.nameSourcePosition;
-									setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
+		} else if (astNode instanceof CompletionOnQualifiedAllocationExpression) {
+			setSourceRange(astNode.sourceStart, astNode.sourceEnd, false);
+			
+			CompletionOnQualifiedAllocationExpression allocExpression =
+				(CompletionOnQualifiedAllocationExpression) astNode;
+			TypeBinding[] argTypes = computeTypes(allocExpression.arguments);
+			
+			ReferenceBinding ref = (ReferenceBinding) qualifiedBinding;
+			if (!this.requestor.isIgnored(CompletionProposal.METHOD_REF)
+					&& ref.isClass()
+					&& !ref.isAbstract()) {
+					findConstructors(
+						ref,
+						argTypes,
+						scope,
+						allocExpression,
+						false);
+			}
+			if (!this.requestor.isIgnored(CompletionProposal.ANONYMOUS_CLASS_DECLARATION)
+					&& !ref.isFinal()
+					&& !ref.isEnum()){
+				findAnonymousType(
+					ref,
+					argTypes,
+					scope,
+					allocExpression);
+			}
+		} else if (astNode instanceof CompletionOnClassLiteralAccess) {
+			if (!this.requestor.isIgnored(CompletionProposal.FIELD_REF)) {
+				CompletionOnClassLiteralAccess access = (CompletionOnClassLiteralAccess) astNode;
+				setSourceRange(access.classStart, access.sourceEnd);
+
+				this.completionToken = access.completionIdentifier;
+
+				findClassField(this.completionToken, (TypeBinding) qualifiedBinding, scope);
+			}
+		} else if (astNode instanceof CompletionOnMethodName) {
+			if (!this.requestor.isIgnored(CompletionProposal.VARIABLE_DECLARATION)) {
+				CompletionOnMethodName method = (CompletionOnMethodName) astNode;
 					
-									this.completionToken = access.token;
-									
-									if(!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
-										findKeywords(this.completionToken, new char[][]{Keywords.NEW}, false);
-									}
-									
-									findFieldsAndMethods(
+				setSourceRange(method.sourceStart, method.selectorEnd);
+					
+				FieldBinding[] fields = scope.enclosingSourceType().fields();
+				char[][] excludeNames = new char[fields.length][];
+				for(int i = 0 ; i < fields.length ; i++){
+					excludeNames[i] = fields[i].name;
+				}
+				
+				this.completionToken = method.selector;
+				
+				findVariableNames(this.completionToken, method.returnType, excludeNames, FIELD, method.modifiers);
+			}
+		} else if (astNode instanceof CompletionOnFieldName) {
+			if (!this.requestor.isIgnored(CompletionProposal.VARIABLE_DECLARATION)) {
+				CompletionOnFieldName field = (CompletionOnFieldName) astNode;
+				
+				FieldBinding[] fields = scope.enclosingSourceType().fields();
+				char[][] excludeNames = new char[fields.length][];
+				for(int i = 0 ; i < fields.length ; i++){
+					excludeNames[i] = fields[i].name;
+				}
+				
+				this.completionToken = field.realName;
+				
+				findVariableNames(field.realName, field.type, excludeNames, FIELD, field.modifiers);
+			}
+		} else if (astNode instanceof CompletionOnLocalName || astNode instanceof CompletionOnArgumentName) {
+			if (!this.requestor.isIgnored(CompletionProposal.VARIABLE_DECLARATION)) {
+				LocalDeclaration variable = (LocalDeclaration) astNode;
+				
+				LocalVariableBinding[] locals = ((BlockScope)scope).locals;
+				char[][] excludeNames = new char[locals.length][];
+				int localCount = 0;
+				for(int i = 0 ; i < locals.length ; i++){
+					if (locals[i] != null) {
+						excludeNames[localCount++] = locals[i].name;
+					}
+				}
+				System.arraycopy(excludeNames, 0, excludeNames = new char[localCount][], 0, localCount);
+				
+				if (variable instanceof CompletionOnLocalName){
+					this.completionToken = ((CompletionOnLocalName) variable).realName;
+					findVariableNames(this.completionToken, variable.type, excludeNames, LOCAL, variable.modifiers);
+				} else {
+					CompletionOnArgumentName arg = (CompletionOnArgumentName) variable;
+					this.completionToken = arg.realName;
+					findVariableNames(this.completionToken, variable.type, excludeNames, arg.isCatchArgument ? LOCAL : ARGUMENT, variable.modifiers);
+				}
+			}
+		} else if (astNode instanceof CompletionOnKeyword) {
+			if (!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
+				CompletionOnKeyword keyword = (CompletionOnKeyword)astNode;
+				findKeywords(keyword.getToken(), keyword.getPossibleKeywords(), keyword.canCompleteEmptyToken());
+			}
+		} else if (astNode instanceof CompletionOnParameterizedQualifiedTypeReference) {
+			if (!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
+				CompletionOnParameterizedQualifiedTypeReference ref = (CompletionOnParameterizedQualifiedTypeReference) astNode;
+				
+				this.insideQualifiedReference = true;
+
+				this.assistNodeIsClass = ref.isClass();
+				this.assistNodeIsException = ref.isException();
+				this.assistNodeIsInterface = ref.isInterface();
+				
+				this.completionToken = ref.completionIdentifier;
+				long completionPosition = ref.sourcePositions[ref.tokens.length];
+				setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
+				findMemberTypes(
+					this.completionToken,
+					(ReferenceBinding) qualifiedBinding,
+					scope,
+					scope.enclosingSourceType(),
+					false,
+					new ObjectVector());
+			}
+		} else if (astNode instanceof CompletionOnMarkerAnnotationName) {
+			CompletionOnMarkerAnnotationName annot = (CompletionOnMarkerAnnotationName) astNode;
+			
+			this.assistNodeIsAnnotation = true;
+			if (annot.type instanceof CompletionOnSingleTypeReference) {
+				CompletionOnSingleTypeReference type = (CompletionOnSingleTypeReference) annot.type;
+				this.completionToken = type.token;
+				setSourceRange(type.sourceStart, type.sourceEnd);
+				
+				findTypesAndPackages(this.completionToken, scope);
+			} else if (annot.type instanceof CompletionOnQualifiedTypeReference) {
+				this.insideQualifiedReference = true;
+				
+				CompletionOnQualifiedTypeReference type = (CompletionOnQualifiedTypeReference) annot.type;
+				this.completionToken = type.completionIdentifier;
+				long completionPosition = type.sourcePositions[type.tokens.length];
+				if (qualifiedBinding instanceof PackageBinding) {
+
+					setSourceRange(astNode.sourceStart, (int) completionPosition);
+					// replace to the end of the completion identifier
+					findTypesAndSubpackages(this.completionToken, (PackageBinding) qualifiedBinding);
+				} else {
+					setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
+
+					findMemberTypes(
+						this.completionToken,
+						(ReferenceBinding) qualifiedBinding,
+						scope,
+						scope.enclosingSourceType(),
+						false,
+						new ObjectVector());
+				}
+			}
+		} else if (astNode instanceof CompletionOnMemberValueName) {
+			if (!this.requestor.isIgnored(CompletionProposal.ANNOTATION_ATTRIBUTE_REF)) {
+				CompletionOnMemberValueName memberValuePair = (CompletionOnMemberValueName) astNode;
+				Annotation annotation = (Annotation) astNodeParent;
+				
+				this.completionToken = memberValuePair.name;
+				
+				if (this.completionToken.length == 0) {
+					this.setSourceRange(astNode.sourceStart, astNode.sourceStart - 1, false);
+
+					findAnnotationReference(annotation.type);
+				} else {
+					MemberValuePair[] memberValuePairs = annotation.memberValuePairs();
+					this.findAnnotationAttributes(this.completionToken, annotation.memberValuePairs(), (ReferenceBinding)annotation.resolvedType);
+					if (memberValuePairs == null || memberValuePairs.length == 0) {
+						if (annotation.resolvedType instanceof ReferenceBinding) {
+							MethodBinding[] methodBindings =
+								((ReferenceBinding)annotation.resolvedType).availableMethods();
+							if (methodBindings != null &&
+									methodBindings.length == 1 &&
+									CharOperation.equals(methodBindings[0].selector, VALUE)) {
+								if (this.expectedTypesPtr > -1 && this.expectedTypes[0].isAnnotationType()) {
+									findTypesAndPackages(this.completionToken, scope);
+								} else {
+									findVariablesAndMethods(
 										this.completionToken,
-										((TypeBinding) qualifiedBinding).capture(scope, access.receiver.sourceEnd),
 										scope,
-										access,
+										FakeInvocationSite,
 										scope,
-										false,
-										access.receiver instanceof SuperReference);
-	
-								} else {
-	
-									if (astNode instanceof CompletionOnMessageSend) {
-										setSourceRange(astNode.sourceStart, astNode.sourceEnd, false);
-										
-										CompletionOnMessageSend messageSend = (CompletionOnMessageSend) astNode;
-										TypeBinding[] argTypes =
-											computeTypes(messageSend.arguments, (BlockScope) scope);
-										this.completionToken = messageSend.selector;
-										if (qualifiedBinding == null) {
-											if(!this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
-												findImplicitMessageSends(this.completionToken, argTypes, scope, messageSend, scope);
-											}
-										} else {
-											if(!this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
-												findMethods(
-													this.completionToken,
-													argTypes,
-													(ReferenceBinding)((ReferenceBinding) qualifiedBinding).capture(scope, messageSend.receiver.sourceEnd),
-													scope,
-													new ObjectVector(),
-													false,
-													true,
-													false,
-													messageSend,
-													scope,
-													false,
-													messageSend.receiver instanceof SuperReference,
-													true);
-											}
-										}
-	
-									} else {
-	
-										if (astNode instanceof CompletionOnExplicitConstructorCall) {
-											if(!this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
-												setSourceRange(astNode.sourceStart, astNode.sourceEnd, false);
-												
-												CompletionOnExplicitConstructorCall constructorCall =
-													(CompletionOnExplicitConstructorCall) astNode;
-												TypeBinding[] argTypes =
-													computeTypes(constructorCall.arguments, (BlockScope) scope);
-												findConstructors(
-													(ReferenceBinding) qualifiedBinding,
-													argTypes,
-													scope,
-													constructorCall,
-													false);
-											}
-										} else {
-	
-											if (astNode instanceof CompletionOnQualifiedAllocationExpression) {
-												setSourceRange(astNode.sourceStart, astNode.sourceEnd, false);
-												
-												CompletionOnQualifiedAllocationExpression allocExpression =
-													(CompletionOnQualifiedAllocationExpression) astNode;
-												TypeBinding[] argTypes =
-													computeTypes(allocExpression.arguments, (BlockScope) scope);
-												
-												ReferenceBinding ref = (ReferenceBinding) qualifiedBinding;
-												if(!this.requestor.isIgnored(CompletionProposal.METHOD_REF)
-														&& ref.isClass()
-														&& !ref.isAbstract()) {
-														findConstructors(
-															ref,
-															argTypes,
-															scope,
-															allocExpression,
-															false);
-												}
-												if(!this.requestor.isIgnored(CompletionProposal.ANONYMOUS_CLASS_DECLARATION)
-														&& !ref.isFinal()
-														&& !ref.isEnum()){
-													findAnonymousType(
-														ref,
-														argTypes,
-														scope,
-														allocExpression);
-												}
-	
-											} else {
-	
-												if (astNode instanceof CompletionOnClassLiteralAccess) {
-													if(!this.requestor.isIgnored(CompletionProposal.FIELD_REF)) {
-														CompletionOnClassLiteralAccess access = (CompletionOnClassLiteralAccess) astNode;
-														setSourceRange(access.classStart, access.sourceEnd);
-										
-														this.completionToken = access.completionIdentifier;
-										
-														findClassField(this.completionToken, (TypeBinding) qualifiedBinding, scope);
-													}
-												} else {
-													if(astNode instanceof CompletionOnMethodName) {
-														if(!this.requestor.isIgnored(CompletionProposal.VARIABLE_DECLARATION)) {
-															CompletionOnMethodName method = (CompletionOnMethodName) astNode;
-																
-															setSourceRange(method.sourceStart, method.selectorEnd);
-																
-															FieldBinding[] fields = scope.enclosingSourceType().fields();
-															char[][] excludeNames = new char[fields.length][];
-															for(int i = 0 ; i < fields.length ; i++){
-																excludeNames[i] = fields[i].name;
-															}
-															
-															this.completionToken = method.selector;
-															
-															findVariableNames(this.completionToken, method.returnType, excludeNames, FIELD, method.modifiers);
-														}
-													} else {
-														if (astNode instanceof CompletionOnFieldName) {
-															if(!this.requestor.isIgnored(CompletionProposal.VARIABLE_DECLARATION)) {
-																CompletionOnFieldName field = (CompletionOnFieldName) astNode;
-																
-																FieldBinding[] fields = scope.enclosingSourceType().fields();
-																char[][] excludeNames = new char[fields.length][];
-																for(int i = 0 ; i < fields.length ; i++){
-																	excludeNames[i] = fields[i].name;
-																}
-																
-																this.completionToken = field.realName;
-																
-																findVariableNames(field.realName, field.type, excludeNames, FIELD, field.modifiers);
-															}
-														} else {
-															if (astNode instanceof CompletionOnLocalName ||
-																astNode instanceof CompletionOnArgumentName){
-																if(!this.requestor.isIgnored(CompletionProposal.VARIABLE_DECLARATION)) {
-																	LocalDeclaration variable = (LocalDeclaration) astNode;
-																	
-																	LocalVariableBinding[] locals = ((BlockScope)scope).locals;
-																	char[][] excludeNames = new char[locals.length][];
-																	int localCount = 0;
-																	for(int i = 0 ; i < locals.length ; i++){
-																		if(locals[i] != null) {
-																			excludeNames[localCount++] = locals[i].name;
-																		}
-																	}
-																	System.arraycopy(excludeNames, 0, excludeNames = new char[localCount][], 0, localCount);
-																	
-																	if(variable instanceof CompletionOnLocalName){
-																		this.completionToken = ((CompletionOnLocalName) variable).realName;
-																		findVariableNames(this.completionToken, variable.type, excludeNames, LOCAL, variable.modifiers);
-																	} else {
-																		CompletionOnArgumentName arg = (CompletionOnArgumentName) variable;
-																		this.completionToken = arg.realName;
-																		findVariableNames(this.completionToken, variable.type, excludeNames, arg.isCatchArgument ? LOCAL : ARGUMENT, variable.modifiers);
-																	}
-																}
-															} else {
-																if(astNode instanceof CompletionOnKeyword) {
-																	if(!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
-																		CompletionOnKeyword keyword = (CompletionOnKeyword)astNode;
-																		findKeywords(keyword.getToken(), keyword.getPossibleKeywords(), keyword.canCompleteEmptyToken());
-																	}
-																} else if(astNode instanceof CompletionOnParameterizedQualifiedTypeReference) {
-																	if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
-																		CompletionOnParameterizedQualifiedTypeReference ref = (CompletionOnParameterizedQualifiedTypeReference) astNode;
-																		
-																		this.insideQualifiedReference = true;
-								
-																		this.assistNodeIsClass = ref.isClass();
-																		this.assistNodeIsException = ref.isException();
-																		this.assistNodeIsInterface = ref.isInterface();
-																		
-																		this.completionToken = ref.completionIdentifier;
-																		long completionPosition = ref.sourcePositions[ref.tokens.length];
-																		setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
-																		findMemberTypes(
-																			this.completionToken,
-																			(ReferenceBinding) qualifiedBinding,
-																			scope,
-																			scope.enclosingSourceType(),
-																			false,
-																			new ObjectVector());
-																	}
-																} else if(astNode instanceof CompletionOnMarkerAnnotationName) {
-																	CompletionOnMarkerAnnotationName annot = (CompletionOnMarkerAnnotationName) astNode;
-																	
-																	this.assistNodeIsAnnotation = true;
-																	if(annot.type instanceof CompletionOnSingleTypeReference) {
-																		CompletionOnSingleTypeReference type = (CompletionOnSingleTypeReference) annot.type;
-																		this.completionToken = type.token;
-																		setSourceRange(type.sourceStart, type.sourceEnd);
-																		
-																		findTypesAndPackages(this.completionToken, scope);
-																	} else if(annot.type instanceof CompletionOnQualifiedTypeReference) {
-																		this.insideQualifiedReference = true;
-																		
-																		CompletionOnQualifiedTypeReference type = (CompletionOnQualifiedTypeReference) annot.type;
-																		this.completionToken = type.completionIdentifier;
-																		long completionPosition = type.sourcePositions[type.tokens.length];
-																		if (qualifiedBinding instanceof PackageBinding) {
-	
-																			setSourceRange(astNode.sourceStart, (int) completionPosition);
-																			// replace to the end of the completion identifier
-																			findTypesAndSubpackages(this.completionToken, (PackageBinding) qualifiedBinding);
-																		} else {
-																			setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
-											
-																			findMemberTypes(
-																				this.completionToken,
-																				(ReferenceBinding) qualifiedBinding,
-																				scope,
-																				scope.enclosingSourceType(),
-																				false,
-																				new ObjectVector());
-																		}
-																	}
-																} else if (astNode instanceof CompletionOnMemberValueName) {
-																	if(!this.requestor.isIgnored(CompletionProposal.ANNOTATION_ATTRIBUTE_REF)) {
-																		CompletionOnMemberValueName memberValuePair = (CompletionOnMemberValueName) astNode;
-																		Annotation annotation = (Annotation) astNodeParent;
-																		
-																		this.completionToken = memberValuePair.name;
-																		
-																		if(this.completionToken.length == 0) {
-																			this.setSourceRange(astNode.sourceStart, astNode.sourceStart - 1, false);
-								
-																			findAnnotationReference(annotation.type);
-																		} else {
-																			MemberValuePair[] memberValuePairs = annotation.memberValuePairs();
-																			this.findAnnotationAttributes(this.completionToken, annotation.memberValuePairs(), (ReferenceBinding)annotation.resolvedType);
-																			if(memberValuePairs == null || memberValuePairs.length == 0) {
-																				if(annotation.resolvedType instanceof ReferenceBinding) {
-																					MethodBinding[] methodBindings =
-																						((ReferenceBinding)annotation.resolvedType).availableMethods();
-																					if(methodBindings != null &&
-																							methodBindings.length == 1 &&
-																							CharOperation.equals(methodBindings[0].selector, VALUE)) {
-																						if(this.expectedTypesPtr > -1 && this.expectedTypes[0].isAnnotationType()) {
-																							findTypesAndPackages(this.completionToken, scope);
-																						} else {
-																							findVariablesAndMethods(
-																								this.completionToken,
-																								scope,
-																								FakeInvocationSite,
-																								scope,
-																								insideTypeAnnotation,
-																								true);
-																							// can be the start of a qualified type name
-																							findTypesAndPackages(this.completionToken, scope);
-																						}
-																					}
-																				}
-																			}
-																		}
-																	}
-																}
-															}
-														}
-													}
-												}
-											}
-										}
-									}
+										insideTypeAnnotation,
+										true);
+									// can be the start of a qualified type name
+									findTypesAndPackages(this.completionToken, scope);
 								}
 							}
 						}
 					}
 				}
 			}
+		// Completion on Javadoc nodes
+		} else if ((astNode.bits & ASTNode.InsideJavadoc) != 0) {
+			if (astNode instanceof CompletionOnJavadocSingleTypeReference) {
+
+				CompletionOnJavadocSingleTypeReference typeRef = (CompletionOnJavadocSingleTypeReference) astNode;
+				this.completionToken = typeRef.token;
+				this.assistNodeInJavadoc = typeRef.completionFlags;
+				this.javadocTagPosition = typeRef.tagSourceStart;
+				setSourceRange(typeRef.sourceStart, typeRef.sourceEnd);
+				findTypesAndPackages(this.completionToken, scope);
+
+			} else if (astNode instanceof CompletionOnJavadocQualifiedTypeReference) {
+
+				this.insideQualifiedReference = true;
+
+				CompletionOnJavadocQualifiedTypeReference typeRef = (CompletionOnJavadocQualifiedTypeReference) astNode;
+				this.assistNodeInJavadoc = typeRef.completionFlags;
+				this.completionToken = typeRef.completionIdentifier;
+				long completionPosition = typeRef.sourcePositions[typeRef.tokens.length];
+				this.javadocTagPosition = typeRef.tagSourceStart;
+
+				// get the source positions of the completion identifier
+				if (qualifiedBinding instanceof ReferenceBinding && !(qualifiedBinding instanceof TypeVariableBinding)) {
+					if (!this.requestor.isIgnored(CompletionProposal.JAVADOC_TYPE_REF)) {
+						setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
+						findMemberTypes(this.completionToken,
+							(ReferenceBinding) qualifiedBinding,
+							scope,
+							scope.enclosingSourceType(),
+							false,
+							new ObjectVector());
+					}
+				} else if (qualifiedBinding instanceof PackageBinding) {
+
+					setSourceRange(astNode.sourceStart, (int) completionPosition);
+					// replace to the end of the completion identifier
+					findTypesAndSubpackages(this.completionToken, (PackageBinding) qualifiedBinding);
+				}
+			} else if (astNode instanceof CompletionOnJavadocFieldReference) {
+
+				this.insideQualifiedReference = true;
+				CompletionOnJavadocFieldReference fieldRef = (CompletionOnJavadocFieldReference) astNode;
+				this.completionToken = fieldRef.token;
+				this.assistNodeInJavadoc = fieldRef.completionFlags;
+				long completionPosition = fieldRef.nameSourcePosition;
+				this.javadocTagPosition = fieldRef.tagSourceStart;
+
+				if (fieldRef.receiverType != null && fieldRef.receiverType.isValidBinding()) {
+					ReferenceBinding receiverType = (ReferenceBinding) fieldRef.receiverType;
+					int rangeStart = (int) (completionPosition >>> 32);
+					if (fieldRef.receiver.isThis()) {
+						if (fieldRef.completeInText()) {
+							rangeStart = fieldRef.separatorPosition;
+						}
+					} else if (fieldRef.completeInText()) {
+						rangeStart = fieldRef.receiver.sourceStart;
+					}
+					setSourceRange(rangeStart, (int) completionPosition);
+
+					if (!this.requestor.isIgnored(CompletionProposal.FIELD_REF)
+							|| !this.requestor.isIgnored(CompletionProposal.JAVADOC_FIELD_REF)) {
+						findClassField(this.completionToken, (TypeBinding) qualifiedBinding, scope);
+					}
+
+					if (!this.requestor.isIgnored(CompletionProposal.FIELD_REF)
+							|| !this.requestor.isIgnored(CompletionProposal.JAVADOC_FIELD_REF)) {
+						findFields(this.completionToken,
+							receiverType,
+							scope,
+							new ObjectVector(),
+							new ObjectVector(),
+							false, /*not only static */
+							fieldRef,
+							scope,
+							false,
+							true);
+					}
+
+					if (!this.requestor.isIgnored(CompletionProposal.METHOD_REF)
+							|| !this.requestor.isIgnored(CompletionProposal.JAVADOC_METHOD_REF)) {
+						findMethods(this.completionToken,
+							null,
+							receiverType,
+							scope,
+							new ObjectVector(),
+							false, /*not only static */
+							false,
+							false,
+							fieldRef,
+							scope,
+							false,
+							false,
+							true);
+						if (fieldRef.receiverType instanceof ReferenceBinding) {
+							ReferenceBinding refBinding = (ReferenceBinding)fieldRef.receiverType;
+							if (this.completionToken == null || CharOperation.prefixEquals(this.completionToken, refBinding.sourceName)) {
+								findConstructors(refBinding, null, scope, fieldRef, false);
+							}
+						}
+					}
+				}
+			} else if (astNode instanceof CompletionOnJavadocMessageSend) {
+
+				CompletionOnJavadocMessageSend messageSend = (CompletionOnJavadocMessageSend) astNode;
+				TypeBinding[] argTypes = computeTypes(messageSend.arguments);
+				this.completionToken = messageSend.selector;
+				this.assistNodeInJavadoc = messageSend.completionFlags;
+				this.javadocTagPosition = messageSend.tagSourceStart;
+
+				// Set source range
+				int rangeStart = astNode.sourceStart;
+				if (messageSend.receiver.isThis()) {
+					if (messageSend.completeInText()) {
+						rangeStart = messageSend.separatorPosition;
+					}
+				} else if (messageSend.completeInText()) {
+					rangeStart = messageSend.receiver.sourceStart;
+				}
+				setSourceRange(rangeStart, astNode.sourceEnd, false);
+
+				if (qualifiedBinding == null) {
+					if (!this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
+						findImplicitMessageSends(this.completionToken, argTypes, scope, messageSend, scope);
+					}
+				} else if (!this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
+					findMethods(this.completionToken,
+						argTypes,
+						(ReferenceBinding) ((ReferenceBinding) qualifiedBinding).capture(scope, messageSend.receiver.sourceEnd),
+						scope,
+						new ObjectVector(),
+						false,
+						true,
+						false,
+						messageSend,
+						scope,
+						false,
+						messageSend.receiver instanceof SuperReference,
+						true);
+				}
+			} else if (astNode instanceof CompletionOnJavadocAllocationExpression) {
+//				setSourceRange(astNode.sourceStart, astNode.sourceEnd, false);
+
+				CompletionOnJavadocAllocationExpression allocExpression = (CompletionOnJavadocAllocationExpression) astNode;
+				this.assistNodeInJavadoc = allocExpression.completionFlags;
+				this.javadocTagPosition = allocExpression.tagSourceStart;
+				int rangeStart = astNode.sourceStart;
+				if (allocExpression.type.isThis()) {
+					if (allocExpression.completeInText()) {
+						rangeStart = allocExpression.separatorPosition;
+					}
+				} else if (allocExpression.completeInText()) {
+					rangeStart = allocExpression.type.sourceStart;
+				}
+				setSourceRange(rangeStart, astNode.sourceEnd, false);
+				TypeBinding[] argTypes = computeTypes(allocExpression.arguments);
+
+				ReferenceBinding ref = (ReferenceBinding) qualifiedBinding;
+				if (!this.requestor.isIgnored(CompletionProposal.METHOD_REF) && ref.isClass()) {
+					findConstructors(ref, argTypes, scope, allocExpression, false);
+				}
+			} else if (astNode instanceof CompletionOnJavadocParamNameReference) {
+				if (!this.requestor.isIgnored(CompletionProposal.JAVADOC_PARAM_REF)) {
+					CompletionOnJavadocParamNameReference paramRef = (CompletionOnJavadocParamNameReference) astNode;
+					this.assistNodeInJavadoc = paramRef.completionFlags;
+					setSourceRange(paramRef.tagSourceStart, paramRef.tagSourceEnd);
+					findJavadocParamNames(paramRef.token, paramRef.missingParams, false);
+					findJavadocParamNames(paramRef.token, paramRef.missingTypeParams, true);
+				}
+			} else if (astNode instanceof CompletionOnJavadocTypeParamReference) {
+				if (!this.requestor.isIgnored(CompletionProposal.JAVADOC_PARAM_REF)) {
+					CompletionOnJavadocTypeParamReference paramRef = (CompletionOnJavadocTypeParamReference) astNode;
+					this.assistNodeInJavadoc = paramRef.completionFlags;
+					setSourceRange(paramRef.tagSourceStart, paramRef.tagSourceEnd);
+					findJavadocParamNames(paramRef.token, paramRef.missingParams, true);
+				}
+			} else if (astNode instanceof CompletionOnJavadocTag) {
+				CompletionOnJavadocTag javadocTag = (CompletionOnJavadocTag) astNode;
+				setSourceRange(javadocTag.tagSourceStart, javadocTag.sourceEnd);
+				findJavadocBlockTags(javadocTag);
+				findJavadocInlineTags(javadocTag);
+			}
 		}
 		return true;
 	}
@@ -1622,15 +1728,13 @@ public final class CompletionEngine
 		}
 	}
 
-	private TypeBinding[] computeTypes(Expression[] arguments, BlockScope scope) {
-
-		if (arguments == null)
-			return null;
-
+	private TypeBinding[] computeTypes(Expression[] arguments) {
+		if (arguments == null) return null;
 		int argsLength = arguments.length;
 		TypeBinding[] argTypes = new TypeBinding[argsLength];
-		for (int a = argsLength; --a >= 0;)
+		for (int a = argsLength; --a >= 0;) {
 			argTypes[a] = arguments[a].resolvedType;
+		}
 		return argTypes;
 	}
 	
@@ -1672,7 +1776,6 @@ public final class CompletionEngine
 	private void findAnnotationReference(TypeReference ref) {
 		ReferenceBinding refBinding = (ReferenceBinding) ref.resolvedType;
 		if(refBinding != null) {
-			char[] packageName = refBinding.qualifiedPackageName();
 			char[] typeName = refBinding.qualifiedSourceName();
 			
 			int accessibility = IAccessRule.K_ACCESSIBLE;
@@ -1704,20 +1807,7 @@ public final class CompletionEngine
 			relevance += computeRelevanceForRestrictions(accessibility); // no access restriction for type in the current unit
 			
 			if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
-				CompletionProposal proposal = this.createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
-				proposal.setDeclarationSignature(packageName);
-				proposal.setSignature(getSignature(refBinding));
-				proposal.setPackageName(packageName);
-				proposal.setTypeName(typeName);
-				proposal.setCompletion(CharOperation.NO_CHAR);
-				proposal.setFlags(refBinding.modifiers);
-				proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-				proposal.setRelevance(relevance);
-				proposal.setAccessibility(accessibility);
-				this.requestor.accept(proposal);
-				if(DEBUG) {
-					this.printDebug(proposal);
-				}
+				createTypeProposal(refBinding, typeName, accessibility, CharOperation.NO_CHAR, relevance);
 			}
 		}
 	}
@@ -1778,7 +1868,7 @@ public final class CompletionEngine
 
 	private void findClassField(char[] token, TypeBinding receiverType, Scope scope) {
 
-		if (token == null)
+		if (token == null || (token.length == 0 && receiverType == null))
 			return;
 
 		if (token.length <= classField.length
@@ -1997,7 +2087,7 @@ public final class CompletionEngine
 					if (minArgLength > paramLength)
 						continue next;
 					for (int a = minArgLength; --a >= 0;)
-						if (argTypes[a] != null) // can be null if it could not be resolved properly
+						if (argTypes[a] != null && argTypes[a].isValidBinding()) // can be null if it could not be resolved properly
 							if (!argTypes[a].isCompatibleWith(constructor.parameters[a]))
 								continue next;
 	
@@ -2053,9 +2143,58 @@ public final class CompletionEngine
 						int relevance = computeBaseRelevance();
 						relevance += computeRelevanceForInterestingProposal();
 						relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE);
+
+						// Special case for completion in javadoc
+						if (this.assistNodeInJavadoc > 0) {
+							Expression receiver = null;
+							char[] selector = null;
+							if (invocationSite instanceof CompletionOnJavadocAllocationExpression) {
+								CompletionOnJavadocAllocationExpression alloc = (CompletionOnJavadocAllocationExpression) invocationSite;
+								receiver = alloc.type;
+							} else if (invocationSite instanceof CompletionOnJavadocFieldReference) {
+								CompletionOnJavadocFieldReference fieldRef = (CompletionOnJavadocFieldReference) invocationSite;
+								receiver = fieldRef.receiver;
+//								 if (fieldRef.completeTypeWithDefaultContructor()) relevance--;
+							}
+							StringBuffer javadocCompletion = new StringBuffer();
+							if (receiver.isThis()) {
+								selector = (((JavadocImplicitTypeReference)receiver).token);
+								if ((this.assistNodeInJavadoc & CompletionOnJavadoc.TEXT) != 0) {
+									javadocCompletion.append('#');
+//									javadocCompletion.append(((JavadocImplicitTypeReference)receiver).token);
+								}
+							} else if (receiver instanceof JavadocSingleTypeReference) {
+								JavadocSingleTypeReference typeRef = (JavadocSingleTypeReference) receiver;
+								selector = typeRef.token;
+								if ((this.assistNodeInJavadoc & CompletionOnJavadoc.TEXT) != 0) {
+									javadocCompletion.append(typeRef.token);
+									javadocCompletion.append('#');
+								}
+							} else if (receiver instanceof JavadocQualifiedTypeReference) {
+								JavadocQualifiedTypeReference typeRef = (JavadocQualifiedTypeReference) receiver;
+								selector = typeRef.tokens[typeRef.tokens.length-1];
+								if ((this.assistNodeInJavadoc & CompletionOnJavadoc.TEXT) != 0) {
+									javadocCompletion.append(CharOperation.concatWith(typeRef.tokens, '.'));
+									javadocCompletion.append('#');
+								}
+							}
+							// Append parameters types
+							javadocCompletion.append(selector);
+							javadocCompletion.append('(');
+							if (constructor.parameters != null) {
+								for (int p=0, ln=constructor.parameters.length; p<ln; p++) {
+									if (p>0) javadocCompletion.append(", "); //$NON-NLS-1$
+									TypeBinding argTypeBinding = constructor.parameters[p];
+									createType(argTypeBinding.erasure(), javadocCompletion);
+								}
+							}
+							javadocCompletion.append(')');
+							completion = javadocCompletion.toString().toCharArray();
+						} 
 						
+						// Create standard proposal
 						this.noProposal = false;
-						if(!this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
+						if(!this.requestor.isIgnored(CompletionProposal.METHOD_REF) && (this.assistNodeInJavadoc & CompletionOnJavadoc.ONLY_INLINE_TAG) == 0) {
 							CompletionProposal proposal = this.createProposal(CompletionProposal.METHOD_REF, this.actualCompletionPosition);
 							proposal.setDeclarationSignature(getSignature(currentType));
 							proposal.setSignature(getSignature(constructor));
@@ -2073,7 +2212,8 @@ public final class CompletionEngine
 							proposal.setIsContructor(true);
 							proposal.setCompletion(completion);
 							proposal.setFlags(constructor.modifiers);
-							proposal.setReplaceRange(this.endPosition - this.offset, this.endPosition - this.offset);
+							int start = (this.assistNodeInJavadoc > 0) ? this.startPosition : this.endPosition;
+							proposal.setReplaceRange(start - this.offset, this.endPosition - this.offset);
 							proposal.setRelevance(relevance);
 							if(parameterNames != null) proposal.setParameterNames(parameterNames);
 							this.requestor.accept(proposal);
@@ -2081,6 +2221,35 @@ public final class CompletionEngine
 								this.printDebug(proposal);
 							}
 						}
+						if ((this.assistNodeInJavadoc & CompletionOnJavadoc.TEXT) != 0 && !this.requestor.isIgnored(CompletionProposal.JAVADOC_METHOD_REF)) {
+							char[] javadocCompletion = inlineTagCompletion(completion, JavadocTagConstants.TAG_LINK);
+							CompletionProposal proposal = this.createProposal(CompletionProposal.JAVADOC_METHOD_REF, this.actualCompletionPosition);
+							proposal.setDeclarationSignature(getSignature(currentType));
+							proposal.setSignature(getSignature(constructor));
+							MethodBinding original = constructor.original();
+							if(original != constructor) {
+								proposal.setOriginalSignature(getSignature(original));
+							}
+							proposal.setDeclarationPackageName(currentType.qualifiedPackageName());
+							proposal.setDeclarationTypeName(currentType.qualifiedSourceName());
+							proposal.setParameterPackageNames(parameterPackageNames);
+							proposal.setParameterTypeNames(parameterTypeNames);
+							//proposal.setPackageName(null);
+							//proposal.setTypeName(null);
+							proposal.setName(currentType.sourceName());
+							proposal.setIsContructor(true);
+							proposal.setCompletion(javadocCompletion);
+							proposal.setFlags(constructor.modifiers);
+							int start = (this.assistNodeInJavadoc > 0) ? this.startPosition : this.endPosition;
+							if ((this.assistNodeInJavadoc & CompletionOnJavadoc.REPLACE_TAG) != 0) start = this.javadocTagPosition;
+							proposal.setReplaceRange(start - this.offset, this.endPosition - this.offset);
+							proposal.setRelevance(relevance+R_INLINE_TAG);
+							if(parameterNames != null) proposal.setParameterNames(parameterNames);
+							this.requestor.accept(proposal);
+							if(DEBUG) {
+								this.printDebug(proposal);
+							}
+						}
 					}
 				}
 			}
@@ -2105,7 +2274,6 @@ public final class CompletionEngine
 		// Inherited fields which are hidden by subclasses are filtered out
 		// No visibility checks can be performed without the scope & invocationSite
 		
-		int fieldLength = fieldName.length;
 		next : for (int f = fields.length; --f >= 0;) {			
 			FieldBinding field = fields[f];
 
@@ -2113,9 +2281,10 @@ public final class CompletionEngine
 
 			if (onlyStaticFields && !field.isStatic()) continue next;
 
-			if (fieldLength > field.name.length) continue next;
-
-			if (!CharOperation.prefixEquals(fieldName, field.name, false /* ignore case */))	continue next;
+			if (fieldName != null) {
+				if (fieldName.length > field.name.length) continue next;
+				if (!CharOperation.prefixEquals(fieldName, field.name, false /* ignore case */))	continue next;
+			}
 
 			if (this.options.checkVisibility
 				&& !field.canBeSeenBy(receiverType, invocationSite, scope))	continue next;
@@ -2174,16 +2343,37 @@ public final class CompletionEngine
 				completion = CharOperation.concat(prefix,completion,'.');
 			}
 
+			// Special case for javadoc completion
+			if (this.assistNodeInJavadoc > 0) {
+				if (invocationSite instanceof CompletionOnJavadocFieldReference) {
+					CompletionOnJavadocFieldReference fieldRef = (CompletionOnJavadocFieldReference) invocationSite;
+					if (fieldRef.receiver.isThis()) {
+						if (fieldRef.completeInText()) {
+							completion = CharOperation.concat(new char[] { '#' }, field.name);
+						}
+					} else if (fieldRef.completeInText()) {
+						if (fieldRef.receiver instanceof JavadocSingleTypeReference) {
+							JavadocSingleTypeReference typeRef = (JavadocSingleTypeReference) fieldRef.receiver;
+							completion = CharOperation.concat(typeRef.token, field.name, '#');
+						} else if (fieldRef.receiver instanceof JavadocQualifiedTypeReference) {
+							JavadocQualifiedTypeReference typeRef = (JavadocQualifiedTypeReference) fieldRef.receiver;
+							completion = CharOperation.concat(CharOperation.concatWith(typeRef.tokens, '.'), field.name, '#');
+						}
+					}
+				}
+			}
+
 			int relevance = computeBaseRelevance();
 			relevance += computeRelevanceForInterestingProposal(field);
-			relevance += computeRelevanceForCaseMatching(fieldName, field.name);
+			if (fieldName != null) relevance += computeRelevanceForCaseMatching(fieldName, field.name);
 			relevance += computeRelevanceForExpectingType(field.type);
 			relevance += computeRelevanceForStatic(onlyStaticFields, field.isStatic());
 			relevance += computeRelevanceForQualification(prefixRequired);
 			relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE);
 			
 			this.noProposal = false;
-			if(!this.requestor.isIgnored(CompletionProposal.FIELD_REF)) {
+			// Standard proposal
+			if (!this.requestor.isIgnored(CompletionProposal.FIELD_REF) && (this.assistNodeInJavadoc & CompletionOnJavadoc.ONLY_INLINE_TAG) == 0) {
 				CompletionProposal proposal = this.createProposal(CompletionProposal.FIELD_REF, this.actualCompletionPosition);
 				proposal.setDeclarationSignature(getSignature(field.declaringClass));
 				proposal.setSignature(getSignature(field.type));
@@ -2201,6 +2391,48 @@ public final class CompletionEngine
 					this.printDebug(proposal);
 				}
 			}
+
+			// Javadoc completions
+			if ((this.assistNodeInJavadoc & CompletionOnJavadoc.TEXT) != 0 && !this.requestor.isIgnored(CompletionProposal.JAVADOC_FIELD_REF)) {
+				char[] javadocCompletion = inlineTagCompletion(completion, JavadocTagConstants.TAG_LINK);
+				CompletionProposal proposal = this.createProposal(CompletionProposal.JAVADOC_FIELD_REF, this.actualCompletionPosition);
+				proposal.setDeclarationSignature(getSignature(field.declaringClass));
+				proposal.setSignature(getSignature(field.type));
+				proposal.setDeclarationPackageName(field.declaringClass.qualifiedPackageName());
+				proposal.setDeclarationTypeName(field.declaringClass.qualifiedSourceName());
+				proposal.setPackageName(field.type.qualifiedPackageName());
+				proposal.setTypeName(field.type.qualifiedSourceName()); 
+				proposal.setName(field.name);
+				proposal.setCompletion(javadocCompletion);
+				proposal.setFlags(field.modifiers);
+				int start = (this.assistNodeInJavadoc & CompletionOnJavadoc.REPLACE_TAG) != 0 ? this.javadocTagPosition : this.startPosition;
+				proposal.setReplaceRange(start - this.offset, this.endPosition - this.offset);
+				proposal.setRelevance(relevance+R_INLINE_TAG);
+				this.requestor.accept(proposal);
+				if(DEBUG) {
+					this.printDebug(proposal);
+				}
+				// Javadoc value completion for static fields
+				if (field.isStatic() && !this.requestor.isIgnored(CompletionProposal.JAVADOC_VALUE_REF)) {
+					javadocCompletion = inlineTagCompletion(completion, JavadocTagConstants.TAG_VALUE);
+					CompletionProposal valueProposal = this.createProposal(CompletionProposal.JAVADOC_VALUE_REF, this.actualCompletionPosition);
+					valueProposal.setDeclarationSignature(getSignature(field.declaringClass));
+					valueProposal.setSignature(getSignature(field.type));
+					valueProposal.setDeclarationPackageName(field.declaringClass.qualifiedPackageName());
+					valueProposal.setDeclarationTypeName(field.declaringClass.qualifiedSourceName());
+					valueProposal.setPackageName(field.type.qualifiedPackageName());
+					valueProposal.setTypeName(field.type.qualifiedSourceName()); 
+					valueProposal.setName(field.name);
+					valueProposal.setCompletion(javadocCompletion);
+					valueProposal.setFlags(field.modifiers);
+					valueProposal.setReplaceRange(start - this.offset, this.endPosition - this.offset);
+					valueProposal.setRelevance(relevance+R_VALUE_TAG);
+					this.requestor.accept(valueProposal);
+					if(DEBUG) {
+						this.printDebug(valueProposal);
+					}
+				}
+			}
 		}
 		
 		fieldsFound.addAll(newFieldsFound);
@@ -2218,7 +2450,8 @@ public final class CompletionEngine
 		boolean implicitCall,
 		boolean canBePrefixed) {
 
-		if (fieldName == null)
+		boolean notInJavadoc = this.assistNodeInJavadoc == 0;
+		if (fieldName == null && notInJavadoc)
 			return;
 
 		ReferenceBinding currentType = receiverType;
@@ -2227,7 +2460,7 @@ public final class CompletionEngine
 		do {
 
 			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
-			if (itsInterfaces != NoSuperInterfaces) {
+			if (notInJavadoc && itsInterfaces != NoSuperInterfaces) {
 
 				if (interfacesToVisit == null)
 					interfacesToVisit = new ReferenceBinding[5][];
@@ -2243,7 +2476,7 @@ public final class CompletionEngine
 			}
 
 			FieldBinding[] fields = currentType.availableFields();
-			if(fields != null) {
+			if(fields != null && fields.length > 0) {
 				findFields(
 					fieldName,
 					fields,
@@ -2258,9 +2491,9 @@ public final class CompletionEngine
 					canBePrefixed);
 			}
 			currentType = currentType.superclass();
-		} while (currentType != null);
+		} while (notInJavadoc && currentType != null);
 
-		if (interfacesToVisit != null) {
+		if (notInJavadoc && interfacesToVisit != null) {
 			for (int i = 0; i <= lastPosition; i++) {
 				ReferenceBinding[] interfaces = interfacesToVisit[i];
 				for (int j = 0, length = interfaces.length; j < length; j++) {
@@ -2520,19 +2753,7 @@ public final class CompletionEngine
 			}
 			this.noProposal = false;
 			if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
-				CompletionProposal proposal = this.createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
-				proposal.setDeclarationSignature(memberType.qualifiedPackageName());
-				proposal.setSignature(getSignature(memberType));
-				proposal.setPackageName(memberType.qualifiedPackageName());
-				proposal.setTypeName(memberType.qualifiedSourceName());
-				proposal.setCompletion(completionName);
-				proposal.setFlags(memberType.modifiers);
-				proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-				proposal.setRelevance(relevance);
-				this.requestor.accept(proposal);
-				if(DEBUG) {
-					this.printDebug(proposal);
-				}
+				createTypeProposal(memberType, memberType.qualifiedSourceName(), IAccessRule.K_ACCESSIBLE, completionName, relevance);
 			}
 		}
 	}
@@ -2674,7 +2895,75 @@ public final class CompletionEngine
 			}
 		}
 	}
-	
+
+	/*
+	 * Find javadoc block tags for a given completion javadoc tag node
+	 */
+	private void findJavadocBlockTags(CompletionOnJavadocTag javadocTag) {
+		char[][] possibleTags = javadocTag.getPossibleBlockTags();
+		if (possibleTags == null) return;
+		int length = possibleTags.length;
+		for (int i=0; i<length; i++) {
+			int relevance = computeBaseRelevance();
+			relevance += computeRelevanceForInterestingProposal();
+			relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE); // no access restriction for keywors
+			
+			this.noProposal = false;
+			if (!this.requestor.isIgnored(CompletionProposal.JAVADOC_BLOCK_TAG)) {
+				char[] possibleTag = possibleTags[i];
+				CompletionProposal proposal = this.createProposal(CompletionProposal.JAVADOC_BLOCK_TAG, this.actualCompletionPosition);
+				proposal.setName(possibleTag);
+				int tagLength = possibleTag.length;
+				char[] completion = new char[1+tagLength];
+				completion[0] = '@';
+				System.arraycopy(possibleTag, 0, completion, 1, tagLength);
+				proposal.setCompletion(completion);
+				proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+				proposal.setRelevance(relevance);
+				this.requestor.accept(proposal);
+				if (DEBUG) {
+					this.printDebug(proposal);
+				}
+			}
+		}
+	}
+
+	/*
+	 * Find javadoc inline tags for a given completion javadoc tag node
+	 */
+	private void findJavadocInlineTags(CompletionOnJavadocTag javadocTag) {
+		char[][] possibleTags = javadocTag.getPossibleInlineTags();
+		if (possibleTags == null) return;
+		int length = possibleTags.length;
+		for (int i=0; i<length; i++) {
+			int relevance = computeBaseRelevance();
+			relevance += computeRelevanceForInterestingProposal();
+			relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE); // no access restriction for keywors
+			
+			this.noProposal = false;
+			if (!this.requestor.isIgnored(CompletionProposal.JAVADOC_INLINE_TAG)) {
+				char[] possibleTag = possibleTags[i];
+				CompletionProposal proposal = this.createProposal(CompletionProposal.JAVADOC_INLINE_TAG, this.actualCompletionPosition);
+				proposal.setName(possibleTag);
+				int tagLength = possibleTag.length;
+//				boolean inlineTagStarted = javadocTag.completeInlineTagStarted();
+				char[] completion = new char[2+tagLength+2];
+				completion[0] = '{';
+				completion[1] = '@';
+				System.arraycopy(possibleTag, 0, completion, 2, tagLength);
+				completion[tagLength+2] = ' ';
+				completion[tagLength+3] = '}';
+				proposal.setCompletion(completion);
+				proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+				proposal.setRelevance(relevance);
+				this.requestor.accept(proposal);
+				if (DEBUG) {
+					this.printDebug(proposal);
+				}
+			}
+		}
+	}
+
 	// what about onDemand types? Ignore them since it does not happen!
 	// import p1.p2.A.*;
 	private void findKeywords(char[] keyword, char[][] choices, boolean canCompleteEmptyToken) {
@@ -2949,19 +3238,7 @@ public final class CompletionEngine
 				
 			this.noProposal = false;
 			if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
-				CompletionProposal proposal = this.createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
-				proposal.setDeclarationSignature(memberType.qualifiedPackageName());
-				proposal.setSignature(getSignature(memberType));
-				proposal.setPackageName(memberType.qualifiedPackageName());
-				proposal.setTypeName(memberType.qualifiedSourceName());
-				proposal.setCompletion(completionName);
-				proposal.setFlags(memberType.modifiers);
-				proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-				proposal.setRelevance(relevance);
-				this.requestor.accept(proposal);
-				if(DEBUG) {
-					this.printDebug(proposal);
-				}
+				createTypeProposal(memberType, memberType.qualifiedSourceName(), IAccessRule.K_ACCESSIBLE, completionName, relevance);
 			}
 		}
 	}
@@ -3115,7 +3392,44 @@ public final class CompletionEngine
 			}
 		}
 	}
-	
+
+	/*
+	 * Find javadoc parameter names.
+	 */
+	private void findJavadocParamNames(char[] token, char[][] missingParams, boolean isTypeParam) {
+
+		if (missingParams == null) return;
+
+		// Get relevance
+		int relevance = computeBaseRelevance();
+		relevance += computeRelevanceForInterestingProposal();
+		relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE); // no access restriction for param name
+		if (!isTypeParam) relevance += R_INTERESTING;
+
+		// Propose missing param
+		int length = missingParams.length;
+		relevance += length;
+		for (int i=0; i<length; i++) {
+			char[] argName = missingParams[i];
+			if (token == null || CharOperation.prefixEquals(token, argName)) {
+				
+				this.noProposal = false;
+				if (!this.requestor.isIgnored(CompletionProposal.JAVADOC_PARAM_REF)) {
+					CompletionProposal proposal = this.createProposal(CompletionProposal.JAVADOC_PARAM_REF, this.actualCompletionPosition);
+					proposal.setName(argName);
+					char[] completion = isTypeParam ? CharOperation.concat('<', argName, '>') : argName;
+					proposal.setCompletion(completion);
+					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+					proposal.setRelevance(--relevance);
+					this.requestor.accept(proposal);
+					if (DEBUG) {
+						this.printDebug(proposal);
+					}
+				}
+			}
+		}
+	}
+
 	private void findSubMemberTypes(
 		char[] typeName,
 		ReferenceBinding receiverType,
@@ -3162,7 +3476,7 @@ public final class CompletionEngine
 		}
 	}
 
-	private void findIntefacesMethods(
+	private void findInterfacesMethods(
 		char[] selector,
 		TypeBinding[] argTypes,
 		ReferenceBinding receiverType,
@@ -3325,7 +3639,6 @@ public final class CompletionEngine
 		// Inherited methods which are hidden by subclasses are filtered out
 		// No visibility checks can be performed without the scope & invocationSite
 
-		int methodLength = methodName.length;
 		int minArgLength = argTypes == null ? 0 : argTypes.length;
 
 		next : for (int f = methods.length; --f >= 0;) {
@@ -3350,26 +3663,25 @@ public final class CompletionEngine
 				continue next;
 			}
 
-			if (exactMatch) {
-				if (!CharOperation.equals(methodName, method.selector, false /* ignore case */
-					))
-					continue next;
-
-			} else {
-
-				if (methodLength > method.selector.length)
-					continue next;
-
-				if (!CharOperation.prefixEquals(methodName, method.selector, false
-					/* ignore case */
-					))
-					continue next;
+			if (methodName != null) {
+				if (exactMatch) {
+					if (!CharOperation.equals(methodName, method.selector, false /* ignore case */)) {
+						continue next;
+					}
+				} else {
+					if (methodName.length > method.selector.length) {
+						continue next;
+					}
+					if (!CharOperation.prefixEquals(methodName, method.selector, false	/* ignore case */)) {
+						continue next;
+					}
+				}
 			}
 			if (minArgLength > method.parameters.length)
 				continue next;
 
 			for (int a = minArgLength; --a >= 0;){
-				if (argTypes[a] != null){ // can be null if it could not be resolved properly
+				if (argTypes[a] != null && argTypes[a].isValidBinding()) { // can be null if it could not be resolved properly
 					if (!argTypes[a].isCompatibleWith(method.parameters[a])) {
 						continue next;
 					}
@@ -3437,38 +3749,83 @@ public final class CompletionEngine
 			char[] completion = CharOperation.NO_CHAR;
 			
 			int previousStartPosition = this.startPosition;
-			
-			// nothing to insert - do not want to replace the existing selector & arguments
-			if (!exactMatch) {
-				if (this.source != null
-					&& this.source.length > this.endPosition
-					&& this.source[this.endPosition] == '(')
-					completion = method.selector;
-				else
-					completion = CharOperation.concat(method.selector, new char[] { '(', ')' });
+
+			// Special case for completion in javadoc
+			if (this.assistNodeInJavadoc > 0) {
+				Expression receiver = null;
+				if (invocationSite instanceof CompletionOnJavadocMessageSend) {
+					CompletionOnJavadocMessageSend msg = (CompletionOnJavadocMessageSend) invocationSite;
+					receiver = msg.receiver;
+				} else if (invocationSite instanceof CompletionOnJavadocFieldReference) {
+					CompletionOnJavadocFieldReference fieldRef = (CompletionOnJavadocFieldReference) invocationSite;
+					receiver = fieldRef.receiver;
+				}
+				StringBuffer javadocCompletion = new StringBuffer();
+				if (receiver.isThis()) {
+					if ((this.assistNodeInJavadoc & /*IN_JAVADOC_TEXT*/CompletionOnJavadoc.TEXT) != 0) {
+						javadocCompletion.append('#');
+					}
+				} else if ((this.assistNodeInJavadoc & /*IN_JAVADOC_TEXT*/CompletionOnJavadoc.TEXT) != 0) {
+					if (receiver instanceof JavadocSingleTypeReference) {
+						JavadocSingleTypeReference typeRef = (JavadocSingleTypeReference) receiver;
+						javadocCompletion.append(typeRef.token);
+						javadocCompletion.append('#');
+					} else if (receiver instanceof JavadocQualifiedTypeReference) {
+						JavadocQualifiedTypeReference typeRef = (JavadocQualifiedTypeReference) receiver;
+						completion = CharOperation.concat(CharOperation.concatWith(typeRef.tokens, '.'), method.selector, '#');
+						for (int t=0,nt =typeRef.tokens.length; t<nt; t++) {
+							if (t>0) javadocCompletion.append('.');
+							javadocCompletion.append(typeRef.tokens[t]);
+						}
+						javadocCompletion.append('#');
+					}
+				}
+				javadocCompletion.append(method.selector);
+				// Append parameters types
+				javadocCompletion.append('(');
+				if (method.parameters != null) {
+					for (int p=0, ln=method.parameters.length; p<ln; p++) {
+						if (p>0) javadocCompletion.append(", "); //$NON-NLS-1$
+						TypeBinding argTypeBinding = method.parameters[p];
+						createType(argTypeBinding.erasure(), javadocCompletion);
+					}
+				}
+				javadocCompletion.append(')');
+				completion = javadocCompletion.toString().toCharArray();
 			} else {
-				if(prefixRequired && (this.source != null)) {
-					completion = CharOperation.subarray(this.source, this.startPosition, this.endPosition);
+				// nothing to insert - do not want to replace the existing selector & arguments
+				if (!exactMatch) {
+					if (this.source != null
+						&& this.source.length > this.endPosition
+						&& this.source[this.endPosition] == '(')
+						completion = method.selector;
+					else
+						completion = CharOperation.concat(method.selector, new char[] { '(', ')' });
 				} else {
-					this.startPosition = this.endPosition;
+					if(prefixRequired && (this.source != null)) {
+						completion = CharOperation.subarray(this.source, this.startPosition, this.endPosition);
+					} else {
+						this.startPosition = this.endPosition;
+					}
+				}
+				
+				if(prefixRequired || this.options.forceImplicitQualification){
+					char[] prefix = computePrefix(scope.enclosingSourceType(), invocationScope.enclosingSourceType(), method.isStatic());
+					completion = CharOperation.concat(prefix,completion,'.');
 				}
-			}
-			
-			if(prefixRequired || this.options.forceImplicitQualification){
-				char[] prefix = computePrefix(scope.enclosingSourceType(), invocationScope.enclosingSourceType(), method.isStatic());
-				completion = CharOperation.concat(prefix,completion,'.');
 			}
 
 			int relevance = computeBaseRelevance();
 			relevance += computeRelevanceForInterestingProposal();
-			relevance += computeRelevanceForCaseMatching(methodName, method.selector);
+			if (methodName != null) relevance += computeRelevanceForCaseMatching(methodName, method.selector);
 			relevance += computeRelevanceForExpectingType(method.returnType);
 			relevance += computeRelevanceForStatic(onlyStaticMethods, method.isStatic());
 			relevance += computeRelevanceForQualification(prefixRequired);
 			relevance += computeRelevanceForRestrictions(IAccessRule.K_ACCESSIBLE);
 			
 			this.noProposal = false;
-			if(!this.requestor.isIgnored(CompletionProposal.METHOD_REF)) {
+			// Standard proposal
+			if(!this.requestor.isIgnored(CompletionProposal.METHOD_REF) && (this.assistNodeInJavadoc & CompletionOnJavadoc.ONLY_INLINE_TAG) == 0) {
 				CompletionProposal proposal = this.createProposal(CompletionProposal.METHOD_REF, this.actualCompletionPosition);
 				proposal.setDeclarationSignature(getSignature(method.declaringClass));
 				proposal.setSignature(getSignature(method));
@@ -3493,6 +3850,35 @@ public final class CompletionEngine
 					this.printDebug(proposal);
 				}
 			}
+
+			// Javadoc proposal
+			if ((this.assistNodeInJavadoc & CompletionOnJavadoc.TEXT) != 0 && !this.requestor.isIgnored(CompletionProposal.JAVADOC_METHOD_REF)) {
+				char[] javadocCompletion = inlineTagCompletion(completion, JavadocTagConstants.TAG_LINK);
+				CompletionProposal proposal = this.createProposal(CompletionProposal.JAVADOC_METHOD_REF, this.actualCompletionPosition);
+				proposal.setDeclarationSignature(getSignature(method.declaringClass));
+				proposal.setSignature(getSignature(method));
+				MethodBinding original = method.original();
+				if(original != method) {
+					proposal.setOriginalSignature(getSignature(original));
+				}
+				proposal.setDeclarationPackageName(method.declaringClass.qualifiedPackageName());
+				proposal.setDeclarationTypeName(method.declaringClass.qualifiedSourceName());
+				proposal.setParameterPackageNames(parameterPackageNames);
+				proposal.setParameterTypeNames(parameterTypeNames);
+				proposal.setPackageName(method.returnType.qualifiedPackageName());
+				proposal.setTypeName(method.returnType.qualifiedSourceName());
+				proposal.setName(method.selector);
+				proposal.setCompletion(javadocCompletion);
+				proposal.setFlags(method.modifiers);
+				int start = (this.assistNodeInJavadoc & CompletionOnJavadoc.REPLACE_TAG) != 0 ? this.javadocTagPosition : this.startPosition;
+				proposal.setReplaceRange(start - this.offset, this.endPosition - this.offset);
+				proposal.setRelevance(relevance+R_INLINE_TAG);
+				if(parameterNames != null) proposal.setParameterNames(parameterNames);
+				this.requestor.accept(proposal);
+				if(DEBUG) {
+					this.printDebug(proposal);
+				}
+			}
 			this.startPosition = previousStartPosition;
 		}
 		
@@ -3585,7 +3971,6 @@ public final class CompletionEngine
 			this.startPosition = previousStartPosition;
 		}
 	}
-	
 	int computeRelevanceForCaseMatching(char[] token, char[] proposalName){
 		if (CharOperation.prefixEquals(token, proposalName, true /* do not ignore case */)) {
 			if(CharOperation.equals(token, proposalName, true /* do not ignore case */)) {
@@ -3648,7 +4033,7 @@ public final class CompletionEngine
 	}
 	private int computeRelevanceForException(char[] proposalName){
 		
-		if(this.assistNodeIsException &&
+		if((this.assistNodeIsException || (this.assistNodeInJavadoc & CompletionOnJavadoc.EXCEPTION) != 0 )&&
 			(CharOperation.match(EXCEPTION_PATTERN, proposalName, false) ||
 			CharOperation.match(ERROR_PATTERN, proposalName, false))) { 
 			return R_EXCEPTION;
@@ -3987,6 +4372,7 @@ public final class CompletionEngine
 			}
 		}
 	}
+
 	private void findMethods(
 		char[] selector,
 		TypeBinding[] argTypes,
@@ -4001,8 +4387,11 @@ public final class CompletionEngine
 		boolean implicitCall,
 		boolean superCall,
 		boolean canBePrefixed) {
-		if (selector == null)
+
+		boolean notInJavadoc = this.assistNodeInJavadoc == 0;
+		if (selector == null && notInJavadoc) {
 			return;
+		}
 		
 		if(isCompletingDeclaration) {
 			MethodBinding[] methods = receiverType.availableMethods();
@@ -4016,69 +4405,71 @@ public final class CompletionEngine
 		}
 		
 		ReferenceBinding currentType = receiverType;
-		if (receiverType.isInterface()) {
-			if(isCompletingDeclaration) {
-				findIntefacesMethods(
-					selector,
-					argTypes,
-					receiverType,
-					currentType.superInterfaces(),
-					scope,
-					methodsFound,
-					onlyStaticMethods,
-					exactMatch,
-					isCompletingDeclaration,
-					invocationSite,
-					invocationScope,
-					implicitCall,
-					superCall,
-					canBePrefixed);
-			} else {
-				findIntefacesMethods(
-					selector,
-					argTypes,
-					receiverType,
-					new ReferenceBinding[]{currentType},
-					scope,
-					methodsFound,
-					onlyStaticMethods,
-					exactMatch,
-					isCompletingDeclaration,
-					invocationSite,
-					invocationScope,
-					implicitCall,
-					superCall,
-					canBePrefixed);
-			}
-			
-			currentType = scope.getJavaLangObject();
-		} else {
-			if(isCompletingDeclaration){
-				findIntefacesMethods(
-					selector,
-					argTypes,
-					receiverType,
-					currentType.superInterfaces(),
-					scope,
-					methodsFound,
-					onlyStaticMethods,
-					exactMatch,
-					isCompletingDeclaration,
-					invocationSite,
-					invocationScope,
-					implicitCall,
-					superCall,
-					canBePrefixed);
+		if (notInJavadoc) {
+			if (receiverType.isInterface()) {
+				if (isCompletingDeclaration) {
+					findInterfacesMethods(
+						selector,
+						argTypes,
+						receiverType,
+						currentType.superInterfaces(),
+						scope,
+						methodsFound,
+						onlyStaticMethods,
+						exactMatch,
+						isCompletingDeclaration,
+						invocationSite,
+						invocationScope,
+						implicitCall,
+						superCall,
+						canBePrefixed);
+				} else {
+					findInterfacesMethods(
+						selector,
+						argTypes,
+						receiverType,
+						new ReferenceBinding[]{currentType},
+						scope,
+						methodsFound,
+						onlyStaticMethods,
+						exactMatch,
+						isCompletingDeclaration,
+						invocationSite,
+						invocationScope,
+						implicitCall,
+						superCall,
+						canBePrefixed);
+				}
 				
-				currentType = receiverType.superclass();
+				currentType = scope.getJavaLangObject();
+			} else {
+				if (isCompletingDeclaration){
+					findInterfacesMethods(
+						selector,
+						argTypes,
+						receiverType,
+						currentType.superInterfaces(),
+						scope,
+						methodsFound,
+						onlyStaticMethods,
+						exactMatch,
+						isCompletingDeclaration,
+						invocationSite,
+						invocationScope,
+						implicitCall,
+						superCall,
+						canBePrefixed);
+					
+					currentType = receiverType.superclass();
+				}
 			}
 		}
 		boolean hasPotentialDefaultAbstractMethods = true;
 		while (currentType != null) {
 			
 			MethodBinding[] methods = currentType.availableMethods();
-			if(methods != null) {
-				if(isCompletingDeclaration){
+			if (methods != null) {
+				if (isCompletingDeclaration){
 					findLocalMethodDeclarations(
 						selector,
 						methods,
@@ -4104,8 +4495,8 @@ public final class CompletionEngine
 				}
 			}
 			
-			if(hasPotentialDefaultAbstractMethods && currentType.isAbstract()){
-				findIntefacesMethods(
+			if (notInJavadoc && hasPotentialDefaultAbstractMethods && currentType.isAbstract()){
+				findInterfacesMethods(
 					selector,
 					argTypes,
 					receiverType,
@@ -4123,7 +4514,7 @@ public final class CompletionEngine
 			} else {
 				hasPotentialDefaultAbstractMethods = false;
 			}
-			currentType = currentType.superclass();
+			currentType = notInJavadoc ? currentType.superclass() : null;
 		}
 	}
 	private char[][] findMethodParameterNames(MethodBinding method, char[][] parameterTypeNames){
@@ -4263,19 +4654,7 @@ public final class CompletionEngine
 								
 								this.noProposal = false;
 								if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
-									CompletionProposal proposal = this.createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
-									proposal.setDeclarationSignature(localType.qualifiedPackageName());
-									proposal.setSignature(getSignature(localType));
-									proposal.setPackageName(localType.qualifiedPackageName());
-									proposal.setTypeName(localType.sourceName);
-									proposal.setCompletion(localType.sourceName);
-									proposal.setFlags(localType.modifiers);
-									proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-									proposal.setRelevance(relevance);
-									this.requestor.accept(proposal);
-									if(DEBUG) {
-										this.printDebug(proposal);
-									}
+									createTypeProposal(localType, localType.sourceName, IAccessRule.K_ACCESSIBLE, localType.sourceName, relevance);
 								}
 							}
 						}
@@ -4310,8 +4689,6 @@ public final class CompletionEngine
 	private void findParameterizedType(TypeReference ref) {
 		ReferenceBinding refBinding = (ReferenceBinding) ref.resolvedType;
 		if(refBinding != null) {
-			char[] packageName = refBinding.qualifiedPackageName();
-			char[] typeName = refBinding.qualifiedSourceName();
 			
 			int accessibility = IAccessRule.K_ACCESSIBLE;
 			if(refBinding.hasRestrictedAccess()) {
@@ -4342,20 +4719,7 @@ public final class CompletionEngine
 			relevance += computeRelevanceForRestrictions(accessibility); // no access restriction for type in the current unit
 			
 			if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
-				CompletionProposal proposal = this.createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
-				proposal.setDeclarationSignature(packageName);
-				proposal.setSignature(getSignature(refBinding));
-				proposal.setPackageName(packageName);
-				proposal.setTypeName(typeName);
-				proposal.setCompletion(CharOperation.NO_CHAR);
-				proposal.setFlags(refBinding.modifiers);
-				proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-				proposal.setRelevance(relevance);
-				proposal.setAccessibility(accessibility);
-				this.requestor.accept(proposal);
-				if(DEBUG) {
-					this.printDebug(proposal);
-				}
+				createTypeProposal(refBinding, refBinding.qualifiedSourceName(), IAccessRule.K_ACCESSIBLE, CharOperation.NO_CHAR, relevance);
 			}
 		}
 	}
@@ -4404,19 +4768,7 @@ public final class CompletionEngine
 					
 					this.noProposal = false;
 					if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
-						CompletionProposal proposal = this.createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
-						//proposal.setDeclarationSignature(null);
-						proposal.setSignature(getSignature(typeParameter.binding));
-						//proposal.setPackageName(null);
-						proposal.setTypeName(typeParameter.name);
-						proposal.setCompletion(typeParameter.name);
-						proposal.setFlags(typeParameter.modifiers);
-						proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-						proposal.setRelevance(relevance);
-						this.requestor.accept(proposal);
-						if(DEBUG) {
-							this.printDebug(proposal);
-						}
+						createTypeParameterProposal(typeParameter, relevance);
 					}
 				}
 			}
@@ -4432,7 +4784,7 @@ public final class CompletionEngine
 		// do not propose type if completion token is empty
 		boolean skip = false;
 		if (token.length == 0 && NO_TYPE_COMPLETION_ON_EMPTY_TOKEN) {
-			if(!assistNodeIsConstructor) {
+			if(!assistNodeIsConstructor && (this.assistNodeInJavadoc & CompletionOnJavadoc.EXCEPTION) == 0) {
 				return;
 			}
 			skip = true;
@@ -4447,7 +4799,7 @@ public final class CompletionEngine
 		if (!skip && proposeType && scope.enclosingSourceType() != null) {
 			findNestedTypes(token, scope.enclosingSourceType(), scope, proposeAllMemberTypes, typesFound);
 			if(!assistNodeIsConstructor) {
-				// don't propose type parmaters if the completion is a constructor ('new |')
+				// don't propose type parameters if the completion is a constructor ('new |')
 				findTypeParameters(token, scope);
 			}
 		}
@@ -4519,19 +4871,8 @@ public final class CompletionEngine
 				}
 				this.noProposal = false;
 				if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
-					CompletionProposal proposal = this.createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
-					proposal.setDeclarationSignature(sourceType.qualifiedPackageName());
-					proposal.setSignature(getSignature(sourceType));
-					proposal.setPackageName(sourceType.qualifiedPackageName());
-					proposal.setTypeName(sourceType.sourceName());
-					proposal.setCompletion(sourceType.sourceName());
-					proposal.setFlags(sourceType.modifiers);
-					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-					proposal.setRelevance(relevance);
-					this.requestor.accept(proposal);
-					if(DEBUG) {
-						this.printDebug(proposal);
-					}
+					char[] typeName = sourceType.sourceName();
+					createTypeProposal(sourceType, typeName, IAccessRule.K_ACCESSIBLE, typeName, relevance);
 				}
 			}
 		}
@@ -4639,7 +4980,9 @@ public final class CompletionEngine
 			} 
 		} else {
 			if(!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
-				findKeywords(token, baseTypes, false);
+				if (this.assistNodeInJavadoc == 0 || (this.assistNodeInJavadoc & CompletionOnJavadoc.BASE_TYPES) != 0) {
+					findKeywords(token, BASE_TYPE_NAMES, false);
+				}
 			}
 			if(proposeType) {
 				int l = typesFound.size();
@@ -4738,20 +5081,8 @@ public final class CompletionEngine
 				}
 				this.noProposal = false;
 				if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
-					CompletionProposal proposal = this.createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
-					proposal.setDeclarationSignature(sourceType.qualifiedPackageName());
-					proposal.setSignature(getSignature(sourceType));
-					proposal.setPackageName(sourceType.qualifiedPackageName());
-					proposal.setTypeName(sourceType.sourceName());
-					proposal.setCompletion(sourceType.sourceName());
-					proposal.setFlags(sourceType.modifiers);
-					proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
-					proposal.setRelevance(relevance);
-					proposal.setAccessibility(accessibility);
-					this.requestor.accept(proposal);
-					if(DEBUG) {
-						this.printDebug(proposal);
-					}
+					char[] typeName = sourceType.sourceName();
+					createTypeProposal(sourceType, typeName, IAccessRule.K_ACCESSIBLE, typeName, relevance);
 				}
 			}
 		}
@@ -5454,6 +5785,20 @@ public final class CompletionEngine
 					}
 				}
 			}
+		// Expected types for javadoc
+		} else if (parent instanceof Javadoc) {
+			if (scope.kind == Scope.METHOD_SCOPE) {
+				MethodScope methodScope = (MethodScope) scope;
+				AbstractMethodDeclaration methodDecl = methodScope.referenceMethod();
+				if (methodDecl != null && methodDecl.binding != null) {
+					ReferenceBinding[] exceptions = methodDecl.binding.thrownExceptions;
+					if (exceptions != null) {
+						for (int i = 0; i < exceptions.length; i++) {
+							addExpectedType(exceptions[i]);
+						}
+					}
+				}
+			}
 		}
 		
 		if(this.expectedTypesPtr + 1 != this.expectedTypes.length) {
@@ -5831,13 +6176,169 @@ public final class CompletionEngine
 				returnTypeSignature);
 	}
 	
-	protected CompletionProposal createProposal(int kind, int compteionOffset) {
-		CompletionProposal proposal = CompletionProposal.create(kind, compteionOffset);
+	protected CompletionProposal createProposal(int kind, int completionOffset) {
+		CompletionProposal proposal = CompletionProposal.create(kind, completionOffset);
 		proposal.nameLookup = this.nameEnvironment.nameLookup;
 		proposal.completionEngine = this;
 		return proposal;
 	}
-	
+
+	/*
+	 * Create a completion proposal for a type.
+	 */
+	private void createTypeProposal(char[] packageName, char[] typeName, int modifiers, int accessibility, char[] completionName, int relevance) {
+
+		// Create standard type proposal
+		if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF) && (this.assistNodeInJavadoc & CompletionOnJavadoc.ONLY_INLINE_TAG) == 0) {
+			CompletionProposal proposal = CompletionProposal.create(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
+			proposal.nameLookup = this.nameEnvironment.nameLookup;
+			proposal.completionEngine = this;
+			proposal.setDeclarationSignature(packageName);
+			proposal.setSignature(createNonGenericTypeSignature(packageName, typeName));
+			proposal.setPackageName(packageName);
+			proposal.setTypeName(typeName);
+			proposal.setCompletion(completionName);
+			proposal.setFlags(modifiers);
+			proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+			proposal.setRelevance(relevance);
+			proposal.setAccessibility(accessibility);
+			this.requestor.accept(proposal);	
+			if(DEBUG) {
+				this.printDebug(proposal);
+			}
+		}
+		
+		// Create javadoc text proposal if necessary
+		if ((this.assistNodeInJavadoc & CompletionOnJavadoc.TEXT) != 0 && !this.requestor.isIgnored(CompletionProposal.JAVADOC_TYPE_REF)) {
+			char[] javadocCompletion= inlineTagCompletion(completionName, JavadocTagConstants.TAG_LINK);
+			CompletionProposal proposal = CompletionProposal.create(CompletionProposal.JAVADOC_TYPE_REF, this.actualCompletionPosition);
+			proposal.nameLookup = this.nameEnvironment.nameLookup;
+			proposal.completionEngine = this;
+			proposal.setDeclarationSignature(packageName);
+			proposal.setSignature(createNonGenericTypeSignature(packageName, typeName));
+			proposal.setPackageName(packageName);
+			proposal.setTypeName(typeName);
+			proposal.setCompletion(javadocCompletion);
+			proposal.setFlags(modifiers);
+			int start = (this.assistNodeInJavadoc & CompletionOnJavadoc.REPLACE_TAG) != 0 ? this.javadocTagPosition : this.startPosition;
+			proposal.setReplaceRange(start - this.offset, this.endPosition - this.offset);
+			proposal.setRelevance(relevance+R_INLINE_TAG);
+			proposal.setAccessibility(accessibility);
+			this.requestor.accept(proposal);
+			if(DEBUG) {
+				this.printDebug(proposal);
+			}
+		}
+	}
+
+	/*
+	 * Create a completion proposal for a member type.
+	 */
+	private void createTypeProposal(ReferenceBinding refBinding, char[] typeName, int accessibility, char[] completionName, int relevance) {
+
+		// Create standard type proposal
+		if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF) && (this.assistNodeInJavadoc & CompletionOnJavadoc.ONLY_INLINE_TAG) == 0) {
+			CompletionProposal proposal = CompletionProposal.create(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
+			proposal.nameLookup = this.nameEnvironment.nameLookup;
+			proposal.completionEngine = this;
+			proposal.setDeclarationSignature(refBinding.qualifiedPackageName());
+			proposal.setSignature(getSignature(refBinding));
+			proposal.setPackageName(refBinding.qualifiedPackageName());
+			proposal.setTypeName(typeName);
+			proposal.setCompletion(completionName);
+			proposal.setFlags(refBinding.modifiers);
+			proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+			proposal.setRelevance(relevance);
+			this.requestor.accept(proposal);
+			if(DEBUG) {
+				this.printDebug(proposal);
+			}
+		}
+		
+		// Create javadoc text proposal if necessary
+		if ((this.assistNodeInJavadoc & CompletionOnJavadoc.TEXT) != 0 && !this.requestor.isIgnored(CompletionProposal.JAVADOC_TYPE_REF)) {
+			char[] javadocCompletion= inlineTagCompletion(completionName, JavadocTagConstants.TAG_LINK);
+			CompletionProposal proposal = CompletionProposal.create(CompletionProposal.JAVADOC_TYPE_REF, this.actualCompletionPosition);
+			proposal.nameLookup = this.nameEnvironment.nameLookup;
+			proposal.completionEngine = this;
+			proposal.setDeclarationSignature(refBinding.qualifiedPackageName());
+			proposal.setSignature(getSignature(refBinding));
+			proposal.setPackageName(refBinding.qualifiedPackageName());
+			proposal.setTypeName(typeName);
+			proposal.setCompletion(javadocCompletion);
+			proposal.setFlags(refBinding.modifiers);
+			int start = (this.assistNodeInJavadoc & CompletionOnJavadoc.REPLACE_TAG) != 0 ? this.javadocTagPosition : this.startPosition;
+			proposal.setReplaceRange(start - this.offset, this.endPosition - this.offset);
+			proposal.setRelevance(relevance+R_INLINE_TAG);
+			this.requestor.accept(proposal);
+			if(DEBUG) {
+				this.printDebug(proposal);
+			}
+		}
+	}
+
+	/*
+	 * Create a completion proposal for a member type.
+	 */
+	private void createTypeParameterProposal(TypeParameter typeParameter, int relevance) {
+		char[] completionName = typeParameter.name;
+
+		// Create standard type proposal
+		if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
+			CompletionProposal proposal = CompletionProposal.create(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
+			proposal.nameLookup = this.nameEnvironment.nameLookup;
+			proposal.completionEngine = this;
+			proposal.setSignature(getSignature(typeParameter.binding));
+			proposal.setTypeName(completionName);
+			proposal.setCompletion(completionName);
+			proposal.setFlags(typeParameter.modifiers);
+			proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+			proposal.setRelevance(relevance);
+			this.requestor.accept(proposal);
+			if(DEBUG) {
+				this.printDebug(proposal);
+			}
+		}
+		
+		// Create javadoc text proposal if necessary
+		if ((this.assistNodeInJavadoc & CompletionOnJavadoc.TEXT) != 0 && !this.requestor.isIgnored(CompletionProposal.JAVADOC_TYPE_REF)) {
+			char[] javadocCompletion= inlineTagCompletion(completionName, JavadocTagConstants.TAG_LINK);
+			CompletionProposal proposal = CompletionProposal.create(CompletionProposal.JAVADOC_TYPE_REF, this.actualCompletionPosition);
+			proposal.nameLookup = this.nameEnvironment.nameLookup;
+			proposal.completionEngine = this;
+			proposal.setSignature(getSignature(typeParameter.binding));
+			proposal.setTypeName(javadocCompletion);
+			proposal.setCompletion(javadocCompletion);
+			proposal.setFlags(typeParameter.modifiers);
+			proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
+			proposal.setRelevance(relevance+R_INLINE_TAG);
+			this.requestor.accept(proposal);
+			if(DEBUG) {
+				this.printDebug(proposal);
+			}
+		}
+	}
+
+	/**
+	 * Returns completion string inserted inside a specified inline tag.
+	 * @param completionName
+	 * @return char[] Completion text inclunding specified inline tag
+	 */
+	private char[] inlineTagCompletion(char[] completionName, char[] inlineTag) {
+		int tagLength= inlineTag.length;
+		int completionLength = completionName.length;
+		int inlineLength = 2+tagLength+1+completionLength+2;
+		char[] inlineCompletion = new char[inlineLength];
+		inlineCompletion[0] = '{';
+		inlineCompletion[1] = '@';
+		System.arraycopy(inlineTag, 0, inlineCompletion, 2, tagLength);
+		inlineCompletion[tagLength+2] = ' ';
+		System.arraycopy(completionName, 0, inlineCompletion, tagLength+3, completionLength);
+		inlineCompletion[inlineLength-2] = ' ';
+		inlineCompletion[inlineLength-1] = '}';
+		return inlineCompletion;
+	}
+
 	protected void printDebug(IProblem error) {
 		if(CompletionEngine.DEBUG) {
 			System.out.print("COMPLETION - completionFailure("); //$NON-NLS-1$
@@ -5915,8 +6416,12 @@ public final class CompletionEngine
 		buffer.append("]\n"); //$NON-NLS-1$
 		
 		buffer.append("\tCompletionLocation[").append(proposal.getCompletionLocation()).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$
-		buffer.append("\tReplaceStart[").append(proposal.getReplaceStart()).append("]"); //$NON-NLS-1$ //$NON-NLS-2$
-		buffer.append("-ReplaceEnd[").append(proposal.getReplaceEnd()).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$
+		int start = proposal.getReplaceStart();
+		int end = proposal.getReplaceEnd();
+		buffer.append("\tReplaceStart[").append(start).append("]"); //$NON-NLS-1$ //$NON-NLS-2$
+		buffer.append("-ReplaceEnd[").append(end).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$
+		if (this.source != null)
+			buffer.append("\tReplacedText[").append(this.source, start, end-start).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$
 		buffer.append("\tTokenStart[").append(proposal.getTokenStart()).append("]"); //$NON-NLS-1$ //$NON-NLS-2$
 		buffer.append("-TokenEnd[").append(proposal.getTokenEnd()).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$
 		buffer.append("\tRelevance[").append(proposal.getRelevance()).append("]\n"); //$NON-NLS-1$ //$NON-NLS-2$
