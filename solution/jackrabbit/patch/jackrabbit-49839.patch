diff --git a/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/nodetype/compact/CompactNodeTypeDefWriter.java b/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/nodetype/compact/CompactNodeTypeDefWriter.java
deleted file mode 100644
index 71c7aaf..0000000
--- a/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/nodetype/compact/CompactNodeTypeDefWriter.java
+++ /dev/null
@@ -1,479 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.jackrabbit.core.nodetype.compact;
-
-import java.io.IOException;
-import java.io.StringWriter;
-import java.io.Writer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-
-import javax.jcr.NamespaceException;
-import javax.jcr.PropertyType;
-import javax.jcr.RepositoryException;
-import javax.jcr.query.qom.QueryObjectModelConstants;
-import javax.jcr.version.OnParentVersionAction;
-
-import org.apache.jackrabbit.core.nodetype.NodeDef;
-import org.apache.jackrabbit.core.nodetype.NodeTypeDef;
-import org.apache.jackrabbit.core.nodetype.PropDef;
-import org.apache.jackrabbit.core.nodetype.ValueConstraint;
-import org.apache.jackrabbit.core.nodetype.ItemDef;
-import org.apache.jackrabbit.core.value.InternalValue;
-import org.apache.jackrabbit.core.value.InternalValueFactory;
-import org.apache.jackrabbit.spi.commons.namespace.NamespaceResolver;
-import org.apache.jackrabbit.spi.commons.nodetype.compact.Lexer;
-import org.apache.jackrabbit.spi.Name;
-import org.apache.jackrabbit.util.ISO9075;
-import org.apache.jackrabbit.spi.commons.conversion.NamePathResolver;
-import org.apache.jackrabbit.spi.commons.query.qom.Operator;
-import org.apache.jackrabbit.spi.commons.value.ValueFactoryQImpl;
-
-/**
- * Prints node type defs in a compact notation.
- * All used namespace declarations are also written.
- * Print Format:
- * <ex = "http://apache.org/jackrabbit/example">
- * [ex:NodeType] > ex:ParentType1, ex:ParentType2
- * orderable mixin
- *   - ex:property (STRING) = 'default1', 'default2'
- *     primary mandatory autocreated protected multiple VERSION
- *     < 'constraint1', 'constraint2'
- *   + ex:node (ex:reqType1, ex:reqType2) = ex:defaultType
- *     mandatory autocreated protected multiple VERSION
- */
-public class CompactNodeTypeDefWriter {
-
-    /**
-     * the indention string
-     */
-    private static final String INDENT = "  ";
-
-    /**
-     * the current namespace resolver
-     */
-    private final NamespaceResolver resolver;
-
-    /**
-     * the current name/path resolver
-     */
-    private final NamePathResolver npResolver;
-
-    /**
-     * the underlying writer
-     */
-    private Writer out;
-
-    /**
-     * special writer used for namespaces
-     */
-    private Writer nsWriter;
-
-    /**
-     * namespaces(prefixes) that are used
-     */
-    private HashSet usedNamespaces = new HashSet();
-
-    private final ValueFactoryQImpl factory;
-
-    /**
-     * Creates a new nodetype writer
-     *
-     * @param out the underlying writer
-     * @param r the namespace resolver
-     * @param npResolver
-     */
-    public CompactNodeTypeDefWriter(Writer out, NamespaceResolver r, NamePathResolver npResolver) {
-        this.resolver = r;
-        this.npResolver = npResolver;
-        this.out = new StringWriter();
-        this.nsWriter = out;
-        factory = new ValueFactoryQImpl(InternalValueFactory.getInstance(), npResolver); 
-    }
-
-    /**
-     * Writes the given list of NodeTypeDefs to the output writer including the
-     * used namespaces.
-     *
-     * @param l
-     * @param r
-     * @param npResolver
-     * @param out
-     * @throws IOException
-     */
-    public static void write(List l, NamespaceResolver r, NamePathResolver npResolver, Writer out)
-            throws IOException {
-        CompactNodeTypeDefWriter w = new CompactNodeTypeDefWriter(out, r, npResolver);
-        Iterator iter = l.iterator();
-        while (iter.hasNext()) {
-            NodeTypeDef def = (NodeTypeDef) iter.next();
-            w.write(def);
-        }
-        w.close();
-    }
-
-    /**
-     * Write one NodeTypeDef to this writer
-     *
-     * @param d
-     * @throws IOException
-     */
-    public void write(NodeTypeDef d) throws IOException {
-        writeName(d);
-        writeSupertypes(d);
-        writeOptions(d);
-        writePropDefs(d);
-        writeNodeDefs(d);
-        out.write("\n\n");
-    }
-
-    /**
-     * Flushes all pending write operations and Closes this writer. please note,
-     * that the underlying writer remains open.
-     *
-     * @throws IOException
-     */
-    public void close() throws IOException {
-        if (nsWriter != null) {
-            nsWriter.write("\n");
-            out.close();
-            nsWriter.write(((StringWriter) out).getBuffer().toString());
-            out = nsWriter;
-            nsWriter = null;
-        }
-        out.flush();
-        out = null;
-    }
-
-    /**
-     * write name
-     */
-    private void writeName(NodeTypeDef ntd) throws IOException {
-        out.write("[");
-        out.write(resolve(ntd.getName()));
-        out.write("]");
-    }
-
-    /**
-     * write supertypes
-     */
-    private void writeSupertypes(NodeTypeDef ntd) throws IOException {
-        Name[] sta = ntd.getSupertypes();
-        String delim = " > ";
-        for (int i = 0; i < sta.length; i++) {
-            out.write(delim);
-            out.write(resolve(sta[i]));
-            delim = ", ";
-        }
-    }
-
-    /**
-     * write options
-     */
-    private void writeOptions(NodeTypeDef ntd) throws IOException {
-        List<String> options = new ArrayList<String>();
-        if (ntd.isAbstract()) {
-            options.add(Lexer.ABSTRACT[0]);
-        }
-        if (ntd.hasOrderableChildNodes()) {
-            options.add(Lexer.ORDERABLE[0]);
-        }
-        if (ntd.isMixin()) {
-            options.add(Lexer.MIXIN[0]);
-        }
-        if (!ntd.isQueryable()) {
-            options.add(Lexer.NOQUERY[0]);
-        }
-        for (int i = 0; i < options.size(); i++) {
-            if (i == 0) {
-                out.write("\n" + INDENT);
-            } else {
-                out.write(" ");
-            }
-            out.write(options.get(i));
-        }
-    }
-
-    /**
-     * write prop defs
-     */
-    private void writePropDefs(NodeTypeDef ntd) throws IOException {
-        PropDef[] pda = ntd.getPropertyDefs();
-        for (int i = 0; i < pda.length; i++) {
-            PropDef pd = pda[i];
-            writePropDef(ntd, pd);
-        }
-    }
-
-    /**
-     * write node defs
-     */
-    private void writeNodeDefs(NodeTypeDef ntd) throws IOException {
-        NodeDef[] nda = ntd.getChildNodeDefs();
-        for (int i = 0; i < nda.length; i++) {
-            NodeDef nd = nda[i];
-            writeNodeDef(ntd, nd);
-        }
-    }
-
-    /**
-     * write prop def
-     * @param pd
-     */
-    private void writePropDef(NodeTypeDef ntd, PropDef pd) throws IOException {
-        out.write("\n" + INDENT + "- ");
-
-
-        Name name = pd.getName();
-        if (name.equals(ItemDef.ANY_NAME)) {
-            out.write('*');
-        } else {
-            writeItemDefName(name);
-        }
-        out.write(" (");
-        out.write(PropertyType.nameFromValue(pd.getRequiredType()).toLowerCase());
-        out.write(")");
-        writeDefaultValues(pd.getDefaultValues());
-        out.write(ntd.getPrimaryItemName() != null && ntd.getPrimaryItemName().equals(pd.getName()) ? " primary" : "");
-        if (pd.isMandatory()) {
-            out.write(" mandatory");
-        }
-        if (pd.isAutoCreated()) {
-            out.write(" autocreated");
-        }
-        if (pd.isProtected()) {
-            out.write(" protected");
-        }
-        if (pd.isMultiple()) {
-            out.write(" multiple");
-        }
-        if (pd.getOnParentVersion() != OnParentVersionAction.COPY) {
-            out.write(" ");
-            out.write(OnParentVersionAction.nameFromValue(pd.getOnParentVersion()).toLowerCase());
-        }
-
-        if (!pd.isFullTextSearchable()) {
-            out.write(" nofulltext");
-        }
-        if (!pd.isQueryOrderable()) {
-            out.write(" noqueryorder");
-        }
-        String[] qops = pd.getAvailableQueryOperators();
-        if (qops != null && qops.length > 0) {
-            List ops = Arrays.asList(qops);
-            List defaultOps = Arrays.asList(Operator.getAllQueryOperators());
-            if (!ops.containsAll(defaultOps)) {
-                out.write(" queryops '");
-                for (int i = 0; i < qops.length; i++) {
-                    if (qops[i].equals(QueryObjectModelConstants.JCR_OPERATOR_EQUAL_TO)) {
-                        out.write(Lexer.QUEROPS_EQUAL);
-                    } else if (qops[i].equals(QueryObjectModelConstants.JCR_OPERATOR_NOT_EQUAL_TO)) {
-                        out.write(Lexer.QUEROPS_NOTEQUAL);
-                    } else if (qops[i].equals(QueryObjectModelConstants.JCR_OPERATOR_GREATER_THAN)) {
-                        out.write(Lexer.QUEROPS_GREATERTHAN);
-                    } else if (qops[i].equals(QueryObjectModelConstants.JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO)) {
-                        out.write(Lexer.QUEROPS_GREATERTHANOREQUAL);
-                    } else if (qops[i].equals(QueryObjectModelConstants.JCR_OPERATOR_LESS_THAN)) {
-                        out.write(Lexer.QUEROPS_LESSTHAN);
-                    } else if (qops[i].equals(QueryObjectModelConstants.JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO)) {
-                        out.write(Lexer.QUEROPS_LESSTHANOREQUAL);
-                    } else if (qops[i].equals(QueryObjectModelConstants.JCR_OPERATOR_LIKE)) {
-                        out.write(Lexer.QUEROPS_LIKE);
-                    }
-                    if (i < qops.length - 1) {
-                        out.write(", ");
-                    }
-                }
-                out.write("'");
-            }
-        }
-
-        writeValueConstraints(pd.getValueConstraints());
-    }
-
-    /**
-     * write default values
-     * @param dva
-     */
-    private void writeDefaultValues(InternalValue[] dva) throws IOException {
-        if (dva != null && dva.length > 0) {
-            String delim = " = '";
-            for (int i = 0; i < dva.length; i++) {
-                out.write(delim);
-                try {
-                    InternalValue v = dva[i];
-                    out.write(escape(factory.createValue(v).getString()));
-                } catch (RepositoryException e) {
-                    out.write(escape(dva[i].toString()));
-                }
-                out.write("'");
-                delim = ", '";
-            }
-        }
-    }
-
-    /**
-     * write value constraints
-     * @param vca
-     */
-    private void writeValueConstraints(ValueConstraint[] vca) throws IOException {
-        if (vca != null && vca.length > 0) {
-            String vc = vca[0].getDefinition(npResolver);
-            out.write(" < '");
-            out.write(escape(vc));
-            out.write("'");
-            for (int i = 1; i < vca.length; i++) {
-                vc = vca[i].getDefinition(npResolver);
-                out.write(", '");
-                out.write(escape(vc));
-                out.write("'");
-            }
-        }
-    }
-
-    /**
-     * write node def
-     * @param nd
-     */
-    private void writeNodeDef(NodeTypeDef ntd, NodeDef nd) throws IOException {
-        out.write("\n" + INDENT + "+ ");
-
-        Name name = nd.getName();
-        writeItemDefName(name);
-        writeRequiredTypes(nd.getRequiredPrimaryTypes());
-        writeDefaultType(nd.getDefaultPrimaryType());
-        out.write(ntd.getPrimaryItemName() != null && ntd.getPrimaryItemName().equals(nd.getName()) ? " primary" : "");
-        if (nd.isMandatory()) {
-            out.write(" mandatory");
-        }
-        if (nd.isAutoCreated()) {
-            out.write(" autocreated");
-        }
-        if (nd.isProtected()) {
-            out.write(" protected");
-        }
-        if (nd.allowsSameNameSiblings()) {
-            out.write(" multiple");
-        }
-        if (nd.getOnParentVersion() != OnParentVersionAction.COPY) {
-            out.write(" ");
-            out.write(OnParentVersionAction.nameFromValue(nd.getOnParentVersion()).toLowerCase());
-        }
-    }
-
-    /**
-     * Write item def name
-     * @param name
-     * @throws IOException
-     */
-    private void writeItemDefName(Name name) throws IOException {
-        if (name.equals(ItemDef.ANY_NAME)) {
-            out.write('*');
-        } else {
-            out.write(resolve(name));
-        }
-    }
-    /**
-     * write required types
-     * @param reqTypes
-     */
-    private void writeRequiredTypes(Name[] reqTypes) throws IOException {
-        if (reqTypes != null && reqTypes.length > 0) {
-            String delim = " (";
-            for (int i = 0; i < reqTypes.length; i++) {
-                out.write(delim);
-                out.write(resolve(reqTypes[i]));
-                delim = ", ";
-            }
-            out.write(")");
-        }
-    }
-
-    /**
-     * write default types
-     * @param defType
-     */
-    private void writeDefaultType(Name defType) throws IOException {
-        if (defType != null && !defType.getLocalName().equals("*")) {
-            out.write(" = ");
-            out.write(resolve(defType));
-        }
-    }
-
-    /**
-     * resolve
-     * @param qname
-     * @return the resolved name
-     */
-    private String resolve(Name qname) throws IOException {
-        if (qname == null) {
-            return "";
-        }
-        try {
-            String prefix = resolver.getPrefix(qname.getNamespaceURI());
-            // check for writing namespaces
-            if (nsWriter != null) {
-                if (!usedNamespaces.contains(prefix)) {
-                    usedNamespaces.add(prefix);
-                    nsWriter.write("<'");
-                    nsWriter.write(prefix);
-                    nsWriter.write("'='");
-                    nsWriter.write(escape(qname.getNamespaceURI()));
-                    nsWriter.write("'>\n");
-                }
-            }
-            if (!prefix.equals(Name.NS_EMPTY_PREFIX)) {
-                prefix += ":";
-            }
-
-            String encLocalName = ISO9075.encode(qname.getLocalName());
-            String resolvedName = prefix + encLocalName;
-
-            // check for '-' and '+'
-            if (resolvedName.indexOf('-') >= 0 || resolvedName.indexOf('+') >= 0) {
-                return "'" + resolvedName + "'";
-            } else {
-                return resolvedName;
-            }
-
-        } catch (NamespaceException e) {
-            return qname.toString();
-        }
-    }
-
-    /**
-     * escape
-     * @param s
-     * @return the escaped string
-     */
-    private String escape(String s) {
-        StringBuffer sb = new StringBuffer(s);
-        for (int i = 0; i < sb.length(); i++) {
-            if (sb.charAt(i) == '\\') {
-                sb.insert(i, '\\');
-                i++;
-            } else if (sb.charAt(i) == '\'') {
-                sb.insert(i, '\'');
-                i++;
-            }
-        }
-        return sb.toString();
-    }
-}
