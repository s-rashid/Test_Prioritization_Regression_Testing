diff --git a/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/nodetype/NodeTypeRegistry.java b/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/nodetype/NodeTypeRegistry.java
index 2529b47..799bb28 100644
--- a/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/nodetype/NodeTypeRegistry.java
+++ b/jackrabbit-core/src/main/java/org/apache/jackrabbit/core/nodetype/NodeTypeRegistry.java
@@ -16,34 +16,16 @@
  */
 package org.apache.jackrabbit.core.nodetype;
 
-import EDU.oswego.cs.dl.util.concurrent.ConcurrentReaderHashMap;
-import org.apache.commons.collections.map.ReferenceMap;
-import org.apache.commons.io.IOUtils;
-import org.apache.jackrabbit.core.cluster.NodeTypeEventChannel;
-import org.apache.jackrabbit.core.cluster.NodeTypeEventListener;
-import org.apache.jackrabbit.core.fs.FileSystem;
-import org.apache.jackrabbit.core.fs.FileSystemException;
-import org.apache.jackrabbit.core.fs.FileSystemResource;
-import org.apache.jackrabbit.core.util.Dumpable;
-import org.apache.jackrabbit.core.value.InternalValue;
-import org.apache.jackrabbit.spi.Name;
-import org.apache.jackrabbit.spi.QValueConstraint;
-import org.apache.jackrabbit.spi.commons.name.NameConstants;
-import org.apache.jackrabbit.spi.commons.name.NameFactoryImpl;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.PrintStream;
-import java.io.InputStreamReader;
 import java.io.Reader;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 import java.util.Stack;
@@ -55,6 +37,24 @@ import javax.jcr.nodetype.ConstraintViolationException;
 import javax.jcr.nodetype.NoSuchNodeTypeException;
 import javax.jcr.version.OnParentVersionAction;
 
+import org.apache.commons.collections.map.ReferenceMap;
+import org.apache.commons.io.IOUtils;
+import org.apache.jackrabbit.core.cluster.NodeTypeEventChannel;
+import org.apache.jackrabbit.core.cluster.NodeTypeEventListener;
+import org.apache.jackrabbit.core.fs.FileSystem;
+import org.apache.jackrabbit.core.fs.FileSystemException;
+import org.apache.jackrabbit.core.fs.FileSystemResource;
+import org.apache.jackrabbit.core.util.Dumpable;
+import org.apache.jackrabbit.core.value.InternalValue;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.QValueConstraint;
+import org.apache.jackrabbit.spi.commons.name.NameConstants;
+import org.apache.jackrabbit.spi.commons.name.NameFactoryImpl;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import EDU.oswego.cs.dl.util.concurrent.ConcurrentReaderHashMap;
+
 /**
  * A <code>NodeTypeRegistry</code> ...
  */
@@ -84,15 +84,15 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
     private EffectiveNodeTypeCache entCache;
 
     // map of node type names and node type definitions
-    private final ConcurrentReaderHashMap registeredNTDefs;
+    private final Map<Name, NodeTypeDef> registeredNTDefs;
 
     // definition of the root node
     private final NodeDef rootNodeDef;
 
     // map of id's and property definitions
-    private final ConcurrentReaderHashMap propDefs;
+    private final Map<PropDefId, PropDef> propDefs;
     // map of id's and node definitions
-    private final ConcurrentReaderHashMap nodeDefs;
+    private final Map<NodeDefId, NodeDef> nodeDefs;
 
     /**
      * namespace registry for resolving prefixes and namespace URI's;
@@ -103,7 +103,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
     /**
      * Listeners (soft references)
      */
-    private final Map listeners =
+    private final Map<NodeTypeRegistryListener, NodeTypeRegistryListener> listeners =
             Collections.synchronizedMap(new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK));
 
     /**
@@ -114,10 +114,10 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
     /**
      * Create a new <code>NodeTypeRegistry</codes>
      *
-     * @param nsReg
-     * @param ntStore
+     * @param nsReg namespace registry
+     * @param ntStore node type store
      * @return <code>NodeTypeRegistry</codes> object
-     * @throws RepositoryException
+     * @throws RepositoryException if an error occurs
      */
     public static NodeTypeRegistry create(NamespaceRegistry nsReg, FileSystem ntStore)
             throws RepositoryException {
@@ -133,7 +133,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
      * @return the names of all registered node types.
      */
     public Name[] getRegisteredNodeTypes() {
-        return (Name[]) registeredNTDefs.keySet().toArray(new Name[registeredNTDefs.size()]);
+        return registeredNTDefs.keySet().toArray(new Name[registeredNTDefs.size()]);
     }
 
     /**
@@ -183,7 +183,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
         persistCustomNodeTypeDefs(customNTDefs);
 
         if (eventChannel != null) {
-            HashSet ntDefs = new HashSet();
+            Set<NodeTypeDef> ntDefs = new HashSet<NodeTypeDef>();
             ntDefs.add(ntd);
             eventChannel.registered(ntDefs);
         }
@@ -206,7 +206,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
      * @throws InvalidNodeTypeDefException if the given node type definition is invalid.
      * @throws RepositoryException if a repository error occurs.
      */
-    public void registerNodeTypes(Collection ntDefs)
+    public void registerNodeTypes(Collection<NodeTypeDef> ntDefs)
             throws InvalidNodeTypeDefException, RepositoryException {
 
         registerNodeTypes(ntDefs, false);
@@ -220,14 +220,14 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
      * @throws InvalidNodeTypeDefException if the given node type definition is invalid.
      * @throws RepositoryException if a repository error occurs.
      */
-    private synchronized void registerNodeTypes(Collection ntDefs, boolean external)
+    private synchronized void registerNodeTypes(Collection<NodeTypeDef> ntDefs,
+                                                boolean external)
             throws InvalidNodeTypeDefException, RepositoryException {
 
         // validate and register new node type definitions
         internalRegister(ntDefs);
         // persist new node type definitions
-        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
-            NodeTypeDef ntDef = (NodeTypeDef) iter.next();
+        for (NodeTypeDef ntDef: ntDefs) {
             customNTDefs.add(ntDef);
         }
         persistCustomNodeTypeDefs(customNTDefs);
@@ -238,8 +238,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
         }
 
         // notify listeners
-        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
-            NodeTypeDef ntDef = (NodeTypeDef) iter.next();
+        for (NodeTypeDef ntDef : ntDefs) {
             notifyRegistered(ntDef.getName());
         }
     }
@@ -258,7 +257,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
      * @throws RepositoryException if another error occurs
      * @see #unregisterNodeType(Name)
      */
-    public void unregisterNodeTypes(Collection ntNames)
+    public void unregisterNodeTypes(Collection<Name> ntNames)
             throws NoSuchNodeTypeException, RepositoryException {
 
         unregisterNodeTypes(ntNames, false);
@@ -274,12 +273,11 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
      *                                 denote a registered node type.
      * @throws RepositoryException if another error occurs
      */
-    private synchronized void unregisterNodeTypes(Collection ntNames, boolean external)
+    private synchronized void unregisterNodeTypes(Collection<Name> ntNames, boolean external)
             throws NoSuchNodeTypeException, RepositoryException {
 
         // do some preliminary checks
-        for (Iterator iter = ntNames.iterator(); iter.hasNext();) {
-            Name ntName = (Name) iter.next();
+        for (Name ntName: ntNames) {
             if (!registeredNTDefs.containsKey(ntName)) {
                 throw new NoSuchNodeTypeException(ntName.toString());
             }
@@ -289,13 +287,13 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
             }
             // check for node types other than those to be unregistered
             // that depend on the given node types
-            Set dependents = getDependentNodeTypes(ntName);
+            Set<Name> dependents = getDependentNodeTypes(ntName);
             dependents.removeAll(ntNames);
             if (dependents.size() > 0) {
                 StringBuffer msg = new StringBuffer();
                 msg.append(ntName).append(" can not be removed because the following node types depend on it: ");
-                for (Iterator depIter = dependents.iterator(); depIter.hasNext();) {
-                    msg.append(depIter.next());
+                for (Name dependent : dependents) {
+                    msg.append(dependent);
                     msg.append(" ");
                 }
                 throw new RepositoryException(msg.toString());
@@ -303,8 +301,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
         }
 
         // make sure node types are not currently in use
-        for (Iterator iter = ntNames.iterator(); iter.hasNext();) {
-            Name ntName = (Name) iter.next();
+        for (Name ntName : ntNames) {
             checkForReferencesInContent(ntName);
         }
 
@@ -317,8 +314,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
         }
 
         // persist removal of node type definitions & notify listeners
-        for (Iterator iter = ntNames.iterator(); iter.hasNext();) {
-            Name ntName = (Name) iter.next();
+        for (Name ntName : ntNames) {
             customNTDefs.remove(ntName);
             notifyUnregistered(ntName);
         }
@@ -344,7 +340,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
      */
     public void unregisterNodeType(Name ntName)
             throws NoSuchNodeTypeException, RepositoryException {
-        HashSet ntNames = new HashSet();
+        HashSet<Name> ntNames = new HashSet<Name>();
         ntNames.add(ntName);
         unregisterNodeTypes(ntNames);
     }
@@ -400,7 +396,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
         /**
          * build diff of current and new definition and determine type of change
          */
-        NodeTypeDef ntdOld = (NodeTypeDef) registeredNTDefs.get(name);
+        NodeTypeDef ntdOld = registeredNTDefs.get(name);
         NodeTypeDefDiff diff = NodeTypeDefDiff.create(ntdOld, ntd);
         if (!diff.isModified()) {
             // the definition has not been modified, there's nothing to do here...
@@ -464,9 +460,9 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
     }
 
     /**
-     * @param ntName
-     * @return
-     * @throws NoSuchNodeTypeException
+     * @param ntName name
+     * @return effective node type
+     * @throws NoSuchNodeTypeException if node type does not exist
      */
     public EffectiveNodeType getEffectiveNodeType(Name ntName)
             throws NoSuchNodeTypeException {
@@ -483,7 +479,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
      * @throws NodeTypeConflictException if the given types are conflicting
      * @throws NoSuchNodeTypeException if one of the given types is not found
      */
-    public EffectiveNodeType getEffectiveNodeType(Name primary, Set mixins)
+    public EffectiveNodeType getEffectiveNodeType(Name primary, Set<Name> mixins)
             throws NodeTypeConflictException, NoSuchNodeTypeException {
         if (mixins.isEmpty()) {
             return getEffectiveNodeType(primary);
@@ -501,9 +497,9 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
      *
      * @param nodeTypeName node type name
      * @return a set of node type <code>Name</code>s
-     * @throws NoSuchNodeTypeException
+     * @throws NoSuchNodeTypeException if node type does not exist
      */
-    public Set getDependentNodeTypes(Name nodeTypeName)
+    public Set<Name> getDependentNodeTypes(Name nodeTypeName)
             throws NoSuchNodeTypeException {
         if (!registeredNTDefs.containsKey(nodeTypeName)) {
             throw new NoSuchNodeTypeException(nodeTypeName.toString());
@@ -513,10 +509,8 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
          * collect names of those node types that have dependencies on the given
          * node type
          */
-        HashSet names = new HashSet();
-        Iterator iter = registeredNTDefs.values().iterator();
-        while (iter.hasNext()) {
-            NodeTypeDef ntd = (NodeTypeDef) iter.next();
+        HashSet<Name> names = new HashSet<Name>();
+        for (NodeTypeDef ntd : registeredNTDefs.values()) {
             if (ntd.getDependencies().contains(nodeTypeName)) {
                 names.add(ntd.getName());
             }
@@ -534,7 +528,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
      */
     public NodeTypeDef getNodeTypeDef(Name nodeTypeName)
             throws NoSuchNodeTypeException {
-        NodeTypeDef def = (NodeTypeDef) registeredNTDefs.get(nodeTypeName);
+        NodeTypeDef def = registeredNTDefs.get(nodeTypeName);
         if (def == null) {
             throw new NoSuchNodeTypeException(nodeTypeName.toString());
         }
@@ -543,7 +537,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
     }
 
     /**
-     * @param nodeTypeName
+     * @param nodeTypeName node type name
      * @return <code>true</code> if the specified node type is registered;
      *         <code>false</code> otherwise.
      */
@@ -552,7 +546,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
     }
 
     /**
-     * @param nodeTypeName
+     * @param nodeTypeName node type name
      * @return <code>true</code> if the specified node type is built-in;
      *         <code>false</code> otherwise.
      */
@@ -561,19 +555,19 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
     }
 
     /**
-     * @param id
+     * @param id node def id
      * @return the node definition for the given id.
      */
     public NodeDef getNodeDef(NodeDefId id) {
-        return (NodeDef) nodeDefs.get(id);
+        return nodeDefs.get(id);
     }
 
     /**
-     * @param id
+     * @param id property def id
      * @return the property definition for the given id.
      */
     public PropDef getPropDef(PropDefId id) {
-        return (PropDef) propDefs.get(id);
+        return propDefs.get(id);
     }
 
     /**
@@ -606,77 +600,75 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
         ps.println();
         ps.println("Registered NodeTypes:");
         ps.println();
-        Iterator iter = registeredNTDefs.values().iterator();
-        while (iter.hasNext()) {
-            NodeTypeDef ntd = (NodeTypeDef) iter.next();
+        for (NodeTypeDef ntd : registeredNTDefs.values()) {
             ps.println(ntd.getName());
             Name[] supertypes = ntd.getSupertypes();
             ps.println("\tSupertypes");
-            for (int i = 0; i < supertypes.length; i++) {
-                ps.println("\t\t" + supertypes[i]);
+            for (Name supertype : supertypes) {
+                ps.println("\t\t" + supertype);
             }
             ps.println("\tMixin\t" + ntd.isMixin());
             ps.println("\tOrderableChildNodes\t" + ntd.hasOrderableChildNodes());
             ps.println("\tPrimaryItemName\t" + (ntd.getPrimaryItemName() == null ? "<null>" : ntd.getPrimaryItemName().toString()));
             PropDef[] pd = ntd.getPropertyDefs();
-            for (int i = 0; i < pd.length; i++) {
+            for (PropDef aPd : pd) {
                 ps.print("\tPropertyDefinition");
-                ps.println(" (declared in " + pd[i].getDeclaringNodeType() + ") id=" + pd[i].getId());
-                ps.println("\t\tName\t\t" + (pd[i].definesResidual() ? "*" : pd[i].getName().toString()));
-                String type = pd[i].getRequiredType() == 0 ? "null" : PropertyType.nameFromValue(pd[i].getRequiredType());
+                ps.println(" (declared in " + aPd.getDeclaringNodeType() + ") id=" + aPd.getId());
+                ps.println("\t\tName\t\t" + (aPd.definesResidual() ? "*" : aPd.getName().toString()));
+                String type = aPd.getRequiredType() == 0 ? "null" : PropertyType.nameFromValue(aPd.getRequiredType());
                 ps.println("\t\tRequiredType\t" + type);
-                QValueConstraint[] vca = pd[i].getValueConstraints();
+                QValueConstraint[] vca = aPd.getValueConstraints();
                 StringBuffer constraints = new StringBuffer();
                 if (vca == null) {
                     constraints.append("<null>");
                 } else {
-                    for (int n = 0; n < vca.length; n++) {
+                    for (QValueConstraint aVca : vca) {
                         if (constraints.length() > 0) {
                             constraints.append(", ");
                         }
-                        constraints.append(vca[n].getString());
+                        constraints.append(aVca.getString());
                     }
                 }
                 ps.println("\t\tValueConstraints\t" + constraints.toString());
-                InternalValue[] defVals = pd[i].getDefaultValues();
+                InternalValue[] defVals = aPd.getDefaultValues();
                 StringBuffer defaultValues = new StringBuffer();
                 if (defVals == null) {
                     defaultValues.append("<null>");
                 } else {
-                    for (int n = 0; n < defVals.length; n++) {
+                    for (InternalValue defVal : defVals) {
                         if (defaultValues.length() > 0) {
                             defaultValues.append(", ");
                         }
-                        defaultValues.append(defVals[n].toString());
+                        defaultValues.append(defVal.toString());
                     }
                 }
                 ps.println("\t\tDefaultValue\t" + defaultValues.toString());
-                ps.println("\t\tAutoCreated\t" + pd[i].isAutoCreated());
-                ps.println("\t\tMandatory\t" + pd[i].isMandatory());
-                ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(pd[i].getOnParentVersion()));
-                ps.println("\t\tProtected\t" + pd[i].isProtected());
-                ps.println("\t\tMultiple\t" + pd[i].isMultiple());
+                ps.println("\t\tAutoCreated\t" + aPd.isAutoCreated());
+                ps.println("\t\tMandatory\t" + aPd.isMandatory());
+                ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(aPd.getOnParentVersion()));
+                ps.println("\t\tProtected\t" + aPd.isProtected());
+                ps.println("\t\tMultiple\t" + aPd.isMultiple());
             }
             NodeDef[] nd = ntd.getChildNodeDefs();
-            for (int i = 0; i < nd.length; i++) {
+            for (NodeDef aNd : nd) {
                 ps.print("\tNodeDefinition");
-                ps.println(" (declared in " + nd[i].getDeclaringNodeType() + ") id=" + nd[i].getId());
-                ps.println("\t\tName\t\t" + (nd[i].definesResidual() ? "*" : nd[i].getName().toString()));
-                Name[] reqPrimaryTypes = nd[i].getRequiredPrimaryTypes();
+                ps.println(" (declared in " + aNd.getDeclaringNodeType() + ") id=" + aNd.getId());
+                ps.println("\t\tName\t\t" + (aNd.definesResidual() ? "*" : aNd.getName().toString()));
+                Name[] reqPrimaryTypes = aNd.getRequiredPrimaryTypes();
                 if (reqPrimaryTypes != null && reqPrimaryTypes.length > 0) {
-                    for (int n = 0; n < reqPrimaryTypes.length; n++) {
-                        ps.print("\t\tRequiredPrimaryType\t" + reqPrimaryTypes[n]);
+                    for (Name reqPrimaryType : reqPrimaryTypes) {
+                        ps.print("\t\tRequiredPrimaryType\t" + reqPrimaryType);
                     }
                 }
-                Name defPrimaryType = nd[i].getDefaultPrimaryType();
+                Name defPrimaryType = aNd.getDefaultPrimaryType();
                 if (defPrimaryType != null) {
                     ps.print("\n\t\tDefaultPrimaryType\t" + defPrimaryType);
                 }
-                ps.println("\n\t\tAutoCreated\t" + nd[i].isAutoCreated());
-                ps.println("\t\tMandatory\t" + nd[i].isMandatory());
-                ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(nd[i].getOnParentVersion()));
-                ps.println("\t\tProtected\t" + nd[i].isProtected());
-                ps.println("\t\tAllowsSameNameSiblings\t" + nd[i].allowsSameNameSiblings());
+                ps.println("\n\t\tAutoCreated\t" + aNd.isAutoCreated());
+                ps.println("\t\tMandatory\t" + aNd.isMandatory());
+                ps.println("\t\tOnVersion\t" + OnParentVersionAction.nameFromValue(aNd.getOnParentVersion()));
+                ps.println("\t\tProtected\t" + aNd.isProtected());
+                ps.println("\t\tAllowsSameNameSiblings\t" + aNd.allowsSameNameSiblings());
             }
         }
         ps.println();
@@ -718,10 +710,11 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
     /**
      * Protected constructor
      *
-     * @param nsReg
-     * @param ntStore
-     * @throws RepositoryException
+     * @param nsReg name space registry
+     * @param ntStore store
+     * @throws RepositoryException if an error occurs
      */
+    @SuppressWarnings("unchecked")
     protected NodeTypeRegistry(NamespaceRegistry nsReg, FileSystem ntStore)
             throws RepositoryException {
         this.nsReg = nsReg;
@@ -998,20 +991,16 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
     }
 
     /**
-     * @param ntName
-     * @param entCache
-     * @param ntdCache
-     * @return
-     * @throws NoSuchNodeTypeException
+     * @param ntName node type name
      * @param entCache cache of already-built effective node types
      * @param ntdCache cache of node type definitions
-     * @return
+     * @return the effective node type
      * @throws NoSuchNodeTypeException if a node type reference (e.g. a supertype)
      *                                 could not be resolved.
      */
     static EffectiveNodeType getEffectiveNodeType(Name ntName,
                                                   EffectiveNodeTypeCache entCache,
-                                                  Map ntdCache)
+                                                  Map<Name, NodeTypeDef> ntdCache)
             throws NoSuchNodeTypeException {
         // 1. check if effective node type has already been built
         EffectiveNodeTypeCache.Key key = entCache.getKey(new Name[]{ntName});
@@ -1021,7 +1010,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
         }
 
         // 2. make sure we've got the definition of the specified node type
-        NodeTypeDef ntd = (NodeTypeDef) ntdCache.get(ntName);
+        NodeTypeDef ntd = ntdCache.get(ntName);
         if (ntd == null) {
             throw new NoSuchNodeTypeException(ntName.toString());
         }
@@ -1057,7 +1046,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
      */
     static EffectiveNodeType getEffectiveNodeType(Name[] ntNames,
                                                   EffectiveNodeTypeCache entCache,
-                                                  Map ntdCache)
+                                                  Map<Name, NodeTypeDef> ntdCache)
             throws NodeTypeConflictException, NoSuchNodeTypeException {
 
         EffectiveNodeTypeCache.Key key = entCache.getKey(ntNames);
@@ -1068,9 +1057,9 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
         }
 
         // 2. make sure we've got the definitions of the specified node types
-        for (int i = 0; i < ntNames.length; i++) {
-            if (!ntdCache.containsKey(ntNames[i])) {
-                throw new NoSuchNodeTypeException(ntNames[i].toString());
+        for (Name ntName : ntNames) {
+            if (!ntdCache.containsKey(ntName)) {
+                throw new NoSuchNodeTypeException(ntName.toString());
             }
         }
 
@@ -1099,8 +1088,8 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
                      * build aggregate of remaining node types through iteration
                      */
                     Name[] remainder = key.getNames();
-                    for (int i = 0; i < remainder.length; i++) {
-                        NodeTypeDef ntd = (NodeTypeDef) ntdCache.get(remainder[i]);
+                    for (Name aRemainder : remainder) {
+                        NodeTypeDef ntd = ntdCache.get(aRemainder);
                         EffectiveNodeType ent =
                                 EffectiveNodeType.create(ntd, entCache, ntdCache);
                         // store new effective node type
@@ -1127,11 +1116,10 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
     }
 
     static void checkForCircularInheritance(Name[] supertypes,
-                                            Stack inheritanceChain,
-                                            Map ntDefCache)
+                                            Stack<Name> inheritanceChain,
+                                            Map<Name, NodeTypeDef> ntDefCache)
             throws InvalidNodeTypeDefException, RepositoryException {
-        for (int i = 0; i < supertypes.length; i++) {
-            Name nt = supertypes[i];
+        for (Name nt : supertypes) {
             int pos = inheritanceChain.lastIndexOf(nt);
             if (pos >= 0) {
                 StringBuffer buf = new StringBuffer();
@@ -1148,8 +1136,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
             }
 
             try {
-
-                NodeTypeDef ntd = (NodeTypeDef) ntDefCache.get(nt);
+                NodeTypeDef ntd = ntDefCache.get(nt);
                 Name[] sta = ntd.getSupertypes();
                 if (sta.length > 0) {
                     // check recursively
@@ -1166,15 +1153,14 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
     }
 
     static void checkForCircularNodeAutoCreation(EffectiveNodeType childNodeENT,
-                                                 Stack definingParentNTs,
+                                                 Stack<Name> definingParentNTs,
                                                  EffectiveNodeTypeCache anEntCache,
-                                                 Map ntDefCache)
+                                                 Map<Name, NodeTypeDef> ntDefCache)
             throws InvalidNodeTypeDefException {
         // check for circularity through default node types of auto-created child nodes
         // (node type 'a' defines auto-created child node with default node type 'a')
         Name[] childNodeNTs = childNodeENT.getAllNodeTypes();
-        for (int i = 0; i < childNodeNTs.length; i++) {
-            Name nt = childNodeNTs[i];
+        for (Name nt : childNodeNTs) {
             int pos = definingParentNTs.lastIndexOf(nt);
             if (pos >= 0) {
                 StringBuffer buf = new StringBuffer();
@@ -1195,9 +1181,9 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
         }
 
         NodeDef[] nodeDefs = childNodeENT.getAutoCreateNodeDefs();
-        for (int i = 0; i < nodeDefs.length; i++) {
-            Name dnt = nodeDefs[i].getDefaultPrimaryType();
-            Name definingNT = nodeDefs[i].getDeclaringNodeType();
+        for (NodeDef nodeDef : nodeDefs) {
+            Name dnt = nodeDef.getDefaultPrimaryType();
+            Name definingNT = nodeDef.getDeclaringNodeType();
             try {
                 if (dnt != null) {
                     // check recursively
@@ -1208,7 +1194,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
                 }
             } catch (NoSuchNodeTypeException nsnte) {
                 String msg = definingNT
-                        + " defines invalid default node type for child node " + nodeDefs[i].getName();
+                        + " defines invalid default node type for child node " + nodeDef.getName();
                 log.debug(msg);
                 throw new InvalidNodeTypeDefException(msg, nsnte);
             }
@@ -1236,12 +1222,12 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
 
         // store property & child node definitions of new node type by id
         PropDef[] pda = ntd.getPropertyDefs();
-        for (int i = 0; i < pda.length; i++) {
-            propDefs.put(pda[i].getId(), pda[i]);
+        for (PropDef aPda : pda) {
+            propDefs.put(aPda.getId(), aPda);
         }
         NodeDef[] nda = ntd.getChildNodeDefs();
-        for (int i = 0; i < nda.length; i++) {
-            nodeDefs.put(nda[i].getId(), nda[i]);
+        for (NodeDef aNda : nda) {
+            nodeDefs.put(aNda.getId(), aNda);
         }
 
         return ent;
@@ -1256,11 +1242,11 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
      * eventually registered.
      *
      * @param ntDefs collection of <code>NodeTypeDef</code> objects
-     * @throws InvalidNodeTypeDefException
-     * @throws RepositoryException
+     * @throws InvalidNodeTypeDefException if the node type is not valid
+     * @throws RepositoryException if an error occurs
      * @see #registerNodeType
      */
-    private void internalRegister(Collection ntDefs)
+    private void internalRegister(Collection<NodeTypeDef> ntDefs)
             throws InvalidNodeTypeDefException, RepositoryException {
         internalRegister(ntDefs, false);
     }
@@ -1275,19 +1261,18 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
      * that can be exposed in a property definition because it is
      * system-generated (such as jcr:primaryType in nt:base).
      */
-    private void internalRegister(Collection ntDefs, boolean lenient)
+    private void internalRegister(Collection<NodeTypeDef> ntDefs, boolean lenient)
             throws InvalidNodeTypeDefException, RepositoryException {
 
         // create working copies of current ent & ntd caches:
         // cache of pre-built aggregations of node types
         EffectiveNodeTypeCache tmpENTCache = (EffectiveNodeTypeCache) entCache.clone();
         // map of node type names and node type definitions
-        Map tmpNTDefCache = new HashMap(registeredNTDefs);
+        Map<Name, NodeTypeDef> tmpNTDefCache = new HashMap<Name, NodeTypeDef>(registeredNTDefs);
 
         // temporarily register the node type definition
         // and do some preliminary checks
-        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
-            NodeTypeDef ntd = (NodeTypeDef) iter.next();
+        for (NodeTypeDef ntd : ntDefs) {
             Name name = ntd.getName();
             if (name != null && registeredNTDefs.containsKey(name)) {
                 String msg = name + " already exists";
@@ -1298,12 +1283,9 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
             tmpNTDefCache.put(ntd.getName(), ntd);
         }
 
-        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
-            NodeTypeDef ntd = (NodeTypeDef) iter.next();
-
-            EffectiveNodeType ent =
-                    validateNodeTypeDef(ntd, tmpENTCache, tmpNTDefCache, nsReg,
-                            lenient);
+        for (NodeTypeDef ntd : ntDefs) {
+            EffectiveNodeType ent = validateNodeTypeDef(ntd, tmpENTCache,
+                    tmpNTDefCache, nsReg, lenient);
 
             // store new effective node type instance
             tmpENTCache.put(ent);
@@ -1311,20 +1293,18 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
 
         // since no exception was thrown so far the definitions are assumed to
         // be valid
-        for (Iterator iter = ntDefs.iterator(); iter.hasNext();) {
-            NodeTypeDef ntd = (NodeTypeDef) iter.next();
-
+        for (NodeTypeDef ntd : ntDefs) {
             // register clone of node type definition
             ntd = (NodeTypeDef) ntd.clone();
             registeredNTDefs.put(ntd.getName(), ntd);
             // store property & child node definitions of new node type by id
             PropDef[] pda = ntd.getPropertyDefs();
-            for (int i = 0; i < pda.length; i++) {
-                propDefs.put(pda[i].getId(), pda[i]);
+            for (PropDef aPda : pda) {
+                propDefs.put(aPda.getId(), aPda);
             }
             NodeDef[] nda = ntd.getChildNodeDefs();
-            for (int i = 0; i < nda.length; i++) {
-                nodeDefs.put(nda[i].getId(), nda[i]);
+            for (NodeDef aNda : nda) {
+                nodeDefs.put(aNda.getId(), aNda);
             }
         }
 
@@ -1333,7 +1313,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
     }
 
     private void internalUnregister(Name name) throws NoSuchNodeTypeException {
-        NodeTypeDef ntd = (NodeTypeDef) registeredNTDefs.get(name);
+        NodeTypeDef ntd = registeredNTDefs.get(name);
         if (ntd == null) {
             throw new NoSuchNodeTypeException(name.toString());
         }
@@ -1342,19 +1322,18 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
 
         // remove property & child node definitions
         PropDef[] pda = ntd.getPropertyDefs();
-        for (int i = 0; i < pda.length; i++) {
-            propDefs.remove(pda[i].getId());
+        for (PropDef aPda : pda) {
+            propDefs.remove(aPda.getId());
         }
         NodeDef[] nda = ntd.getChildNodeDefs();
-        for (int i = 0; i < nda.length; i++) {
-            nodeDefs.remove(nda[i].getId());
+        for (NodeDef aNda : nda) {
+            nodeDefs.remove(aNda.getId());
         }
     }
 
-    private void internalUnregister(Collection ntNames)
+    private void internalUnregister(Collection<Name> ntNames)
             throws NoSuchNodeTypeException {
-        for (Iterator iter = ntNames.iterator(); iter.hasNext();) {
-            Name name = (Name) iter.next();
+        for (Name name : ntNames) {
             internalUnregister(name);
         }
     }
@@ -1380,18 +1359,18 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
      * Validates the specified <code>NodeTypeDef</code> within the context of
      * the two other given collections and returns an <code>EffectiveNodeType</code>.
      *
-     * @param ntd
-     * @param entCache
+     * @param ntd node type definition
+     * @param entCache effective node type cache
      * @param ntdCache cache of 'known' node type definitions, used to resolve dependencies
      * @param nsReg    namespace registry used for validatingatch names
      * @param lenient flag governing whether validation can be lenient or has to be strict
      * @return an effective node type representation of the specified <code>NodeTypeDef</code>
-     * @throws InvalidNodeTypeDefException
+     * @throws InvalidNodeTypeDefException if the node type is not valid
      * @throws RepositoryException         if another error occurs
      */
     private static EffectiveNodeType validateNodeTypeDef(NodeTypeDef ntd,
                                                          EffectiveNodeTypeCache entCache,
-                                                         Map ntdCache,
+                                                         Map<Name, NodeTypeDef> ntdCache,
                                                          NamespaceRegistry nsReg,
                                                          boolean lenient)
             throws InvalidNodeTypeDefException, RepositoryException {
@@ -1417,21 +1396,21 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
         // validate supertypes
         Name[] supertypes = ntd.getSupertypes();
         if (supertypes.length > 0) {
-            for (int i = 0; i < supertypes.length; i++) {
-                checkNamespace(supertypes[i], nsReg);
+            for (Name supertype : supertypes) {
+                checkNamespace(supertype, nsReg);
                 /**
                  * simple check for infinite recursion
                  * (won't trap recursion on a deeper inheritance level)
                  */
-                if (name.equals(supertypes[i])) {
+                if (name.equals(supertype)) {
                     String msg = "[" + name + "] invalid supertype: "
-                            + supertypes[i] + " (infinite recursion))";
+                            + supertype + " (infinite recursion))";
                     log.debug(msg);
                     throw new InvalidNodeTypeDefException(msg);
                 }
-                if (!ntdCache.containsKey(supertypes[i])) {
+                if (!ntdCache.containsKey(supertype)) {
                     String msg = "[" + name + "] invalid supertype: "
-                            + supertypes[i];
+                            + supertype;
                     log.debug(msg);
                     throw new InvalidNodeTypeDefException(msg);
                 }
@@ -1441,7 +1420,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
              * check for circularity in inheritance chain
              * ('a' extends 'b' extends 'a')
              */
-            Stack inheritanceChain = new Stack();
+            Stack<Name> inheritanceChain = new Stack<Name>();
             inheritanceChain.push(name);
             checkForCircularInheritance(supertypes, inheritanceChain, ntdCache);
         }
@@ -1494,8 +1473,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
 
         // validate property definitions
         PropDef[] pda = ntd.getPropertyDefs();
-        for (int i = 0; i < pda.length; i++) {
-            PropDef pd = pda[i];
+        for (PropDef pd : pda) {
             /**
              * sanity check:
              * make sure declaring node type matches name of node type definition
@@ -1529,11 +1507,11 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
             InternalValue[] defVals = pd.getDefaultValues();
             if (defVals != null && defVals.length != 0) {
                 int reqType = pd.getRequiredType();
-                for (int j = 0; j < defVals.length; j++) {
+                for (InternalValue defVal : defVals) {
                     if (reqType == PropertyType.UNDEFINED) {
-                        reqType = defVals[j].getType();
+                        reqType = defVal.getType();
                     } else {
-                        if (defVals[j].getType() != reqType) {
+                        if (defVal.getType() != reqType) {
                             String msg = "[" + name + "#" + pd.getName()
                                     + "] type of default value(s) is not consistent with required property type";
                             log.debug(msg);
@@ -1559,19 +1537,18 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
             if (constraints != null && constraints.length > 0) {
                 if (defVals != null && defVals.length > 0) {
                     // check value constraints on every value
-                    for (int j = 0; j < defVals.length; j++) {
+                    for (InternalValue defVal : defVals) {
                         // constraints are OR-ed together
                         boolean satisfied = false;
                         ConstraintViolationException cve = null;
-                        for (int k = 0; k < constraints.length; k++) {
+                        for (QValueConstraint constraint : constraints) {
                             try {
-                                constraints[k].check(defVals[j]);
+                                constraint.check(defVal);
                                 // at least one constraint is satisfied
                                 satisfied = true;
                                 break;
                             } catch (ConstraintViolationException e) {
                                 cve = e;
-                                continue;
                             }
                         }
                         if (!satisfied) {
@@ -1609,8 +1586,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
 
         // validate child-node definitions
         NodeDef[] cnda = ntd.getChildNodeDefs();
-        for (int i = 0; i < cnda.length; i++) {
-            NodeDef cnd = cnda[i];
+        for (NodeDef cnd : cnda) {
             /**
              * sanity check:
              * make sure declaring node type matches name of node type definition
@@ -1679,7 +1655,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
                          * of auto-created child nodes (node type 'a' defines
                          * auto-created child node with default primary type 'a')
                          */
-                        Stack definingNTs = new Stack();
+                        Stack<Name> definingNTs = new Stack<Name>();
                         definingNTs.push(name);
                         checkForCircularNodeAutoCreation(defaultENT, definingNTs, entCache, ntdCache);
                     }
@@ -1699,8 +1675,7 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
             // check required primary types
             Name[] reqTypes = cnd.getRequiredPrimaryTypes();
             if (reqTypes != null && reqTypes.length > 0) {
-                for (int n = 0; n < reqTypes.length; n++) {
-                    Name rpt = reqTypes[n];
+                for (Name rpt : reqTypes) {
                     checkNamespace(rpt, nsReg);
                     referenceToSelf = false;
                     /**
@@ -1802,45 +1777,45 @@ public class NodeTypeRegistry implements Dumpable, NodeTypeEventListener {
 
     /**
      * Notify the listeners that a node type <code>ntName</code> has been registered.
+     * @param ntName node type name
      */
     private void notifyRegistered(Name ntName) {
         // copy listeners to array to avoid ConcurrentModificationException
-        NodeTypeRegistryListener[] la =
-                (NodeTypeRegistryListener[]) listeners.values().toArray(
+        NodeTypeRegistryListener[] la = listeners.values().toArray(
                         new NodeTypeRegistryListener[listeners.size()]);
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] != null) {
-                la[i].nodeTypeRegistered(ntName);
+        for (NodeTypeRegistryListener aLa : la) {
+            if (aLa != null) {
+                aLa.nodeTypeRegistered(ntName);
             }
         }
     }
 
     /**
      * Notify the listeners that a node type <code>ntName</code> has been re-registered.
+     * @param ntName node type name
      */
     private void notifyReRegistered(Name ntName) {
         // copy listeners to array to avoid ConcurrentModificationException
-        NodeTypeRegistryListener[] la =
-                (NodeTypeRegistryListener[]) listeners.values().toArray(
+        NodeTypeRegistryListener[] la = listeners.values().toArray(
                         new NodeTypeRegistryListener[listeners.size()]);
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] != null) {
-                la[i].nodeTypeReRegistered(ntName);
+        for (NodeTypeRegistryListener aLa : la) {
+            if (aLa != null) {
+                aLa.nodeTypeReRegistered(ntName);
             }
         }
     }
 
     /**
      * Notify the listeners that a node type <code>ntName</code> has been unregistered.
+     * @param ntName node type name
      */
     private void notifyUnregistered(Name ntName) {
         // copy listeners to array to avoid ConcurrentModificationException
-        NodeTypeRegistryListener[] la =
-                (NodeTypeRegistryListener[]) listeners.values().toArray(
+        NodeTypeRegistryListener[] la = listeners.values().toArray(
                         new NodeTypeRegistryListener[listeners.size()]);
-        for (int i = 0; i < la.length; i++) {
-            if (la[i] != null) {
-                la[i].nodeTypeUnregistered(ntName);
+        for (NodeTypeRegistryListener aLa : la) {
+            if (aLa != null) {
+                aLa.nodeTypeUnregistered(ntName);
             }
         }
     }
